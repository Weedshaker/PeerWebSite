!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);void 0!==c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&"undefined"!=typeof require.resolve&&"undefined"!=typeof process&&process.platform&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1","2"], [], true, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(u),t=(r[1].split(",")[n]||"require").replace(s,""),i=p[t]||(p[t]=new RegExp(a+t+f,"g"));i.lastIndex=0;for(var o,c=[];o=i.exec(e);)c.push(o[2]||o[3]);return c}function r(e,n,t,o){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var l=i.get(e);return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var a=[],f=0;f<e.length;f++)a.push(i["import"](e[f],o));Promise.all(a).then(function(e){n&&n.apply(null,e)},t)}function t(t,l,a){"string"!=typeof t&&(a=l,l=t,t=null),l instanceof Array||(a=l,l=["require","exports","module"].splice(0,a.length)),"function"!=typeof a&&(a=function(e){return function(){return e}}(a)),void 0===l[l.length-1]&&l.pop();var f,u,s;-1!=(f=o.call(l,"require"))&&(l.splice(f,1),t||(l=l.concat(n(a.toString(),f)))),-1!=(u=o.call(l,"exports"))&&l.splice(u,1),-1!=(s=o.call(l,"module"))&&l.splice(s,1);var p={name:t,deps:l,execute:function(n,t,o){for(var p=[],c=0;c<l.length;c++)p.push(n(l[c]));o.uri=o.id,o.config=function(){},-1!=s&&p.splice(s,0,o),-1!=u&&p.splice(u,0,t),-1!=f&&p.splice(f,0,function(e,t,l){return"string"==typeof e&&"function"!=typeof t?n(e):r.call(i,e,t,l,o.id)});var d=a.apply(-1==u?e:t,p);return"undefined"==typeof d&&o&&(d=o.exports),"undefined"!=typeof d?d:void 0}};if(t)c.anonDefine||c.isBundle?c.anonDefine&&c.anonDefine.name&&(c.anonDefine=null):c.anonDefine=p,c.isBundle=!0,i.registerDynamic(p.name,p.deps,!1,p.execute);else{if(c.anonDefine&&!c.anonDefine.name)throw new Error("Multiple anonymous defines in module "+t);c.anonDefine=p}}var i=$__System,o=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,a="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",u=/\(([^\)]*)\)/,s=/^\s+|\s+$/g,p={};t.amd={};var c={isBundle:!1,anonDefine:null};i.amdDefine=t,i.amdRequire=r}("undefined"!=typeof self?self:global);
$__System.registerDynamic("1", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    System.config({
      baseURL: "./",
      defaultJSExtensions: true,
      transpiler: "babel",
      babelOptions: {
        "optional": ["runtime", "optimisation.modules.system"]
      },
      paths: {
        "*": "./JavaScript/js/*",
        "mock/*": "./JavaScript/mock/*",
        "./*": "./*",
        "github:*": "jspm_packages/github/*",
        "npm:*": "jspm_packages/npm/*"
      },

      packages: {
        "summernote/summernote": {
          "format": "cjs"
        }
      },

      meta: {
        "*/RTCMultiConnection.js": {
          "format": "global"
        },
        "Editor/lib/codemirror/codemirror.js": {
          "format": "global"
        },
        "Editor/lib/codemirror/css.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        },
        "Editor/lib/codemirror/formatting.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        },
        "Editor/lib/codemirror/htmlmixed.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        },
        "Editor/lib/codemirror/javascript.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        },
        "Editor/lib/codemirror/xml.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        }
      },

      map: {
        "AkeemMcLennon/dom2hscript": "github:AkeemMcLennon/dom2hscript@master",
        "Weedshaker/virtual-dom": "github:Weedshaker/virtual-dom@2.1.2",
        "babel": "npm:babel-core@5.8.38",
        "babel-runtime": "npm:babel-runtime@5.8.38",
        "bootstrap": "github:twbs/bootstrap@3.3.7",
        "capaj/systemjs-hot-reloader": "github:alexisvincent/systemjs-hot-reloader@0.6.0",
        "core-js": "npm:core-js@1.2.7",
        "hockic/summernote-ext-filedialog": "github:hockic/summernote-ext-filedialog@master",
        "jquery": "npm:jquery@3.3.1",
        "muaz-khan/RTCMultiConnection": "github:muaz-khan/RTCMultiConnection@3.4.4",
        "parse-torrent": "npm:parse-torrent@5.8.3",
        "pieroxy/lz-string": "github:pieroxy/lz-string@1.4.4",
        "socket.io-client": "github:socketio/socket.io-client@1.7.4",
        "summernote/summernote": "github:summernote/summernote@0.8.16",
        "tanaka-de-silva/google-diff-match-patch-js": "github:tanaka-de-silva/google-diff-match-patch-js@1.0.0",
        "webtorrent/webtorrent": "github:webtorrent/webtorrent@0.108.1",
        "xuset/indexeddb-chunk-store": "github:xuset/indexeddb-chunk-store@2.2.1",
        "github:alexisvincent/systemjs-hot-reloader@0.6.0": {
          "debug": "npm:debug@2.6.9",
          "socket.io-client": "github:socketio/socket.io-client@1.7.4",
          "weakee": "npm:weakee@1.0.0"
        },
        "github:jspm/nodelibs-assert@0.1.0": {
          "assert": "npm:assert@1.4.1"
        },
        "github:jspm/nodelibs-buffer@0.1.1": {
          "buffer": "npm:buffer@5.1.0"
        },
        "github:jspm/nodelibs-constants@0.1.0": {
          "constants-browserify": "npm:constants-browserify@0.0.1"
        },
        "github:jspm/nodelibs-crypto@0.1.0": {
          "crypto-browserify": "npm:crypto-browserify@3.12.0"
        },
        "github:jspm/nodelibs-events@0.1.1": {
          "events": "npm:events@1.0.2"
        },
        "github:jspm/nodelibs-http@1.7.1": {
          "Base64": "npm:Base64@0.2.1",
          "events": "github:jspm/nodelibs-events@0.1.1",
          "inherits": "npm:inherits@2.0.1",
          "stream": "github:jspm/nodelibs-stream@0.1.0",
          "url": "github:jspm/nodelibs-url@0.1.0",
          "util": "github:jspm/nodelibs-util@0.1.0"
        },
        "github:jspm/nodelibs-https@0.1.0": {
          "https-browserify": "npm:https-browserify@0.0.0"
        },
        "github:jspm/nodelibs-path@0.1.0": {
          "path-browserify": "npm:path-browserify@0.0.0"
        },
        "github:jspm/nodelibs-process@0.1.2": {
          "process": "npm:process@0.11.10"
        },
        "github:jspm/nodelibs-querystring@0.1.0": {
          "querystring": "npm:querystring@0.2.0"
        },
        "github:jspm/nodelibs-stream@0.1.0": {
          "stream-browserify": "npm:stream-browserify@1.0.0"
        },
        "github:jspm/nodelibs-string_decoder@0.1.0": {
          "string_decoder": "npm:string_decoder@0.10.31"
        },
        "github:jspm/nodelibs-url@0.1.0": {
          "url": "npm:url@0.10.3"
        },
        "github:jspm/nodelibs-util@0.1.0": {
          "util": "npm:util@0.10.3"
        },
        "github:jspm/nodelibs-vm@0.1.0": {
          "vm-browserify": "npm:vm-browserify@0.0.4"
        },
        "github:twbs/bootstrap@3.3.7": {
          "jquery": "npm:jquery@3.3.1"
        },
        "npm:asn1.js@4.10.1": {
          "bn.js": "npm:bn.js@4.11.8",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0",
          "vm": "github:jspm/nodelibs-vm@0.1.0"
        },
        "npm:assert@1.4.1": {
          "assert": "github:jspm/nodelibs-assert@0.1.0",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "util": "npm:util@0.10.3"
        },
        "npm:babel-runtime@5.8.38": {
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:bencode@2.0.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:blob-to-buffer@1.2.7": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:browserify-aes@1.1.1": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "buffer-xor": "npm:buffer-xor@1.0.3",
          "cipher-base": "npm:cipher-base@1.0.4",
          "create-hash": "npm:create-hash@1.1.3",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "evp_bytestokey": "npm:evp_bytestokey@1.0.3",
          "inherits": "npm:inherits@2.0.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:browserify-cipher@1.0.0": {
          "browserify-aes": "npm:browserify-aes@1.1.1",
          "browserify-des": "npm:browserify-des@1.0.0",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "evp_bytestokey": "npm:evp_bytestokey@1.0.3"
        },
        "npm:browserify-des@1.0.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "cipher-base": "npm:cipher-base@1.0.4",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "des.js": "npm:des.js@1.0.0",
          "inherits": "npm:inherits@2.0.1"
        },
        "npm:browserify-rsa@4.0.1": {
          "bn.js": "npm:bn.js@4.11.8",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "constants": "github:jspm/nodelibs-constants@0.1.0",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "randombytes": "npm:randombytes@2.0.6"
        },
        "npm:browserify-sign@4.0.4": {
          "bn.js": "npm:bn.js@4.11.8",
          "browserify-rsa": "npm:browserify-rsa@4.0.1",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "create-hash": "npm:create-hash@1.1.3",
          "create-hmac": "npm:create-hmac@1.1.6",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "elliptic": "npm:elliptic@6.4.0",
          "inherits": "npm:inherits@2.0.1",
          "parse-asn1": "npm:parse-asn1@5.1.0",
          "stream": "github:jspm/nodelibs-stream@0.1.0",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:buffer-xor@1.0.3": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:buffer@5.1.0": {
          "base64-js": "npm:base64-js@1.3.0",
          "ieee754": "npm:ieee754@1.1.12"
        },
        "npm:cipher-base@1.0.4": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "stream": "github:jspm/nodelibs-stream@0.1.0",
          "string_decoder": "github:jspm/nodelibs-string_decoder@0.1.0"
        },
        "npm:constants-browserify@0.0.1": {
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:core-js@1.2.7": {
          "fs": "github:jspm/nodelibs-fs@0.1.2",
          "path": "github:jspm/nodelibs-path@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:core-util-is@1.0.2": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:create-ecdh@4.0.0": {
          "bn.js": "npm:bn.js@4.11.8",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "elliptic": "npm:elliptic@6.4.0"
        },
        "npm:create-hash@1.1.3": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "cipher-base": "npm:cipher-base@1.0.4",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "inherits": "npm:inherits@2.0.1",
          "ripemd160": "npm:ripemd160@2.0.1",
          "sha.js": "npm:sha.js@2.4.10"
        },
        "npm:create-hmac@1.1.6": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "cipher-base": "npm:cipher-base@1.0.4",
          "create-hash": "npm:create-hash@1.1.3",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "inherits": "npm:inherits@2.0.1",
          "ripemd160": "npm:ripemd160@2.0.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "sha.js": "npm:sha.js@2.4.10"
        },
        "npm:crypto-browserify@3.12.0": {
          "browserify-cipher": "npm:browserify-cipher@1.0.0",
          "browserify-sign": "npm:browserify-sign@4.0.4",
          "create-ecdh": "npm:create-ecdh@4.0.0",
          "create-hash": "npm:create-hash@1.1.3",
          "create-hmac": "npm:create-hmac@1.1.6",
          "diffie-hellman": "npm:diffie-hellman@5.0.2",
          "inherits": "npm:inherits@2.0.1",
          "pbkdf2": "npm:pbkdf2@3.0.14",
          "public-encrypt": "npm:public-encrypt@4.0.0",
          "randombytes": "npm:randombytes@2.0.6",
          "randomfill": "npm:randomfill@1.0.4"
        },
        "npm:debug@2.6.9": {
          "ms": "npm:ms@2.0.0"
        },
        "npm:des.js@1.0.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.1",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0"
        },
        "npm:diffie-hellman@5.0.2": {
          "bn.js": "npm:bn.js@4.11.8",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "miller-rabin": "npm:miller-rabin@4.0.1",
          "randombytes": "npm:randombytes@2.0.6",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:elliptic@6.4.0": {
          "bn.js": "npm:bn.js@4.11.8",
          "brorand": "npm:brorand@1.1.0",
          "hash.js": "npm:hash.js@1.1.3",
          "hmac-drbg": "npm:hmac-drbg@1.0.1",
          "inherits": "npm:inherits@2.0.1",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0",
          "minimalistic-crypto-utils": "npm:minimalistic-crypto-utils@1.0.1",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:evp_bytestokey@1.0.3": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "md5.js": "npm:md5.js@1.3.4",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:get-stdin@5.0.1": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:hash-base@2.0.2": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "stream": "github:jspm/nodelibs-stream@0.1.0"
        },
        "npm:hash-base@3.0.4": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "stream": "github:jspm/nodelibs-stream@0.1.0"
        },
        "npm:hash.js@1.1.3": {
          "inherits": "npm:inherits@2.0.3",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0"
        },
        "npm:hmac-drbg@1.0.1": {
          "hash.js": "npm:hash.js@1.1.3",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0",
          "minimalistic-crypto-utils": "npm:minimalistic-crypto-utils@1.0.1",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:https-browserify@0.0.0": {
          "http": "github:jspm/nodelibs-http@1.7.1"
        },
        "npm:inherits@2.0.1": {
          "util": "github:jspm/nodelibs-util@0.1.0"
        },
        "npm:inherits@2.0.3": {
          "util": "github:jspm/nodelibs-util@0.1.0"
        },
        "npm:magnet-uri@5.1.7": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "thirty-two": "npm:thirty-two@1.0.2",
          "uniq": "npm:uniq@1.0.1",
          "xtend": "npm:xtend@4.0.1"
        },
        "npm:md5.js@1.3.4": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "hash-base": "npm:hash-base@3.0.4",
          "inherits": "npm:inherits@2.0.1"
        },
        "npm:miller-rabin@4.0.1": {
          "bn.js": "npm:bn.js@4.11.8",
          "brorand": "npm:brorand@1.1.0"
        },
        "npm:once@1.4.0": {
          "wrappy": "npm:wrappy@1.0.2"
        },
        "npm:parse-asn1@5.1.0": {
          "asn1.js": "npm:asn1.js@4.10.1",
          "browserify-aes": "npm:browserify-aes@1.1.1",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "create-hash": "npm:create-hash@1.1.3",
          "evp_bytestokey": "npm:evp_bytestokey@1.0.3",
          "pbkdf2": "npm:pbkdf2@3.0.14",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:parse-torrent-file@4.1.0": {
          "bencode": "npm:bencode@2.0.0",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "path": "github:jspm/nodelibs-path@0.1.0",
          "simple-sha1": "npm:simple-sha1@2.1.0",
          "uniq": "npm:uniq@1.0.1"
        },
        "npm:parse-torrent@5.8.3": {
          "blob-to-buffer": "npm:blob-to-buffer@1.2.7",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "fs": "github:jspm/nodelibs-fs@0.1.2",
          "get-stdin": "npm:get-stdin@5.0.1",
          "magnet-uri": "npm:magnet-uri@5.1.7",
          "parse-torrent-file": "npm:parse-torrent-file@4.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "simple-get": "npm:simple-get@2.7.0",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:path-browserify@0.0.0": {
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:pbkdf2@3.0.14": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "create-hash": "npm:create-hash@1.1.3",
          "create-hmac": "npm:create-hmac@1.1.6",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "ripemd160": "npm:ripemd160@2.0.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "sha.js": "npm:sha.js@2.4.10"
        },
        "npm:process@0.11.10": {
          "assert": "github:jspm/nodelibs-assert@0.1.0",
          "fs": "github:jspm/nodelibs-fs@0.1.2",
          "vm": "github:jspm/nodelibs-vm@0.1.0"
        },
        "npm:public-encrypt@4.0.0": {
          "bn.js": "npm:bn.js@4.11.8",
          "browserify-rsa": "npm:browserify-rsa@4.0.1",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "create-hash": "npm:create-hash@1.1.3",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "parse-asn1": "npm:parse-asn1@5.1.0",
          "randombytes": "npm:randombytes@2.0.6"
        },
        "npm:punycode@1.3.2": {
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:randombytes@2.0.6": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:randomfill@1.0.4": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "randombytes": "npm:randombytes@2.0.6",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:readable-stream@1.1.14": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "core-util-is": "npm:core-util-is@1.0.2",
          "events": "github:jspm/nodelibs-events@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "isarray": "npm:isarray@0.0.1",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "stream-browserify": "npm:stream-browserify@1.0.0",
          "string_decoder": "npm:string_decoder@0.10.31"
        },
        "npm:ripemd160@2.0.1": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "hash-base": "npm:hash-base@2.0.2",
          "inherits": "npm:inherits@2.0.1"
        },
        "npm:rusha@0.8.13": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:safe-buffer@5.1.1": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:sha.js@2.4.10": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "fs": "github:jspm/nodelibs-fs@0.1.2",
          "inherits": "npm:inherits@2.0.1",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:simple-concat@1.0.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:simple-get@2.7.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "http": "github:jspm/nodelibs-http@1.7.1",
          "https": "github:jspm/nodelibs-https@0.1.0",
          "once": "npm:once@1.4.0",
          "querystring": "github:jspm/nodelibs-querystring@0.1.0",
          "simple-concat": "npm:simple-concat@1.0.0",
          "url": "github:jspm/nodelibs-url@0.1.0"
        },
        "npm:simple-sha1@2.1.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "rusha": "npm:rusha@0.8.13"
        },
        "npm:stream-browserify@1.0.0": {
          "events": "github:jspm/nodelibs-events@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "readable-stream": "npm:readable-stream@1.1.14"
        },
        "npm:string_decoder@0.10.31": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:thirty-two@1.0.2": {
          "assert": "github:jspm/nodelibs-assert@0.1.0",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:url@0.10.3": {
          "assert": "github:jspm/nodelibs-assert@0.1.0",
          "punycode": "npm:punycode@1.3.2",
          "querystring": "npm:querystring@0.2.0",
          "util": "github:jspm/nodelibs-util@0.1.0"
        },
        "npm:util@0.10.3": {
          "inherits": "npm:inherits@2.0.1",
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:vm-browserify@0.0.4": {
          "indexof": "npm:indexof@0.0.1"
        }
      }
    });
  })(this);

  return _retrieveGlobal();
});
$__System.register('3', ['4', '5', '6', '7'], function (_export) {
	var MasterLastMessage, _get, _inherits, _classCallCheck, SentMessage;

	return {
		setters: [function (_4) {
			MasterLastMessage = _4.MasterLastMessage;
		}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			SentMessage = (function (_MasterLastMessage) {
				_inherits(SentMessage, _MasterLastMessage);

				function SentMessage(elID, remoteUserId) {
					_classCallCheck(this, SentMessage);

					_get(Object.getPrototypeOf(SentMessage.prototype), 'constructor', this).call(this, elID, remoteUserId);
				}

				return SentMessage;
			})(MasterLastMessage);

			_export('SentMessage', SentMessage);
		}
	};
});
$__System.registerDynamic("8", ["9"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$defineProperty = $__require("9")["default"];
  exports["default"] = function (obj, key, value) {
    if (key in obj) {
      _Object$defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  exports.__esModule = true;
});
$__System.register('4', ['7', '8', 'a'], function (_export) {
	var _classCallCheck, _defineProperty, _createClass, MasterLastMessage;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_defineProperty = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterLastMessage = (function () {
				function MasterLastMessage() {
					var elID = arguments.length <= 0 || arguments[0] === undefined ? 'sst_all' : arguments[0];
					var remoteUserId = arguments.length <= 1 || arguments[1] === undefined ? 'sst_toAll' : arguments[1];

					_classCallCheck(this, MasterLastMessage);

					this.elID = elID;
					this.remoteUserId = remoteUserId;

					// shared vars
					this.cont = _defineProperty({}, this.remoteUserId, _defineProperty({}, this.elID, '')); // sst_toAll means to all channel peers, sst_all is just a dummy class for elementID
				}

				_createClass(MasterLastMessage, [{
					key: 'set',
					value: function set(message) {
						var elID = arguments.length <= 1 || arguments[1] === undefined ? this.elID : arguments[1];
						var remoteUserId = arguments.length <= 2 || arguments[2] === undefined ? this.remoteUserId : arguments[2];

						// keep track on sent messages
						// new unique message
						if (!this.cont[remoteUserId]) {
							this.cont[remoteUserId] = {};
						}
						this.cont[remoteUserId][elID] = [new Date().getTime(), message];
					}
				}, {
					key: 'get',
					value: function get() {
						var elID = arguments.length <= 0 || arguments[0] === undefined ? this.elID : arguments[0];
						var remoteUserId = arguments.length <= 1 || arguments[1] === undefined ? this.remoteUserId : arguments[1];

						return this.cont[remoteUserId] && this.cont[remoteUserId][elID] ? this.cont[remoteUserId][elID][1] : false;
					}
				}, {
					key: 'getLatestElIDvsToAll',
					value: function getLatestElIDvsToAll() {
						var elID = arguments.length <= 0 || arguments[0] === undefined ? this.elID : arguments[0];
						var remoteUserId = arguments.length <= 1 || arguments[1] === undefined ? this.remoteUserId : arguments[1];

						if (this.cont[remoteUserId] && this.cont[remoteUserId][elID] && this.cont[this.remoteUserId][elID]) {
							return this.cont[this.remoteUserId][elID][0] > this.cont[remoteUserId][elID][0] ? this.cont[this.remoteUserId][elID][1] : this.cont[remoteUserId][elID][1];
						} else {
							return this.cont[remoteUserId] && this.cont[remoteUserId][elID] ? this.cont[remoteUserId][elID][1] : this.cont[this.remoteUserId][elID][1];
						}
					}
				}, {
					key: 'getAll',
					value: function getAll() {
						var remoteUserId = arguments.length <= 0 || arguments[0] === undefined ? this.remoteUserId : arguments[0];

						var messages = [];
						for (var key in this.cont[remoteUserId]) {
							if (this.cont[remoteUserId].hasOwnProperty(key) && this.cont[remoteUserId][key].length > 0) {
								messages.push([this.cont[remoteUserId][key][1], key, remoteUserId]);
							}
						}
						return messages;
					}
				}]);

				return MasterLastMessage;
			})();

			_export('MasterLastMessage', MasterLastMessage);
		}
	};
});
$__System.register('b', ['4', '5', '6', '7'], function (_export) {
	var MasterLastMessage, _get, _inherits, _classCallCheck, ReceivedMessage;

	return {
		setters: [function (_4) {
			MasterLastMessage = _4.MasterLastMessage;
		}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			ReceivedMessage = (function (_MasterLastMessage) {
				_inherits(ReceivedMessage, _MasterLastMessage);

				function ReceivedMessage(elID, remoteUserId) {
					_classCallCheck(this, ReceivedMessage);

					_get(Object.getPrototypeOf(ReceivedMessage.prototype), 'constructor', this).call(this, elID, remoteUserId);

					this.cont = {};
				}

				return ReceivedMessage;
			})(MasterLastMessage);

			_export('ReceivedMessage', ReceivedMessage);
		}
	};
});
$__System.register('c', ['5', '6', '7', '10', 'a', 'd', 'e', 'f'], function (_export) {
	var _get, _inherits, _classCallCheck, _Map, _createClass, MasterOption, Diff_match_patchWorker, LZStringWorker, OptionSender;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			_Map = _4['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {
			MasterOption = _d.MasterOption;
		}, function (_e) {
			Diff_match_patchWorker = _e.Diff_match_patchWorker;
		}, function (_f) {
			LZStringWorker = _f.LZStringWorker;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			OptionSender = (function (_MasterOption) {
				_inherits(OptionSender, _MasterOption);

				function OptionSender(SentMessage, returnMap) {
					var _this = this;

					_classCallCheck(this, OptionSender);

					_get(Object.getPrototypeOf(OptionSender.prototype), 'constructor', this).call(this, returnMap);

					this.SentMessage = SentMessage;
					// workers can only handle arrays in their data -> setOptions and getOptions has to be used to map to array
					/**
      * (api hook)
      * setOptions & getOptions convert map to array according to the number passed to the map at value array[0], since webworker can't handle send/receive Objects like Map
      * 
      * @param {Map([['diffed', [0, true]], ['compressed', [1, 'auto']]])} options
      * @memberof OptionSender
      */
					this.options = new _Map([['diffed', [0, true]],
					//['diffed', [0, false]],
					['compressed', [1, 'auto']]
					//['compressed', [1, false]]
					]);

					// workers
					this.Diff_match_patchWorker = new Diff_match_patchWorker();
					this.Diff_match_patchWorker.create(this.Diff_match_patchWorker.sendDiff, function (result) {
						_this.returnApply('sendDiff', result);
					});
					this.LZStringWorker = new LZStringWorker();
					this.LZStringWorker.create(this.LZStringWorker.sendCompress, function (result) {
						_this.returnApply('sendCompress', result);
					});
				}

				_createClass(OptionSender, [{
					key: 'init',
					value: function init() {
						for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
							data[_key] = arguments[_key];
						}

						data.push(this.optionsConvertMapToArray(data.pop()));
						_get(Object.getPrototypeOf(OptionSender.prototype), 'init', this).apply(this, data);
					}
				}, {
					key: 'sendDiff',
					value: function sendDiff(message, elID, remoteUserId, requestID, options) {
						var result = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

						if (this.getOptions('diffed', options)) {
							var oldMessage = this.SentMessage.get(elID, remoteUserId);
							if (oldMessage && oldMessage.length > 0 && message[1] !== oldMessage) {
								this.Diff_match_patchWorker.run([oldMessage, message, elID, remoteUserId, requestID, options, result]);
								return true;
							}
						}
						// whole message
						result.push('sendDiff:false');
						this.returnApply('sendDiff', [message, elID, remoteUserId, requestID, options, result]);
						return false;
					}
				}, {
					key: 'sendCompress',
					value: function sendCompress(message, elID, remoteUserId, requestID, options) {
						var result = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

						// compression: false (68kB in 68, 1MB in 2317),
						// Uint8Array (68kB in 91, 1MB in 6218),
						// EncodedURIComponent (68kB in 48, 1MB in 2484),
						// auto (chooses fastest compression 'EncodedURIComponent', if no base64 in message)
						var compressed = this.getOptions('compressed', options);
						if (compressed === 'auto') {
							compressed = message[1].indexOf('base64') === -1 ? 'EncodedURIComponent' : false;
							// set the options to the changed parameter, used insed message info for receive/decompress
							options = this.setOptions('compressed', compressed, options);
						}
						if (compressed) {
							this.LZStringWorker.run([compressed, message, elID, remoteUserId, requestID, options, result]);
							return true;
						}
						// whole message
						result.push('sendCompress:false');
						this.returnApply('sendCompress', [message, elID, remoteUserId, requestID, options, result]);
						return false;
					}

					// workers can only handle arrays in their data -> setOptions and getOptions has to be used to map to array
				}, {
					key: 'optionsConvertMapToArray',
					value: function optionsConvertMapToArray(map) {
						var _this2 = this;

						if (map instanceof _Map) {
							var _ret = (function () {
								var arr = [];
								map.forEach(function (value, key) {
									var i = _this2.options.get(key)[0];
									arr[i] = value;
								});
								return {
									v: arr
								};
							})();

							if (typeof _ret === 'object') return _ret.v;
						}
						return [];
					}
				}, {
					key: 'setOptions',
					value: function setOptions(name, prop) {
						var options = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

						var i = this.options.get(name)[0];
						options[i] = prop;
						return options;
					}
				}, {
					key: 'getOptions',
					value: function getOptions(name) {
						var options = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

						var i = this.options.get(name)[0];
						return options[i] !== undefined ? options[i] : this.options.get(name)[1];
					}
				}, {
					key: 'getCompressedStatus',
					value: function getCompressedStatus(options) {
						var compressed = this.getOptions('compressed', options) === 'auto' ? false : this.getOptions('compressed', options);
						return compressed ? compressed : false;
					}
				}]);

				return OptionSender;
			})(MasterOption);

			_export('OptionSender', OptionSender);
		}
	};
});
$__System.register('11', ['7', '12', 'a', 'c'], function (_export) {
	var _classCallCheck, Helper, _createClass, OptionSender, MasterSender;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			Helper = _2.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			OptionSender = _c.OptionSender;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterSender = (function () {
				function MasterSender(connection, SentMessage) {
					_classCallCheck(this, MasterSender);

					this.connection = connection;
					this.SentMessage = SentMessage;

					this.Helper = new Helper();
					this.OptionSender = new OptionSender(this.SentMessage);
					this.OptionSender.returnMap.set('init', [this.OptionSender.sendDiff, this.OptionSender]);
					this.OptionSender.returnMap.set('sendDiff', [this.OptionSender.sendCompress, this.OptionSender]);
					this.OptionSender.returnMap.set('sendCompress', [this.send, this]);
					this.changeDelay = 1000;
					this.timeout = true;
					this.timeoutCont = null; // used internal when timeout true
					this.chunkSize = this.connection.chunkSize || 1000;
					this.chunkSizeRegEx = new RegExp('(.|[\r\n]){1,' + this.chunkSize + '}', 'g');
				}

				/**
     * message, elID (used for Diff_match_patch), remoteUserId (@user), requestID (used at sendRequest)
     * sendEvent (api hook)
     * 
     * @param {string} message 
     * @param {string} [elID=this.SentMessage.elID] 
     * @param {string} [remoteUserId=this.SentMessage.remoteUserId] 
     * @param {string} [requestID=''] 
     * @param {boolean} [timeout=this.timeout] 
     * @param {Map} options 
     * @memberof MasterSender
     */

				_createClass(MasterSender, [{
					key: 'sendEvent',
					value: function sendEvent(message, elID, remoteUserId, requestID, timeout, options) {
						if (elID === undefined) elID = this.SentMessage.elID;
						if (remoteUserId === undefined) remoteUserId = this.SentMessage.remoteUserId;
						if (requestID === undefined) requestID = '';
						if (timeout === undefined) timeout = this.timeout;

						var _this = this;

						var forceSending = arguments.length <= 6 || arguments[6] === undefined ? false : arguments[6];

						if (this.connection.getAllParticipants().length > 0 && message.length > 0) {
							//console.log(`send: ${message}`);
							if (timeout) {
								clearTimeout(this.timeoutCont);
								this.timeoutCont = setTimeout(function () {
									if (message !== _this.SentMessage.get(elID, remoteUserId) || forceSending) {
										// make a backup of the message and doublicate to [rawMessage, message]
										_this.OptionSender.init([message, message], elID, remoteUserId, requestID, options);
									}
								}, this.changeDelay);
							} else {
								if (message !== this.SentMessage.get(elID, remoteUserId) || forceSending) {
									// make a backup of the message and doublicate to [rawMessage, message]
									this.OptionSender.init([message, message], elID, remoteUserId, requestID, options);
								}
							}
						} else {
							console.info('SST: Not connected!');
						}
					}

					// message = [rawMessage, message]
				}, {
					key: 'send',
					value: function send(message, elID, remoteUserId, requestID, options) {
						var _this2 = this;

						// set rawMessage
						this.SentMessage.set(message[0], elID, remoteUserId);
						// check compression
						var compressed = this.OptionSender.getCompressedStatus(options);
						var chunks = message[1].toString().match(this.chunkSizeRegEx);
						if (chunks.length > 0) {
							var toAll = remoteUserId === this.SentMessage.remoteUserId || !remoteUserId;
							var remoteUserIds = toAll ? this.connection.getAllParticipants() : [remoteUserId];
							remoteUserIds.forEach(function (remoteUserId) {
								var remoteUser = _this2.connection.peers[remoteUserId];
								if (remoteUser) {
									if (!remoteUser.channels.length) {
										_this2.connection.peers[remoteUserId].createDataChannel();
										_this2.connection.renegotiate(remoteUserId);
										setTimeout(function () {
											_this2._send(chunks, elID, remoteUserId, requestID, compressed);
										}, 3000);
									}
									_this2._send(chunks, elID, remoteUserId, requestID, compressed);
									return true;
								} else {
									console.warn('SST: Unable to send message to ' + remoteUserId + '. No connection.peers found!');
								}
							});
						}
						return false;
					}
				}, {
					key: '_send',
					value: function _send(chunks, elID, remoteUserId, requestID) {
						var compressed = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];

						var uuid = this.Helper.getRandomString();
						if (this.connection.peers[remoteUserId]) {
							this.connection.peers[remoteUserId].channels.forEach(function (channel) {
								chunks.forEach(function (chunk, i) {
									var info = [uuid, elID, requestID, compressed, i + 1, chunks.length, new Date().getTime()];
									channel.send(chunk + '(sst:' + info.toString() + ')');
								});
							});
						}
					}
				}, {
					key: 'setIgnoreOption',
					value: function setIgnoreOption() {
						// skip with binding this.send
						this.oldInit = this.OptionSender.init;
						this.OptionSender.init = this.send.bind(this);
					}
				}, {
					key: 'unsetIgnoreOption',
					value: function unsetIgnoreOption() {
						// skip with binding this.send
						this.OptionSender.init = this.oldInit ? this.oldInit : this.OptionSender.init;
					}
				}]);

				return MasterSender;
			})();

			_export('MasterSender', MasterSender);
		}
	};
});
$__System.register('13', ['5', '6', '7', '11'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterSender, Sender;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterSender = _4.MasterSender;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Sender = (function (_MasterSender) {
				_inherits(Sender, _MasterSender);

				function Sender(connection, SentMessage) {
					_classCallCheck(this, Sender);

					_get(Object.getPrototypeOf(Sender.prototype), 'constructor', this).call(this, connection, SentMessage);
				}

				return Sender;
			})(MasterSender);

			_export('Sender', Sender);
		}
	};
});
$__System.register('14', ['7', '10', '12', 'a'], function (_export) {
	var _classCallCheck, _Map, Helper, _createClass, MasterConnectionEvent;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_3) {
			Helper = _3.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterConnectionEvent = (function () {
				function MasterConnectionEvent(connection, Sender, SentMessage) {
					var _this = this;

					_classCallCheck(this, MasterConnectionEvent);

					this.connection = connection;
					this.Sender = Sender;
					this.SentMessage = SentMessage;

					this.isSender = [true]; // App defines this by looking at hash
					this.openOrJoinEventDelay = 1000;
					this.newParticipantDelay = 2000;
					this.openOrJoinEventID = null;
					this.newParticipantEventID = null;
					// https://www.rtcmulticonnection.org/
					this.connection.onNewParticipant = function (participantId, userPreferences) {
						_this.newParticipant(participantId, userPreferences);
					};
					/*this.connection.onReConnecting = (event) => {
     	this.newParticipant(event.userid, undefined, true);
     };*/
					/*this.connection.onUserStatusChanged = (event) => {
     	this.newParticipant(event.userid);
     };*/
					/*this.connection.onPeerStateChanged = (state) => {
     	this.newParticipant(state.userid);
     };*/
					this.connection.onopen = function (event) {
						_this.sendMessage(event.userid, true);
					};
					/*this.connection.onSettingLocalDescription = (event) => {
     	this.newParticipant(event.userid);
     };*/
					this.connection.onclose = function (event) {
						setTimeout(function () {
							_this.updatePeerCounter();
						}, _this.openOrJoinEventDelay);
					};
					this.connection.onleave = function (event) {
						setTimeout(function () {
							_this.updatePeerCounter();
						}, _this.openOrJoinEventDelay);
					};
					this.connection.onerror = function (event) {
						setTimeout(function () {
							_this.updatePeerCounter('[ERROR! Please, reload.]');
						}, _this.openOrJoinEventDelay);
					};
					this.Helper = new Helper();
					this.onNewParticipant = this.Helper.getEventHandler(); // event handler (api hook)

					this.peerCounterElements = [];
				}

				/**
     * called from dom
     * openOrJoinEvent (api hook)
     * 
     * @param {string} roomid 
     * @param {string} [message=''] 
     * @param {string} [elID=''] 
     * @memberof MasterConnectionEvent
     */

				_createClass(MasterConnectionEvent, [{
					key: 'openOrJoinEvent',
					value: function openOrJoinEvent(roomid) {
						var message = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

						var _this2 = this;

						var elID = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
						var send = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

						clearTimeout(this.openOrJoinEventID);
						this.openOrJoinEventID = setTimeout(function () {
							_this2.connection.openOrJoin(roomid || 'predefiend-roomid');
							if (_this2.isSender[0] && send) {
								_this2.Sender.sendEvent(message, elID, undefined, undefined, false, new _Map([['diffed', false]]), true);
							}
							_this2.updatePeerCounter();
						}, this.openOrJoinEventDelay); // timeout = false, diffed = false
					}

					// called from connection
					// newParticipant
				}, {
					key: 'newParticipant',
					value: function newParticipant(remoteUserId, userPreferences) {
						var _this3 = this;

						clearTimeout(this.newParticipantEventID);
						this.newParticipantEventID = setTimeout(function () {
							if (remoteUserId !== 'sst_toAll' && userPreferences !== undefined) _this3.connection.acceptParticipationRequest(remoteUserId, userPreferences);
							_this3.updatePeerCounter();
						}, this.newParticipantDelay); // timeout = false, diffed = false
					}
				}, {
					key: 'sendMessage',
					value: function sendMessage(remoteUserId) {
						var _this4 = this;

						var force = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

						var msgElID = false;
						this.onNewParticipant.container.forEach(function (e) {
							var result = e.func.apply(e.scope, [remoteUserId].concat(e.args));
							msgElID = result.constructor === Array && result[0] && result[1] ? result : msgElID;
						});
						if (this.isSender[0]) {
							if (msgElID) {
								this.Sender.sendEvent(msgElID[0], msgElID[1], remoteUserId, undefined, false, new _Map([['diffed', false]]), force); // timeout = false, diffed = false
							} else {
									this.SentMessage.getAll().forEach(function (message) {
										_this4.Sender.sendEvent(message[0], message[1], remoteUserId, undefined, false, new _Map([['diffed', true]]), force); // timeout = false, diffed = false
									});
								}
						}
						this.updatePeerCounter();
					}
				}, {
					key: 'updatePeerCounter',
					value: function updatePeerCounter(message) {
						var _this5 = this;

						this.peerCounterElements.forEach(function (element) {
							return element.textContent = message ? message : '[' + _this5.connection.peers.getLength() + ' connected]';
						});
					}
				}]);

				return MasterConnectionEvent;
			})();

			_export('MasterConnectionEvent', MasterConnectionEvent);
		}
	};
});
$__System.register('15', ['5', '6', '7', '14'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterConnectionEvent, ConnectionEvent;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterConnectionEvent = _4.MasterConnectionEvent;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			ConnectionEvent = (function (_MasterConnectionEvent) {
				_inherits(ConnectionEvent, _MasterConnectionEvent);

				function ConnectionEvent(connection, Sender, SentMessage) {
					_classCallCheck(this, ConnectionEvent);

					_get(Object.getPrototypeOf(ConnectionEvent.prototype), 'constructor', this).call(this, connection, Sender, SentMessage);
				}

				return ConnectionEvent;
			})(MasterConnectionEvent);

			_export('ConnectionEvent', ConnectionEvent);
		}
	};
});
$__System.register('16', ['7', '10', '12', 'a'], function (_export) {
	var _classCallCheck, _Map, Helper, _createClass, MasterRequestor;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_3) {
			Helper = _3.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterRequestor = (function () {
				function MasterRequestor(Sender, SentMessage) {
					_classCallCheck(this, MasterRequestor);

					this.Sender = Sender;
					this.SentMessage = SentMessage;

					this.Helper = new Helper();
					this.initRequest = '!!!@';
					this.request = { resendMessage: '-> resendMessage!!!' };
					this.requests = {};
				}

				// requests
				// local

				_createClass(MasterRequestor, [{
					key: 'sendRequest',
					value: function sendRequest(request, elID, remoteUserId) {
						var requestID = this.Helper.getRandomString();
						this.requests[requestID] = request;
						this.Sender.sendEvent('' + this.initRequest + remoteUserId + request, elID, remoteUserId, requestID, false, new _Map([['diffed', false]])); // timeout = false, diffed = false
					}

					// remote
				}, {
					key: 'receiveRequest',
					value: function receiveRequest(request, requestID, elID, remoteUserId, localUserId) {
						switch (request) {
							case '' + this.initRequest + localUserId + this.request.resendMessage:
								// resend last WHOLE message
								this.Sender.sendEvent(this.SentMessage.getLatestElIDvsToAll(elID, remoteUserId), elID, remoteUserId, requestID, undefined, new _Map([['diffed', false]])); // diffed = false
								break;
						}
					}

					// local
				}, {
					key: 'fullFilledRequest',
					value: function fullFilledRequest(requestID, oldMessage, dataPack) {
						switch (this.requests[requestID]) {
							case this.request.resendMessage:
								delete this.requests[requestID];
								return dataPack;
						}
						return false;
					}
				}]);

				return MasterRequestor;
			})();

			_export('MasterRequestor', MasterRequestor);
		}
	};
});
$__System.register('17', ['5', '6', '7', '16'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterRequestor, Requestor;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterRequestor = _4.MasterRequestor;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Requestor = (function (_MasterRequestor) {
				_inherits(Requestor, _MasterRequestor);

				function Requestor(Sender, SentMessage) {
					_classCallCheck(this, Requestor);

					_get(Object.getPrototypeOf(Requestor.prototype), 'constructor', this).call(this, Sender, SentMessage);
				}

				return Requestor;
			})(MasterRequestor);

			_export('Requestor', Requestor);
		}
	};
});
$__System.register('e', ['5', '6', '7', '12', '18', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, Helper, MasterWorker, _createClass, Diff_match_patchWorker;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_5) {
			Helper = _5.Helper;
		}, function (_4) {
			MasterWorker = _4.MasterWorker;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Diff_match_patchWorker = (function (_MasterWorker) {
				_inherits(Diff_match_patchWorker, _MasterWorker);

				function Diff_match_patchWorker() {
					_classCallCheck(this, Diff_match_patchWorker);

					_get(Object.getPrototypeOf(Diff_match_patchWorker.prototype), 'constructor', this).call(this, false);

					this.name = 'Diff_match_patchWorker';
					this.Helper = new Helper();
					this.scripts = this.Helper.addBaseURL(['jspm_packages/' + System.map['tanaka-de-silva/google-diff-match-patch-js'] + '/diff_match_patch.js'], false);
				}

				_createClass(Diff_match_patchWorker, [{
					key: 'sendDiff',
					value: function sendDiff(data) {
						// diff
						//https://code.google.com/p/google-diff-match-patch/
						// https://neil.fraser.name/software/diff_match_patch/svn/trunk/demos/demo_patch.html
						this.Diff_match_patch = new diff_match_patch();
						// data = [oldMessage, [rawMessage, message], elID, remoteUserId, requestID, options, result]
						var diff = this.Diff_match_patch.diff_main(data[0], data[1][1], true); // needs diff to react sensitive
						var patch = this.Diff_match_patch.patch_make(data[0], data[1][1], diff);
						data[1][1] = this.Diff_match_patch.patch_toText(patch);
						if (data[6].constructor !== Array) {
							data[6] = [];
						}
						data[6].push('sendDiff:true');
						// remove oldMessage
						data.splice(0, 1);
						return data;
					}
				}, {
					key: 'receiveDiff',
					value: function receiveDiff(data) {
						//https://code.google.com/p/google-diff-match-patch/
						// https://neil.fraser.name/software/diff_match_patch/svn/trunk/demos/demo_patch.html
						this.Diff_match_patch = new diff_match_patch();
						// data = [[oldMessage, message], elID, remoteUserId, requestID, options, result]
						var patch = this.Diff_match_patch.patch_fromText(data[0][1]);
						var results = this.Diff_match_patch.patch_apply(patch, data[0][0]);
						if (data[5].constructor !== Array) {
							data[5] = [];
						}
						if (results[1].indexOf(false) !== -1) {
							data[5].push('receiveDiff:failed');
						} else {
							data[0][1] = results[0];
							data[5].push('receiveDiff:true');
						}
						return data;
					}
				}]);

				return Diff_match_patchWorker;
			})(MasterWorker);

			_export('Diff_match_patchWorker', Diff_match_patchWorker);
		}
	};
});
$__System.register('12', ['5', '6', '7', '19', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterHelper, _createClass, Helper;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterHelper = _4.MasterHelper;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Helper = (function (_MasterHelper) {
				_inherits(Helper, _MasterHelper);

				function Helper() {
					_classCallCheck(this, Helper);

					_get(Object.getPrototypeOf(Helper.prototype), 'constructor', this).apply(this, arguments);
				}

				_createClass(Helper, [{
					key: 'getEventHandler',

					/**
      * event handler (api hook)
      * 
      * @param {Function} func 
      * @param {string} [scope = this]
      * @param {string} [args = [message = '', elID = '']]
      * @memberof Helper
      */
					value: function getEventHandler() {
						return {
							container: [],
							add: function add(func) {
								var scope = arguments.length <= 1 || arguments[1] === undefined ? this : arguments[1];
								var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

								this.container.push({ func: func, scope: scope, args: args });
							},
							remove: function remove(func) {
								var scope = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

								this.container = this.container.filter(function (value, index, array) {
									if (func === value.func && (scope === false || scope === value.scope)) {
										return false;
									}
									return true;
								});
							}
						};
					}
				}, {
					key: 'arrayKeyValStrToObj',
					value: function arrayKeyValStrToObj() {
						var arr = arguments.length <= 0 || arguments[0] === undefined ? ['key:val', 'key:val'] : arguments[0];
						var needle = arguments.length <= 1 || arguments[1] === undefined ? ':' : arguments[1];

						var obj = {};
						arr.forEach(function (e) {
							e = e.split(needle);
							var val = e[1].trim();
							obj[e[0].trim()] = val === 'true' || val === 'false' ? val === 'true' : val;
						});
						return obj;
					}
				}]);

				return Helper;
			})(MasterHelper);

			_export('Helper', Helper);
		}
	};
});
$__System.register('f', ['5', '6', '7', '12', '18', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, Helper, MasterWorker, _createClass, LZStringWorker;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_5) {
			Helper = _5.Helper;
		}, function (_4) {
			MasterWorker = _4.MasterWorker;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			LZStringWorker = (function (_MasterWorker) {
				_inherits(LZStringWorker, _MasterWorker);

				function LZStringWorker() {
					_classCallCheck(this, LZStringWorker);

					_get(Object.getPrototypeOf(LZStringWorker.prototype), 'constructor', this).call(this, false);

					this.name = 'LZStringWorker';
					this.Helper = new Helper();
					this.scripts = this.Helper.addBaseURL(['jspm_packages/' + System.map['pieroxy/lz-string'] + '/libs/lz-string.min.js'], false);
				}

				_createClass(LZStringWorker, [{
					key: 'sendCompress',
					value: function sendCompress(data) {
						// compress
						// data = [compressed, [rawMessage, message], elID, remoteUserId, requestID, options, result]
						var command = data[0] === 'compress' ? 'compress' : 'compressTo' + data[0];
						data[1][1] = LZString[command](data[1][1]);
						if (data[6].constructor !== Array) {
							data[6] = [];
						}
						data[6].push('sendCompress:true');
						// remove compressed
						data.splice(0, 1);
						return data;
					}
				}, {
					key: 'receiveDecompress',
					value: function receiveDecompress(data) {
						// compress
						// data = [compressed, [oldMessage, message], elID, remoteUserId, requestID, options, result]
						var command = data[0] === 'compress' ? 'decompress' : 'decompressFrom' + data[0];
						data[1][1] = LZString[command](data[1][1]);
						if (data[6].constructor !== Array) {
							data[6] = [];
						}
						data[6].push('receiveDecompress:true');
						// remove compressed
						data.splice(0, 1);
						return data;
					}
				}]);

				return LZStringWorker;
			})(MasterWorker);

			_export('LZStringWorker', LZStringWorker);
		}
	};
});
$__System.register('1a', ['5', '6', '7', 'a', 'd', 'e', 'f'], function (_export) {
	var _get, _inherits, _classCallCheck, _createClass, MasterOption, Diff_match_patchWorker, LZStringWorker, OptionReceiver;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {
			MasterOption = _d.MasterOption;
		}, function (_e) {
			Diff_match_patchWorker = _e.Diff_match_patchWorker;
		}, function (_f) {
			LZStringWorker = _f.LZStringWorker;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			OptionReceiver = (function (_MasterOption) {
				_inherits(OptionReceiver, _MasterOption);

				function OptionReceiver(returnMap) {
					var _this = this;

					_classCallCheck(this, OptionReceiver);

					_get(Object.getPrototypeOf(OptionReceiver.prototype), 'constructor', this).call(this, returnMap);

					// workers
					this.LZStringWorker = new LZStringWorker();
					this.LZStringWorker.create(this.LZStringWorker.receiveDecompress, function (result) {
						_this.returnApply('receiveDecompress', result);
					});
					this.Diff_match_patchWorker = new Diff_match_patchWorker();
					this.Diff_match_patchWorker.create(this.Diff_match_patchWorker.receiveDiff, function (result) {
						_this.returnApply('receiveDiff', result);
					});
				}

				_createClass(OptionReceiver, [{
					key: 'receiveDecompress',
					value: function receiveDecompress(message, elID, remoteUserId, requestID, options) {
						var result = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

						// options[0] must be compress option set in MasterReceiver
						if (options[0] !== 'false') {
							if (options[0] === 'Uint8Array') {
								message[1] = message[1].split(',').map(Number);
							}
							this.LZStringWorker.run([options[0], message, elID, remoteUserId, requestID, options, result]);
							return true;
						}
						// whole message
						result.push('receiveDecompress:false');
						this.returnApply('receiveDecompress', [message, elID, remoteUserId, requestID, options, result]);
						return false;
					}
				}, {
					key: 'receiveDiff',
					value: function receiveDiff(message, elID, remoteUserId, requestID, options) {
						var result = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

						if (message[1].slice(0, 2) === '@@') {
							this.Diff_match_patchWorker.run([message, elID, remoteUserId, requestID, options, result]);
							return true;
						}
						// whole message
						result.push('receiveDiff:false');
						this.returnApply('receiveDiff', [message, elID, remoteUserId, requestID, options, result]);
						return false;
					}
				}]);

				return OptionReceiver;
			})(MasterOption);

			_export('OptionReceiver', OptionReceiver);
		}
	};
});
$__System.register('1b', ['7', '10', '12', 'a', '1c', '1a'], function (_export) {
	var _classCallCheck, _Map, Helper, _createClass, _toConsumableArray, OptionReceiver, MasterReceiver;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_3) {
			Helper = _3.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			_toConsumableArray = _c['default'];
		}, function (_a2) {
			OptionReceiver = _a2.OptionReceiver;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterReceiver = (function () {
				function MasterReceiver(connection, Requestor, ReceivedMessage) {
					_classCallCheck(this, MasterReceiver);

					this.connection = connection;
					this.Requestor = Requestor;
					this.ReceivedMessage = ReceivedMessage;

					this.connection.receive = this.receiveEvent.bind(this); // bindings (2113:RTCMultiConnection => sst: hijack onDataChannelMessage)
					this.Helper = new Helper();
					this.onReceive = this.Helper.getEventHandler(); // event handler (api hook)
					this.OptionReceiver = new OptionReceiver();
					this.OptionReceiver.returnMap.set('init', [this.OptionReceiver.receiveDecompress, this.OptionReceiver]);
					this.OptionReceiver.returnMap.set('receiveDecompress', [this.OptionReceiver.receiveDiff, this.OptionReceiver]);
					this.OptionReceiver.returnMap.set('receiveDiff', [this.receive, this]);
					this.chunks = {};
					this.loading = '<p>loading...</p>';
				}

				_createClass(MasterReceiver, [{
					key: 'receiveEvent',
					value: function receiveEvent(message, remoteUserId) {
						//console.log(`receive: ${message}`);
						var receivingTime = new Date().getTime();
						var dataPack = {};
						var info = message.match(/\(sst:(.*?)\)/, '')[1].split(',');
						dataPack.uuid = info[0];
						dataPack.elID = info[1];
						dataPack.requestID = info[2];
						dataPack.compressed = info[3];
						dataPack.chunk = Number(info[4]);
						dataPack.chunkTotal = Number(info[5]);
						dataPack.latency = receivingTime - info[6];
						dataPack.message = message.replace(/\(sst:.*?\)/g, '');
						dataPack.remoteUserId = remoteUserId;
						if (!this.chunks[dataPack.uuid]) {
							this.chunks[dataPack.uuid] = { message: new _Map([[dataPack.chunk, dataPack.message]]), latency: dataPack.latency };
						} else {
							this.chunks[dataPack.uuid].message.set(dataPack.chunk, dataPack.message);
							this.chunks[dataPack.uuid].latency += dataPack.latency;
						}
						if (this.chunks[dataPack.uuid].message.size === dataPack.chunkTotal) {
							//console.log(this.chunks[dataPack.uuid].latency);
							// mapToArray => sort array => map values and join
							dataPack.message = [].concat(_toConsumableArray(this.chunks[dataPack.uuid].message)).sort(function (a, b) {
								return a[0] - b[0];
							}).map(function (e) {
								return e[1];
							}).join('');
							// [oldMessage, message], elID, remoteUserId, requestID, options [0:compressed]
							this.OptionReceiver.init([this.ReceivedMessage.get(dataPack.elID, dataPack.remoteUserId), dataPack.message], dataPack.elID, dataPack.remoteUserId, dataPack.requestID, [dataPack.compressed]);
							delete this.chunks[dataPack.uuid];
						}
					}

					// message = [oldMessage, message]
				}, {
					key: 'receive',
					value: function receive(message, elID, remoteUserId, requestID, options, result) {
						if (message[1].length > 0) {
							var dataPack = { message: message[1], elID: elID, remoteUserId: remoteUserId, requestID: requestID, result: result };
							var success = false;
							// diff did't pass
							if (this.Helper.arrayKeyValStrToObj(result)['receiveDiff'] === 'failed') {
								this.Requestor.sendRequest(this.Requestor.request.resendMessage, elID, remoteUserId);
								dataPack.message = this.loading;
								this._receive(dataPack);
							} else if (requestID.length > 0 && message[1].indexOf('' + this.Requestor.initRequest + this.connection.userid) !== -1) {
								// handle request
								this.Requestor.receiveRequest(message[1], requestID, elID, remoteUserId, this.connection.userid);
								// ==> don't _receive anything => text doesn't get updated but request gets fullFilled
							} else if (this.Requestor.requests[requestID]) {
									// fullFilled request received
									this._receive(this.Requestor.fullFilledRequest(requestID, message[0], dataPack));
									success = true;
								} else {
									// whole message
									this._receive(dataPack);
									success = true;
								}
							if (success) {
								this.ReceivedMessage.set(message[1], elID, remoteUserId);
							}
						}
					}
				}, {
					key: '_receive',
					value: function _receive() {
						var dataPack = arguments.length <= 0 || arguments[0] === undefined ? { message: undefined } : arguments[0];

						// give it further to the event listener
						this.onReceive.container.forEach(function (e) {
							e.func.apply(e.scope, [dataPack].concat(e.args));
						});
					}
				}, {
					key: 'setIgnoreOption',
					value: function setIgnoreOption() {
						// skip with binding this.receive
						this.oldInit = this.OptionReceiver.init;
						this.OptionReceiver.init = this.receive.bind(this);
					}
				}, {
					key: 'unsetIgnoreOption',
					value: function unsetIgnoreOption() {
						// skip with binding this.receive
						this.OptionReceiver.init = this.oldInit ? this.oldInit : this.OptionReceiver.init;
					}
				}]);

				return MasterReceiver;
			})();

			_export('MasterReceiver', MasterReceiver);
		}
	};
});
$__System.register('1d', ['5', '6', '7', '1b'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterReceiver, Receiver;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_b) {
			MasterReceiver = _b.MasterReceiver;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Receiver = (function (_MasterReceiver) {
				_inherits(Receiver, _MasterReceiver);

				function Receiver(connection, Requestor, ReceivedMessage) {
					_classCallCheck(this, Receiver);

					_get(Object.getPrototypeOf(Receiver.prototype), 'constructor', this).call(this, connection, Requestor, ReceivedMessage);
				}

				return Receiver;
			})(MasterReceiver);

			_export('Receiver', Receiver);
		}
	};
});
$__System.registerDynamic('1e', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        'use strict';

        // Last time updated: 2020-08-26 8:55:13 AM UTC

        // _________________________
        // RTCMultiConnection v3.7.0

        // Open-Sourced: https://github.com/muaz-khan/RTCMultiConnection

        // --------------------------------------------------
        // Muaz Khan     - www.MuazKhan.com
        // MIT License   - www.WebRTC-Experiment.com/licence
        // --------------------------------------------------

        // sst: expose to global

        window.RTCMultiConnection = function (roomid, forceOptions) {

            var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';

            (function (that) {
                if (!that) {
                    return;
                }

                if (typeof window !== 'undefined') {
                    return;
                }

                if (typeof global === 'undefined') {
                    return;
                }

                global.navigator = {
                    userAgent: browserFakeUserAgent,
                    getUserMedia: function () {}
                };

                if (!global.console) {
                    global.console = {};
                }

                if (typeof global.console.debug === 'undefined') {
                    global.console.debug = global.console.info = global.console.error = global.console.log = global.console.log || function () {
                        console.log(arguments);
                    };
                }

                if (typeof document === 'undefined') {
                    /*global document:true */
                    that.document = {};

                    document.createElement = document.captureStream = document.mozCaptureStream = function () {
                        var obj = {
                            getContext: function () {
                                return obj;
                            },
                            play: function () {},
                            pause: function () {},
                            drawImage: function () {},
                            toDataURL: function () {
                                return '';
                            }
                        };
                        return obj;
                    };

                    document.addEventListener = document.removeEventListener = that.addEventListener = that.removeEventListener = function () {};

                    that.HTMLVideoElement = that.HTMLMediaElement = function () {};
                }

                if (typeof io === 'undefined') {
                    that.io = function () {
                        return {
                            on: function (eventName, callback) {
                                callback = callback || function () {};

                                if (eventName === 'connect') {
                                    callback();
                                }
                            },
                            emit: function (eventName, data, callback) {
                                callback = callback || function () {};
                                if (eventName === 'open-room' || eventName === 'join-room') {
                                    callback(true, data.sessionid, null);
                                }
                            }
                        };
                    };
                }

                if (typeof location === 'undefined') {
                    /*global location:true */
                    that.location = {
                        protocol: 'file:',
                        href: '',
                        hash: '',
                        origin: 'self'
                    };
                }

                if (typeof screen === 'undefined') {
                    /*global screen:true */
                    that.screen = {
                        width: 0,
                        height: 0
                    };
                }

                if (typeof URL === 'undefined') {
                    /*global screen:true */
                    that.URL = {
                        createObjectURL: function () {
                            return '';
                        },
                        revokeObjectURL: function () {
                            return '';
                        }
                    };
                }

                /*global window:true */
                that.window = global;
            })(typeof global !== 'undefined' ? global : null);

            function SocketConnection(connection, connectCallback) {
                function isData(session) {
                    return !session.audio && !session.video && !session.screen && session.data;
                }

                var parameters = '';

                parameters += '?userid=' + connection.userid;
                parameters += '&sessionid=' + connection.sessionid;
                parameters += '&msgEvent=' + connection.socketMessageEvent;
                parameters += '&socketCustomEvent=' + connection.socketCustomEvent;
                parameters += '&autoCloseEntireSession=' + !!connection.autoCloseEntireSession;

                if (connection.session.broadcast === true) {
                    parameters += '&oneToMany=true';
                }

                parameters += '&maxParticipantsAllowed=' + connection.maxParticipantsAllowed;

                if (connection.enableScalableBroadcast) {
                    parameters += '&enableScalableBroadcast=true';
                    parameters += '&maxRelayLimitPerUser=' + (connection.maxRelayLimitPerUser || 2);
                }

                parameters += '&extra=' + JSON.stringify(connection.extra || {});

                if (connection.socketCustomParameters) {
                    parameters += connection.socketCustomParameters;
                }

                try {
                    io.sockets = {};
                } catch (e) {};

                if (!connection.socketURL) {
                    connection.socketURL = '/';
                }

                if (connection.socketURL.substr(connection.socketURL.length - 1, 1) != '/') {
                    // connection.socketURL = 'https://domain.com:9001/';
                    throw '"socketURL" MUST end with a slash.';
                }

                if (connection.enableLogs) {
                    if (connection.socketURL == '/') {
                        console.info('socket.io url is: ', location.origin + '/');
                    } else {
                        console.info('socket.io url is: ', connection.socketURL);
                    }
                }

                try {
                    connection.socket = io(connection.socketURL + parameters);
                } catch (e) {
                    connection.socket = io.connect(connection.socketURL + parameters, connection.socketOptions);
                }

                var mPeer = connection.multiPeersHandler;

                connection.socket.on('extra-data-updated', function (remoteUserId, extra) {
                    if (!connection.peers[remoteUserId]) return;
                    connection.peers[remoteUserId].extra = extra;

                    connection.onExtraDataUpdated({
                        userid: remoteUserId,
                        extra: extra
                    });

                    updateExtraBackup(remoteUserId, extra);
                });

                function updateExtraBackup(remoteUserId, extra) {
                    if (!connection.peersBackup[remoteUserId]) {
                        connection.peersBackup[remoteUserId] = {
                            userid: remoteUserId,
                            extra: {}
                        };
                    }

                    connection.peersBackup[remoteUserId].extra = extra;
                }

                function onMessageEvent(message) {
                    if (message.remoteUserId != connection.userid) return;

                    if (connection.peers[message.sender] && connection.peers[message.sender].extra != message.message.extra) {
                        connection.peers[message.sender].extra = message.extra;
                        connection.onExtraDataUpdated({
                            userid: message.sender,
                            extra: message.extra
                        });

                        updateExtraBackup(message.sender, message.extra);
                    }

                    if (message.message.streamSyncNeeded && connection.peers[message.sender]) {
                        var stream = connection.streamEvents[message.message.streamid];
                        if (!stream || !stream.stream) {
                            return;
                        }

                        var action = message.message.action;

                        if (action === 'ended' || action === 'inactive' || action === 'stream-removed') {
                            if (connection.peersBackup[stream.userid]) {
                                stream.extra = connection.peersBackup[stream.userid].extra;
                            }
                            connection.onstreamended(stream);
                            return;
                        }

                        var type = message.message.type != 'both' ? message.message.type : null;

                        if (typeof stream.stream[action] == 'function') {
                            stream.stream[action](type);
                        }
                        return;
                    }

                    if (message.message === 'dropPeerConnection') {
                        connection.deletePeer(message.sender);
                        return;
                    }

                    if (message.message.allParticipants) {
                        if (message.message.allParticipants.indexOf(message.sender) === -1) {
                            message.message.allParticipants.push(message.sender);
                        }

                        message.message.allParticipants.forEach(function (participant) {
                            mPeer[!connection.peers[participant] ? 'createNewPeer' : 'renegotiatePeer'](participant, {
                                localPeerSdpConstraints: {
                                    OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                    OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                                },
                                remotePeerSdpConstraints: {
                                    OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                    OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                                },
                                isOneWay: !!connection.session.oneway || connection.direction === 'one-way',
                                isDataOnly: isData(connection.session)
                            });
                        });
                        return;
                    }

                    if (message.message.newParticipant) {
                        if (message.message.newParticipant == connection.userid) return;
                        if (!!connection.peers[message.message.newParticipant]) return;

                        mPeer.createNewPeer(message.message.newParticipant, message.message.userPreferences || {
                            localPeerSdpConstraints: {
                                OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            remotePeerSdpConstraints: {
                                OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            isOneWay: !!connection.session.oneway || connection.direction === 'one-way',
                            isDataOnly: isData(connection.session)
                        });
                        return;
                    }

                    if (message.message.readyForOffer) {
                        if (connection.attachStreams.length) {
                            connection.waitingForLocalMedia = false;
                        }

                        if (connection.waitingForLocalMedia) {
                            // if someone is waiting to join you
                            // make sure that we've local media before making a handshake
                            setTimeout(function () {
                                onMessageEvent(message);
                            }, 1);
                            return;
                        }
                    }

                    if (message.message.newParticipationRequest && message.sender !== connection.userid) {
                        if (connection.peers[message.sender]) {
                            connection.deletePeer(message.sender);
                        }

                        var userPreferences = {
                            extra: message.extra || {},
                            localPeerSdpConstraints: message.message.remotePeerSdpConstraints || {
                                OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            remotePeerSdpConstraints: message.message.localPeerSdpConstraints || {
                                OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            isOneWay: typeof message.message.isOneWay !== 'undefined' ? message.message.isOneWay : !!connection.session.oneway || connection.direction === 'one-way',
                            isDataOnly: typeof message.message.isDataOnly !== 'undefined' ? message.message.isDataOnly : isData(connection.session),
                            dontGetRemoteStream: typeof message.message.isOneWay !== 'undefined' ? message.message.isOneWay : !!connection.session.oneway || connection.direction === 'one-way',
                            dontAttachLocalStream: !!message.message.dontGetRemoteStream,
                            connectionDescription: message,
                            successCallback: function () {}
                        };

                        connection.onNewParticipant(message.sender, userPreferences);
                        return;
                    }

                    if (message.message.changedUUID) {
                        if (connection.peers[message.message.oldUUID]) {
                            connection.peers[message.message.newUUID] = connection.peers[message.message.oldUUID];
                            delete connection.peers[message.message.oldUUID];
                        }
                    }

                    if (message.message.userLeft) {
                        mPeer.onUserLeft(message.sender);

                        if (!!message.message.autoCloseEntireSession) {
                            connection.leave();
                        }

                        return;
                    }

                    mPeer.addNegotiatedMessage(message.message, message.sender);
                }

                connection.socket.on(connection.socketMessageEvent, onMessageEvent);

                var alreadyConnected = false;

                connection.socket.resetProps = function () {
                    alreadyConnected = false;
                };

                connection.socket.on('connect', function () {
                    if (alreadyConnected) {
                        return;
                    }
                    alreadyConnected = true;

                    if (connection.enableLogs) {
                        console.info('socket.io connection is opened.');
                    }

                    setTimeout(function () {
                        connection.socket.emit('extra-data-updated', connection.extra);
                    }, 1000);

                    if (connectCallback) {
                        connectCallback(connection.socket);
                    }
                });

                connection.socket.on('disconnect', function (event) {
                    connection.onSocketDisconnect(event);
                });

                connection.socket.on('error', function (event) {
                    connection.onSocketError(event);
                });

                connection.socket.on('user-disconnected', function (remoteUserId) {
                    if (remoteUserId === connection.userid) {
                        return;
                    }

                    connection.onUserStatusChanged({
                        userid: remoteUserId,
                        status: 'offline',
                        extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra || {} : {}
                    });

                    connection.deletePeer(remoteUserId);
                });

                connection.socket.on('user-connected', function (userid) {
                    if (userid === connection.userid) {
                        return;
                    }

                    connection.onUserStatusChanged({
                        userid: userid,
                        status: 'online',
                        extra: connection.peers[userid] ? connection.peers[userid].extra || {} : {}
                    });
                });

                connection.socket.on('closed-entire-session', function (sessionid, extra) {
                    connection.leave();
                    connection.onEntireSessionClosed({
                        sessionid: sessionid,
                        userid: sessionid,
                        extra: extra
                    });
                });

                connection.socket.on('userid-already-taken', function (useridAlreadyTaken, yourNewUserId) {
                    connection.onUserIdAlreadyTaken(useridAlreadyTaken, yourNewUserId);
                });

                connection.socket.on('logs', function (log) {
                    if (!connection.enableLogs) return;
                    console.debug('server-logs', log);
                });

                connection.socket.on('number-of-broadcast-viewers-updated', function (data) {
                    connection.onNumberOfBroadcastViewersUpdated(data);
                });

                connection.socket.on('set-isInitiator-true', function (sessionid) {
                    if (sessionid != connection.sessionid) return;
                    connection.isInitiator = true;
                });
            }

            function MultiPeers(connection) {
                var self = this;

                var skipPeers = ['getAllParticipants', 'getLength', 'selectFirst', 'streams', 'send', 'forEach'];
                connection.peers = {
                    getLength: function () {
                        var numberOfPeers = 0;
                        for (var peer in this) {
                            if (skipPeers.indexOf(peer) == -1) {
                                numberOfPeers++;
                            }
                        }
                        return numberOfPeers;
                    },
                    selectFirst: function () {
                        var firstPeer;
                        for (var peer in this) {
                            if (skipPeers.indexOf(peer) == -1) {
                                firstPeer = this[peer];
                            }
                        }
                        return firstPeer;
                    },
                    getAllParticipants: function (sender) {
                        var allPeers = [];
                        for (var peer in this) {
                            if (skipPeers.indexOf(peer) == -1 && peer != sender) {
                                allPeers.push(peer);
                            }
                        }
                        return allPeers;
                    },
                    forEach: function (callback) {
                        this.getAllParticipants().forEach(function (participant) {
                            callback(connection.peers[participant]);
                        });
                    },
                    send: function (data, remoteUserId) {
                        var that = this;

                        if (!isNull(data.size) && !isNull(data.type)) {
                            if (connection.enableFileSharing) {
                                self.shareFile(data, remoteUserId);
                                return;
                            }

                            if (typeof data !== 'string') {
                                data = JSON.stringify(data);
                            }
                        }

                        if (data.type !== 'text' && !(data instanceof ArrayBuffer) && !(data instanceof DataView)) {
                            TextSender.send({
                                text: data,
                                channel: this,
                                connection: connection,
                                remoteUserId: remoteUserId
                            });
                            return;
                        }

                        if (data.type === 'text') {
                            data = JSON.stringify(data);
                        }

                        if (remoteUserId) {
                            var remoteUser = connection.peers[remoteUserId];
                            if (remoteUser) {
                                if (!remoteUser.channels.length) {
                                    connection.peers[remoteUserId].createDataChannel();
                                    connection.renegotiate(remoteUserId);
                                    setTimeout(function () {
                                        that.send(data, remoteUserId);
                                    }, 3000);
                                    return;
                                }

                                remoteUser.channels.forEach(function (channel) {
                                    channel.send(data);
                                });
                                return;
                            }
                        }

                        this.getAllParticipants().forEach(function (participant) {
                            if (!that[participant].channels.length) {
                                connection.peers[participant].createDataChannel();
                                connection.renegotiate(participant);
                                setTimeout(function () {
                                    that[participant].channels.forEach(function (channel) {
                                        channel.send(data);
                                    });
                                }, 3000);
                                return;
                            }

                            that[participant].channels.forEach(function (channel) {
                                channel.send(data);
                            });
                        });
                    }
                };

                this.uuid = connection.userid;

                this.getLocalConfig = function (remoteSdp, remoteUserId, userPreferences) {
                    if (!userPreferences) {
                        userPreferences = {};
                    }

                    return {
                        streamsToShare: userPreferences.streamsToShare || {},
                        rtcMultiConnection: connection,
                        connectionDescription: userPreferences.connectionDescription,
                        userid: remoteUserId,
                        localPeerSdpConstraints: userPreferences.localPeerSdpConstraints,
                        remotePeerSdpConstraints: userPreferences.remotePeerSdpConstraints,
                        dontGetRemoteStream: !!userPreferences.dontGetRemoteStream,
                        dontAttachLocalStream: !!userPreferences.dontAttachLocalStream,
                        renegotiatingPeer: !!userPreferences.renegotiatingPeer,
                        peerRef: userPreferences.peerRef,
                        channels: userPreferences.channels || [],
                        onLocalSdp: function (localSdp) {
                            self.onNegotiationNeeded(localSdp, remoteUserId);
                        },
                        onLocalCandidate: function (localCandidate) {
                            localCandidate = OnIceCandidateHandler.processCandidates(connection, localCandidate);
                            if (localCandidate) {
                                self.onNegotiationNeeded(localCandidate, remoteUserId);
                            }
                        },
                        remoteSdp: remoteSdp,
                        onDataChannelMessage: function (message) {
                            /*
                            if (!connection.fbr && connection.enableFileSharing) initFileBufferReader();
                              if (typeof message == 'string' || !connection.enableFileSharing) {
                                self.onDataChannelMessage(message, remoteUserId);
                                return;
                            }
                              var that = this;
                              if (message instanceof ArrayBuffer || message instanceof DataView) {
                                connection.fbr.convertToObject(message, function(object) {
                                    that.onDataChannelMessage(object);
                                });
                                return;
                            }
                              if (message.readyForNextChunk) {
                                connection.fbr.getNextChunk(message, function(nextChunk, isLastChunk) {
                                    connection.peers[remoteUserId].channels.forEach(function(channel) {
                                        channel.send(nextChunk);
                                    });
                                }, remoteUserId);
                                return;
                            }
                              if (message.chunkMissing) {
                                connection.fbr.chunkMissing(message);
                                return;
                            }
                              connection.fbr.addChunk(message, function(promptNextChunk) {
                                connection.peers[remoteUserId].peer.channel.send(promptNextChunk);
                            });
                            */
                            // sst: hijack onDataChannelMessage
                            connection.receive(message, remoteUserId);
                        },
                        onDataChannelError: function (error) {
                            self.onDataChannelError(error, remoteUserId);
                        },
                        onDataChannelOpened: function (channel) {
                            self.onDataChannelOpened(channel, remoteUserId);
                        },
                        onDataChannelClosed: function (event) {
                            self.onDataChannelClosed(event, remoteUserId);
                        },
                        onRemoteStream: function (stream) {
                            if (connection.peers[remoteUserId]) {
                                connection.peers[remoteUserId].streams.push(stream);
                            }

                            self.onGettingRemoteMedia(stream, remoteUserId);
                        },
                        onRemoteStreamRemoved: function (stream) {
                            self.onRemovingRemoteMedia(stream, remoteUserId);
                        },
                        onPeerStateChanged: function (states) {
                            self.onPeerStateChanged(states);

                            if (states.iceConnectionState === 'new') {
                                self.onNegotiationStarted(remoteUserId, states);
                            }

                            if (states.iceConnectionState === 'connected') {
                                self.onNegotiationCompleted(remoteUserId, states);
                            }

                            if (states.iceConnectionState.search(/closed|failed/gi) !== -1) {
                                self.onUserLeft(remoteUserId);
                                self.disconnectWith(remoteUserId);
                            }
                        }
                    };
                };

                this.createNewPeer = function (remoteUserId, userPreferences) {
                    if (connection.maxParticipantsAllowed <= connection.getAllParticipants().length) {
                        return;
                    }

                    userPreferences = userPreferences || {};

                    if (connection.isInitiator && !!connection.session.audio && connection.session.audio === 'two-way' && !userPreferences.streamsToShare) {
                        userPreferences.isOneWay = false;
                        userPreferences.isDataOnly = false;
                        userPreferences.session = connection.session;
                    }

                    if (!userPreferences.isOneWay && !userPreferences.isDataOnly) {
                        userPreferences.isOneWay = true;
                        this.onNegotiationNeeded({
                            enableMedia: true,
                            userPreferences: userPreferences
                        }, remoteUserId);
                        return;
                    }

                    userPreferences = connection.setUserPreferences(userPreferences, remoteUserId);
                    var localConfig = this.getLocalConfig(null, remoteUserId, userPreferences);
                    connection.peers[remoteUserId] = new PeerInitiator(localConfig);
                };

                this.createAnsweringPeer = function (remoteSdp, remoteUserId, userPreferences) {
                    userPreferences = connection.setUserPreferences(userPreferences || {}, remoteUserId);

                    var localConfig = this.getLocalConfig(remoteSdp, remoteUserId, userPreferences);
                    connection.peers[remoteUserId] = new PeerInitiator(localConfig);
                };

                this.renegotiatePeer = function (remoteUserId, userPreferences, remoteSdp) {
                    if (!connection.peers[remoteUserId]) {
                        if (connection.enableLogs) {
                            console.error('Peer (' + remoteUserId + ') does not exist. Renegotiation skipped.');
                        }
                        return;
                    }

                    if (!userPreferences) {
                        userPreferences = {};
                    }

                    userPreferences.renegotiatingPeer = true;
                    userPreferences.peerRef = connection.peers[remoteUserId].peer;
                    userPreferences.channels = connection.peers[remoteUserId].channels;

                    var localConfig = this.getLocalConfig(remoteSdp, remoteUserId, userPreferences);

                    connection.peers[remoteUserId] = new PeerInitiator(localConfig);
                };

                this.replaceTrack = function (track, remoteUserId, isVideoTrack) {
                    if (!connection.peers[remoteUserId]) {
                        throw 'This peer (' + remoteUserId + ') does not exist.';
                    }

                    var peer = connection.peers[remoteUserId].peer;

                    if (!!peer.getSenders && typeof peer.getSenders === 'function' && peer.getSenders().length) {
                        peer.getSenders().forEach(function (rtpSender) {
                            if (isVideoTrack && rtpSender.track.kind === 'video') {
                                connection.peers[remoteUserId].peer.lastVideoTrack = rtpSender.track;
                                rtpSender.replaceTrack(track);
                            }

                            if (!isVideoTrack && rtpSender.track.kind === 'audio') {
                                connection.peers[remoteUserId].peer.lastAudioTrack = rtpSender.track;
                                rtpSender.replaceTrack(track);
                            }
                        });
                        return;
                    }

                    console.warn('RTPSender.replaceTrack is NOT supported.');
                    this.renegotiatePeer(remoteUserId);
                };

                this.onNegotiationNeeded = function (message, remoteUserId) {};
                this.addNegotiatedMessage = function (message, remoteUserId) {
                    if (message.type && message.sdp) {
                        if (message.type == 'answer') {
                            if (connection.peers[remoteUserId]) {
                                connection.peers[remoteUserId].addRemoteSdp(message);
                            }
                        }

                        if (message.type == 'offer') {
                            if (message.renegotiatingPeer) {
                                this.renegotiatePeer(remoteUserId, null, message);
                            } else {
                                this.createAnsweringPeer(message, remoteUserId);
                            }
                        }

                        if (connection.enableLogs) {
                            console.log('Remote peer\'s sdp:', message.sdp);
                        }
                        return;
                    }

                    if (message.candidate) {
                        if (connection.peers[remoteUserId]) {
                            connection.peers[remoteUserId].addRemoteCandidate(message);
                        }

                        if (connection.enableLogs) {
                            console.log('Remote peer\'s candidate pairs:', message.candidate);
                        }
                        return;
                    }

                    if (message.enableMedia) {
                        connection.session = message.userPreferences.session || connection.session;

                        if (connection.session.oneway && connection.attachStreams.length) {
                            connection.attachStreams = [];
                        }

                        if (message.userPreferences.isDataOnly && connection.attachStreams.length) {
                            connection.attachStreams.length = [];
                        }

                        var streamsToShare = {};
                        connection.attachStreams.forEach(function (stream) {
                            streamsToShare[stream.streamid] = {
                                isAudio: !!stream.isAudio,
                                isVideo: !!stream.isVideo,
                                isScreen: !!stream.isScreen
                            };
                        });
                        message.userPreferences.streamsToShare = streamsToShare;

                        self.onNegotiationNeeded({
                            readyForOffer: true,
                            userPreferences: message.userPreferences
                        }, remoteUserId);
                    }

                    if (message.readyForOffer) {
                        connection.onReadyForOffer(remoteUserId, message.userPreferences);
                    }

                    function cb(stream) {
                        gumCallback(stream, message, remoteUserId);
                    }
                };

                function gumCallback(stream, message, remoteUserId) {
                    var streamsToShare = {};
                    connection.attachStreams.forEach(function (stream) {
                        streamsToShare[stream.streamid] = {
                            isAudio: !!stream.isAudio,
                            isVideo: !!stream.isVideo,
                            isScreen: !!stream.isScreen
                        };
                    });
                    message.userPreferences.streamsToShare = streamsToShare;

                    self.onNegotiationNeeded({
                        readyForOffer: true,
                        userPreferences: message.userPreferences
                    }, remoteUserId);
                }

                this.onGettingRemoteMedia = function (stream, remoteUserId) {};
                this.onRemovingRemoteMedia = function (stream, remoteUserId) {};
                this.onGettingLocalMedia = function (localStream) {};
                this.onLocalMediaError = function (error, constraints) {
                    connection.onMediaError(error, constraints);
                };

                function initFileBufferReader() {
                    connection.fbr = new FileBufferReader();
                    connection.fbr.onProgress = function (chunk) {
                        connection.onFileProgress(chunk);
                    };
                    connection.fbr.onBegin = function (file) {
                        connection.onFileStart(file);
                    };
                    connection.fbr.onEnd = function (file) {
                        connection.onFileEnd(file);
                    };
                }

                this.shareFile = function (file, remoteUserId) {
                    initFileBufferReader();

                    connection.fbr.readAsArrayBuffer(file, function (uuid) {
                        var arrayOfUsers = connection.getAllParticipants();

                        if (remoteUserId) {
                            arrayOfUsers = [remoteUserId];
                        }

                        arrayOfUsers.forEach(function (participant) {
                            connection.fbr.getNextChunk(uuid, function (nextChunk) {
                                connection.peers[participant].channels.forEach(function (channel) {
                                    channel.send(nextChunk);
                                });
                            }, participant);
                        });
                    }, {
                        userid: connection.userid,
                        // extra: connection.extra,
                        chunkSize: DetectRTC.browser.name === 'Firefox' ? 15 * 1000 : connection.chunkSize || 0
                    });
                };

                if (typeof 'TextReceiver' !== 'undefined') {
                    var textReceiver = new TextReceiver(connection);
                }

                this.onDataChannelMessage = function (message, remoteUserId) {
                    textReceiver.receive(JSON.parse(message), remoteUserId, connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {});
                };

                this.onDataChannelClosed = function (event, remoteUserId) {
                    event.userid = remoteUserId;
                    event.extra = connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {};
                    connection.onclose(event);
                };

                this.onDataChannelError = function (error, remoteUserId) {
                    error.userid = remoteUserId;
                    event.extra = connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {};
                    connection.onerror(error);
                };

                this.onDataChannelOpened = function (channel, remoteUserId) {
                    // sst: Uncaught TypeError: connection.peers[remoteUserId] is undefined
                    if (!connection.peers[remoteUserId]) connection.peers[remoteUserId] = { channels: [] };
                    // keep last channel only; we are not expecting parallel/channels channels
                    if (connection.peers[remoteUserId].channels.length) {
                        connection.peers[remoteUserId].channels = [channel];
                        return;
                    }

                    connection.peers[remoteUserId].channels.push(channel);
                    connection.onopen({
                        userid: remoteUserId,
                        extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                        channel: channel
                    });
                };

                this.onPeerStateChanged = function (state) {
                    connection.onPeerStateChanged(state);
                };

                this.onNegotiationStarted = function (remoteUserId, states) {};
                this.onNegotiationCompleted = function (remoteUserId, states) {};

                this.getRemoteStreams = function (remoteUserId) {
                    remoteUserId = remoteUserId || connection.peers.getAllParticipants()[0];
                    return connection.peers[remoteUserId] ? connection.peers[remoteUserId].streams : [];
                };
            }

            'use strict';

            // Last Updated On: 2019-01-10 5:32:55 AM UTC

            // ________________
            // DetectRTC v1.3.9

            // Open-Sourced: https://github.com/muaz-khan/DetectRTC

            // --------------------------------------------------
            // Muaz Khan     - www.MuazKhan.com
            // MIT License   - www.WebRTC-Experiment.com/licence
            // --------------------------------------------------

            (function () {

                var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';

                var isNodejs = typeof process === 'object' && typeof process.versions === 'object' && process.versions.node && /*node-process*/!process.browser;
                if (isNodejs) {
                    var version = process.versions.node.toString().replace('v', '');
                    browserFakeUserAgent = 'Nodejs/' + version + ' (NodeOS) AppleWebKit/' + version + ' (KHTML, like Gecko) Nodejs/' + version + ' Nodejs/' + version;
                }

                (function (that) {
                    if (typeof window !== 'undefined') {
                        return;
                    }

                    if (typeof window === 'undefined' && typeof global !== 'undefined') {
                        global.navigator = {
                            userAgent: browserFakeUserAgent,
                            getUserMedia: function () {}
                        };

                        /*global window:true */
                        that.window = global;
                    } else if (typeof window === 'undefined') {
                        // window = this;
                    }

                    if (typeof location === 'undefined') {
                        /*global location:true */
                        that.location = {
                            protocol: 'file:',
                            href: '',
                            hash: ''
                        };
                    }

                    if (typeof screen === 'undefined') {
                        /*global screen:true */
                        that.screen = {
                            width: 0,
                            height: 0
                        };
                    }
                })(typeof global !== 'undefined' ? global : window);

                /*global navigator:true */
                var navigator = window.navigator;

                if (typeof navigator !== 'undefined') {
                    if (typeof navigator.webkitGetUserMedia !== 'undefined') {
                        navigator.getUserMedia = navigator.webkitGetUserMedia;
                    }

                    if (typeof navigator.mozGetUserMedia !== 'undefined') {
                        navigator.getUserMedia = navigator.mozGetUserMedia;
                    }
                } else {
                    navigator = {
                        getUserMedia: function () {},
                        userAgent: browserFakeUserAgent
                    };
                }

                var isMobileDevice = !!/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || '');

                var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);

                var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
                var isFirefox = typeof window.InstallTrigger !== 'undefined';
                var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                var isChrome = !!window.chrome && !isOpera;
                var isIE = typeof document !== 'undefined' && !!document.documentMode && !isEdge;

                // this one can also be used:
                // https://www.websocket.org/js/stuff.js (DetectBrowser.js)

                function getBrowserInfo() {
                    var nVer = navigator.appVersion;
                    var nAgt = navigator.userAgent;
                    var browserName = navigator.appName;
                    var fullVersion = '' + parseFloat(navigator.appVersion);
                    var majorVersion = parseInt(navigator.appVersion, 10);
                    var nameOffset, verOffset, ix;

                    // both and safri and chrome has same userAgent
                    if (isSafari && !isChrome && nAgt.indexOf('CriOS') !== -1) {
                        isSafari = false;
                        isChrome = true;
                    }

                    // In Opera, the true version is after 'Opera' or after 'Version'
                    if (isOpera) {
                        browserName = 'Opera';
                        try {
                            fullVersion = navigator.userAgent.split('OPR/')[1].split(' ')[0];
                            majorVersion = fullVersion.split('.')[0];
                        } catch (e) {
                            fullVersion = '0.0.0.0';
                            majorVersion = 0;
                        }
                    }
                    // In MSIE version <=10, the true version is after 'MSIE' in userAgent
                    // In IE 11, look for the string after 'rv:'
                    else if (isIE) {
                            verOffset = nAgt.indexOf('rv:');
                            if (verOffset > 0) {
                                //IE 11
                                fullVersion = nAgt.substring(verOffset + 3);
                            } else {
                                //IE 10 or earlier
                                verOffset = nAgt.indexOf('MSIE');
                                fullVersion = nAgt.substring(verOffset + 5);
                            }
                            browserName = 'IE';
                        }
                        // In Chrome, the true version is after 'Chrome' 
                        else if (isChrome) {
                                verOffset = nAgt.indexOf('Chrome');
                                browserName = 'Chrome';
                                fullVersion = nAgt.substring(verOffset + 7);
                            }
                            // In Safari, the true version is after 'Safari' or after 'Version' 
                            else if (isSafari) {
                                    verOffset = nAgt.indexOf('Safari');

                                    browserName = 'Safari';
                                    fullVersion = nAgt.substring(verOffset + 7);

                                    if ((verOffset = nAgt.indexOf('Version')) !== -1) {
                                        fullVersion = nAgt.substring(verOffset + 8);
                                    }

                                    if (navigator.userAgent.indexOf('Version/') !== -1) {
                                        fullVersion = navigator.userAgent.split('Version/')[1].split(' ')[0];
                                    }
                                }
                                // In Firefox, the true version is after 'Firefox' 
                                else if (isFirefox) {
                                        verOffset = nAgt.indexOf('Firefox');
                                        browserName = 'Firefox';
                                        fullVersion = nAgt.substring(verOffset + 8);
                                    }

                                    // In most other browsers, 'name/version' is at the end of userAgent 
                                    else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
                                            browserName = nAgt.substring(nameOffset, verOffset);
                                            fullVersion = nAgt.substring(verOffset + 1);

                                            if (browserName.toLowerCase() === browserName.toUpperCase()) {
                                                browserName = navigator.appName;
                                            }
                                        }

                    if (isEdge) {
                        browserName = 'Edge';
                        fullVersion = navigator.userAgent.split('Edge/')[1];
                        // fullVersion = parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10).toString();
                    }

                    // trim the fullVersion string at semicolon/space/bracket if present
                    if ((ix = fullVersion.search(/[; \)]/)) !== -1) {
                        fullVersion = fullVersion.substring(0, ix);
                    }

                    majorVersion = parseInt('' + fullVersion, 10);

                    if (isNaN(majorVersion)) {
                        fullVersion = '' + parseFloat(navigator.appVersion);
                        majorVersion = parseInt(navigator.appVersion, 10);
                    }

                    return {
                        fullVersion: fullVersion,
                        version: majorVersion,
                        name: browserName,
                        isPrivateBrowsing: false
                    };
                }

                // via: https://gist.github.com/cou929/7973956

                function retry(isDone, next) {
                    var currentTrial = 0,
                        maxRetry = 50,
                        interval = 10,
                        isTimeout = false;
                    var id = window.setInterval(function () {
                        if (isDone()) {
                            window.clearInterval(id);
                            next(isTimeout);
                        }
                        if (currentTrial++ > maxRetry) {
                            window.clearInterval(id);
                            isTimeout = true;
                            next(isTimeout);
                        }
                    }, 10);
                }

                function isIE10OrLater(userAgent) {
                    var ua = userAgent.toLowerCase();
                    if (ua.indexOf('msie') === 0 && ua.indexOf('trident') === 0) {
                        return false;
                    }
                    var match = /(?:msie|rv:)\s?([\d\.]+)/.exec(ua);
                    if (match && parseInt(match[1], 10) >= 10) {
                        return true;
                    }
                    return false;
                }

                function detectPrivateMode(callback) {
                    var isPrivate;

                    try {

                        if (window.webkitRequestFileSystem) {
                            window.webkitRequestFileSystem(window.TEMPORARY, 1, function () {
                                isPrivate = false;
                            }, function (e) {
                                isPrivate = true;
                            });
                        } else if (window.indexedDB && /Firefox/.test(window.navigator.userAgent)) {
                            var db;
                            try {
                                db = window.indexedDB.open('test');
                                db.onerror = function () {
                                    return true;
                                };
                            } catch (e) {
                                isPrivate = true;
                            }

                            if (typeof isPrivate === 'undefined') {
                                retry(function isDone() {
                                    return db.readyState === 'done' ? true : false;
                                }, function next(isTimeout) {
                                    if (!isTimeout) {
                                        isPrivate = db.result ? false : true;
                                    }
                                });
                            }
                        } else if (isIE10OrLater(window.navigator.userAgent)) {
                            isPrivate = false;
                            try {
                                if (!window.indexedDB) {
                                    isPrivate = true;
                                }
                            } catch (e) {
                                isPrivate = true;
                            }
                        } else if (window.localStorage && /Safari/.test(window.navigator.userAgent)) {
                            try {
                                window.localStorage.setItem('test', 1);
                            } catch (e) {
                                isPrivate = true;
                            }

                            if (typeof isPrivate === 'undefined') {
                                isPrivate = false;
                                window.localStorage.removeItem('test');
                            }
                        }
                    } catch (e) {
                        isPrivate = false;
                    }

                    retry(function isDone() {
                        return typeof isPrivate !== 'undefined' ? true : false;
                    }, function next(isTimeout) {
                        callback(isPrivate);
                    });
                }

                var isMobile = {
                    Android: function () {
                        return navigator.userAgent.match(/Android/i);
                    },
                    BlackBerry: function () {
                        return navigator.userAgent.match(/BlackBerry|BB10/i);
                    },
                    iOS: function () {
                        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
                    },
                    Opera: function () {
                        return navigator.userAgent.match(/Opera Mini/i);
                    },
                    Windows: function () {
                        return navigator.userAgent.match(/IEMobile/i);
                    },
                    any: function () {
                        return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
                    },
                    getOsName: function () {
                        var osName = 'Unknown OS';
                        if (isMobile.Android()) {
                            osName = 'Android';
                        }

                        if (isMobile.BlackBerry()) {
                            osName = 'BlackBerry';
                        }

                        if (isMobile.iOS()) {
                            osName = 'iOS';
                        }

                        if (isMobile.Opera()) {
                            osName = 'Opera Mini';
                        }

                        if (isMobile.Windows()) {
                            osName = 'Windows';
                        }

                        return osName;
                    }
                };

                // via: http://jsfiddle.net/ChristianL/AVyND/
                function detectDesktopOS() {
                    var unknown = '-';

                    var nVer = navigator.appVersion;
                    var nAgt = navigator.userAgent;

                    var os = unknown;
                    var clientStrings = [{
                        s: 'Windows 10',
                        r: /(Windows 10.0|Windows NT 10.0)/
                    }, {
                        s: 'Windows 8.1',
                        r: /(Windows 8.1|Windows NT 6.3)/
                    }, {
                        s: 'Windows 8',
                        r: /(Windows 8|Windows NT 6.2)/
                    }, {
                        s: 'Windows 7',
                        r: /(Windows 7|Windows NT 6.1)/
                    }, {
                        s: 'Windows Vista',
                        r: /Windows NT 6.0/
                    }, {
                        s: 'Windows Server 2003',
                        r: /Windows NT 5.2/
                    }, {
                        s: 'Windows XP',
                        r: /(Windows NT 5.1|Windows XP)/
                    }, {
                        s: 'Windows 2000',
                        r: /(Windows NT 5.0|Windows 2000)/
                    }, {
                        s: 'Windows ME',
                        r: /(Win 9x 4.90|Windows ME)/
                    }, {
                        s: 'Windows 98',
                        r: /(Windows 98|Win98)/
                    }, {
                        s: 'Windows 95',
                        r: /(Windows 95|Win95|Windows_95)/
                    }, {
                        s: 'Windows NT 4.0',
                        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
                    }, {
                        s: 'Windows CE',
                        r: /Windows CE/
                    }, {
                        s: 'Windows 3.11',
                        r: /Win16/
                    }, {
                        s: 'Android',
                        r: /Android/
                    }, {
                        s: 'Open BSD',
                        r: /OpenBSD/
                    }, {
                        s: 'Sun OS',
                        r: /SunOS/
                    }, {
                        s: 'Linux',
                        r: /(Linux|X11)/
                    }, {
                        s: 'iOS',
                        r: /(iPhone|iPad|iPod)/
                    }, {
                        s: 'Mac OS X',
                        r: /Mac OS X/
                    }, {
                        s: 'Mac OS',
                        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
                    }, {
                        s: 'QNX',
                        r: /QNX/
                    }, {
                        s: 'UNIX',
                        r: /UNIX/
                    }, {
                        s: 'BeOS',
                        r: /BeOS/
                    }, {
                        s: 'OS/2',
                        r: /OS\/2/
                    }, {
                        s: 'Search Bot',
                        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
                    }];
                    for (var i = 0, cs; cs = clientStrings[i]; i++) {
                        if (cs.r.test(nAgt)) {
                            os = cs.s;
                            break;
                        }
                    }

                    var osVersion = unknown;

                    if (/Windows/.test(os)) {
                        if (/Windows (.*)/.test(os)) {
                            osVersion = /Windows (.*)/.exec(os)[1];
                        }
                        os = 'Windows';
                    }

                    switch (os) {
                        case 'Mac OS X':
                            if (/Mac OS X (10[\.\_\d]+)/.test(nAgt)) {
                                osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1];
                            }
                            break;
                        case 'Android':
                            if (/Android ([\.\_\d]+)/.test(nAgt)) {
                                osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1];
                            }
                            break;
                        case 'iOS':
                            if (/OS (\d+)_(\d+)_?(\d+)?/.test(nAgt)) {
                                osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
                                osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
                            }
                            break;
                    }

                    return {
                        osName: os,
                        osVersion: osVersion
                    };
                }

                var osName = 'Unknown OS';
                var osVersion = 'Unknown OS Version';

                function getAndroidVersion(ua) {
                    ua = (ua || navigator.userAgent).toLowerCase();
                    var match = ua.match(/android\s([0-9\.]*)/);
                    return match ? match[1] : false;
                }

                var osInfo = detectDesktopOS();

                if (osInfo && osInfo.osName && osInfo.osName != '-') {
                    osName = osInfo.osName;
                    osVersion = osInfo.osVersion;
                } else if (isMobile.any()) {
                    osName = isMobile.getOsName();

                    if (osName == 'Android') {
                        osVersion = getAndroidVersion();
                    }
                }

                var isNodejs = typeof process === 'object' && typeof process.versions === 'object' && process.versions.node;

                if (osName === 'Unknown OS' && isNodejs) {
                    osName = 'Nodejs';
                    osVersion = process.versions.node.toString().replace('v', '');
                }

                var isCanvasSupportsStreamCapturing = false;
                var isVideoSupportsStreamCapturing = false;
                ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function (item) {
                    if (typeof document === 'undefined' || typeof document.createElement !== 'function') {
                        return;
                    }

                    if (!isCanvasSupportsStreamCapturing && item in document.createElement('canvas')) {
                        isCanvasSupportsStreamCapturing = true;
                    }

                    if (!isVideoSupportsStreamCapturing && item in document.createElement('video')) {
                        isVideoSupportsStreamCapturing = true;
                    }
                });

                var regexIpv4Local = /^(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/,
                    regexIpv4 = /([0-9]{1,3}(\.[0-9]{1,3}){3})/,
                    regexIpv6 = /[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7}/;

                // via: https://github.com/diafygi/webrtc-ips
                function DetectLocalIPAddress(callback, stream) {
                    if (!DetectRTC.isWebRTCSupported) {
                        return;
                    }

                    var isPublic = true,
                        isIpv4 = true;
                    getIPs(function (ip) {
                        if (!ip) {
                            callback(); // Pass nothing to tell that ICE-gathering-ended
                        } else if (ip.match(regexIpv4Local)) {
                            isPublic = false;
                            callback('Local: ' + ip, isPublic, isIpv4);
                        } else if (ip.match(regexIpv6)) {
                            //via https://ourcodeworld.com/articles/read/257/how-to-get-the-client-ip-address-with-javascript-only
                            isIpv4 = false;
                            callback('Public: ' + ip, isPublic, isIpv4);
                        } else {
                            callback('Public: ' + ip, isPublic, isIpv4);
                        }
                    }, stream);
                }

                function getIPs(callback, stream) {
                    if (typeof document === 'undefined' || typeof document.getElementById !== 'function') {
                        return;
                    }

                    var ipDuplicates = {};

                    var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;

                    if (!RTCPeerConnection) {
                        var iframe = document.getElementById('iframe');
                        if (!iframe) {
                            return;
                        }
                        var win = iframe.contentWindow;
                        RTCPeerConnection = win.RTCPeerConnection || win.mozRTCPeerConnection || win.webkitRTCPeerConnection;
                    }

                    if (!RTCPeerConnection) {
                        return;
                    }

                    var peerConfig = null;

                    if (DetectRTC.browser === 'Chrome' && DetectRTC.browser.version < 58) {
                        // todo: add support for older Opera
                        peerConfig = {
                            optional: [{
                                RtpDataChannels: true
                            }]
                        };
                    }

                    var servers = {
                        iceServers: [{
                            urls: 'stun:stun.l.google.com:19302'
                        }]
                    };

                    var pc = new RTCPeerConnection(servers, peerConfig);

                    if (stream) {
                        if (pc.addStream) {
                            pc.addStream(stream);
                        } else if (pc.addTrack && stream.getTracks()[0]) {
                            pc.addTrack(stream.getTracks()[0], stream);
                        }
                    }

                    function handleCandidate(candidate) {
                        if (!candidate) {
                            callback(); // Pass nothing to tell that ICE-gathering-ended
                            return;
                        }

                        var match = regexIpv4.exec(candidate);
                        if (!match) {
                            return;
                        }
                        var ipAddress = match[1];
                        var isPublic = candidate.match(regexIpv4Local),
                            isIpv4 = true;

                        if (ipDuplicates[ipAddress] === undefined) {
                            callback(ipAddress, isPublic, isIpv4);
                        }

                        ipDuplicates[ipAddress] = true;
                    }

                    // listen for candidate events
                    pc.onicecandidate = function (event) {
                        if (event.candidate && event.candidate.candidate) {
                            handleCandidate(event.candidate.candidate);
                        } else {
                            handleCandidate(); // Pass nothing to tell that ICE-gathering-ended
                        }
                    };

                    // create data channel
                    if (!stream) {
                        try {
                            pc.createDataChannel('sctp', {});
                        } catch (e) {}
                    }

                    // create an offer sdp
                    if (DetectRTC.isPromisesSupported) {
                        pc.createOffer().then(function (result) {
                            pc.setLocalDescription(result).then(afterCreateOffer);
                        });
                    } else {
                        pc.createOffer(function (result) {
                            pc.setLocalDescription(result, afterCreateOffer, function () {});
                        }, function () {});
                    }

                    function afterCreateOffer() {
                        var lines = pc.localDescription.sdp.split('\n');

                        lines.forEach(function (line) {
                            if (line && line.indexOf('a=candidate:') === 0) {
                                handleCandidate(line);
                            }
                        });
                    }
                }

                var MediaDevices = [];

                var audioInputDevices = [];
                var audioOutputDevices = [];
                var videoInputDevices = [];

                if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                    // Firefox 38+ seems having support of enumerateDevices
                    // Thanks @xdumaine/enumerateDevices
                    navigator.enumerateDevices = function (callback) {
                        var enumerateDevices = navigator.mediaDevices.enumerateDevices();
                        if (enumerateDevices && enumerateDevices.then) {
                            navigator.mediaDevices.enumerateDevices().then(callback).catch(function () {
                                callback([]);
                            });
                        } else {
                            callback([]);
                        }
                    };
                }

                // Media Devices detection
                var canEnumerate = false;

                /*global MediaStreamTrack:true */
                if (typeof MediaStreamTrack !== 'undefined' && 'getSources' in MediaStreamTrack) {
                    canEnumerate = true;
                } else if (navigator.mediaDevices && !!navigator.mediaDevices.enumerateDevices) {
                    canEnumerate = true;
                }

                var hasMicrophone = false;
                var hasSpeakers = false;
                var hasWebcam = false;

                var isWebsiteHasMicrophonePermissions = false;
                var isWebsiteHasWebcamPermissions = false;

                // http://dev.w3.org/2011/webrtc/editor/getusermedia.html#mediadevices
                function checkDeviceSupport(callback) {
                    if (!canEnumerate) {
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    if (!navigator.enumerateDevices && window.MediaStreamTrack && window.MediaStreamTrack.getSources) {
                        navigator.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack);
                    }

                    if (!navigator.enumerateDevices && navigator.enumerateDevices) {
                        navigator.enumerateDevices = navigator.enumerateDevices.bind(navigator);
                    }

                    if (!navigator.enumerateDevices) {
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    MediaDevices = [];

                    audioInputDevices = [];
                    audioOutputDevices = [];
                    videoInputDevices = [];

                    hasMicrophone = false;
                    hasSpeakers = false;
                    hasWebcam = false;

                    isWebsiteHasMicrophonePermissions = false;
                    isWebsiteHasWebcamPermissions = false;

                    // to prevent duplication
                    var alreadyUsedDevices = {};

                    navigator.enumerateDevices(function (devices) {
                        devices.forEach(function (_device) {
                            var device = {};
                            for (var d in _device) {
                                try {
                                    if (typeof _device[d] !== 'function') {
                                        device[d] = _device[d];
                                    }
                                } catch (e) {}
                            }

                            if (alreadyUsedDevices[device.deviceId + device.label + device.kind]) {
                                return;
                            }

                            // if it is MediaStreamTrack.getSources
                            if (device.kind === 'audio') {
                                device.kind = 'audioinput';
                            }

                            if (device.kind === 'video') {
                                device.kind = 'videoinput';
                            }

                            if (!device.deviceId) {
                                device.deviceId = device.id;
                            }

                            if (!device.id) {
                                device.id = device.deviceId;
                            }

                            if (!device.label) {
                                device.isCustomLabel = true;

                                if (device.kind === 'videoinput') {
                                    device.label = 'Camera ' + (videoInputDevices.length + 1);
                                } else if (device.kind === 'audioinput') {
                                    device.label = 'Microphone ' + (audioInputDevices.length + 1);
                                } else if (device.kind === 'audiooutput') {
                                    device.label = 'Speaker ' + (audioOutputDevices.length + 1);
                                } else {
                                    device.label = 'Please invoke getUserMedia once.';
                                }

                                if (typeof DetectRTC !== 'undefined' && DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
                                    if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
                                        device.label = 'HTTPs is required to get label of this ' + device.kind + ' device.';
                                    }
                                }
                            } else {
                                // Firefox on Android still returns empty label
                                if (device.kind === 'videoinput' && !isWebsiteHasWebcamPermissions) {
                                    isWebsiteHasWebcamPermissions = true;
                                }

                                if (device.kind === 'audioinput' && !isWebsiteHasMicrophonePermissions) {
                                    isWebsiteHasMicrophonePermissions = true;
                                }
                            }

                            if (device.kind === 'audioinput') {
                                hasMicrophone = true;

                                if (audioInputDevices.indexOf(device) === -1) {
                                    audioInputDevices.push(device);
                                }
                            }

                            if (device.kind === 'audiooutput') {
                                hasSpeakers = true;

                                if (audioOutputDevices.indexOf(device) === -1) {
                                    audioOutputDevices.push(device);
                                }
                            }

                            if (device.kind === 'videoinput') {
                                hasWebcam = true;

                                if (videoInputDevices.indexOf(device) === -1) {
                                    videoInputDevices.push(device);
                                }
                            }

                            // there is no 'videoouput' in the spec.
                            MediaDevices.push(device);

                            alreadyUsedDevices[device.deviceId + device.label + device.kind] = device;
                        });

                        if (typeof DetectRTC !== 'undefined') {
                            // to sync latest outputs
                            DetectRTC.MediaDevices = MediaDevices;
                            DetectRTC.hasMicrophone = hasMicrophone;
                            DetectRTC.hasSpeakers = hasSpeakers;
                            DetectRTC.hasWebcam = hasWebcam;

                            DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;
                            DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;

                            DetectRTC.audioInputDevices = audioInputDevices;
                            DetectRTC.audioOutputDevices = audioOutputDevices;
                            DetectRTC.videoInputDevices = videoInputDevices;
                        }

                        if (callback) {
                            callback();
                        }
                    });
                }

                var DetectRTC = window.DetectRTC || {};

                // ----------
                // DetectRTC.browser.name || DetectRTC.browser.version || DetectRTC.browser.fullVersion
                DetectRTC.browser = getBrowserInfo();

                detectPrivateMode(function (isPrivateBrowsing) {
                    DetectRTC.browser.isPrivateBrowsing = !!isPrivateBrowsing;
                });

                // DetectRTC.isChrome || DetectRTC.isFirefox || DetectRTC.isEdge
                DetectRTC.browser['is' + DetectRTC.browser.name] = true;

                // -----------
                DetectRTC.osName = osName;
                DetectRTC.osVersion = osVersion;

                var isNodeWebkit = typeof process === 'object' && typeof process.versions === 'object' && process.versions['node-webkit'];

                // --------- Detect if system supports WebRTC 1.0 or WebRTC 1.1.
                var isWebRTCSupported = false;
                ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function (item) {
                    if (isWebRTCSupported) {
                        return;
                    }

                    if (item in window) {
                        isWebRTCSupported = true;
                    }
                });
                DetectRTC.isWebRTCSupported = isWebRTCSupported;

                //-------
                DetectRTC.isORTCSupported = typeof RTCIceGatherer !== 'undefined';

                // --------- Detect if system supports screen capturing API
                var isScreenCapturingSupported = false;
                if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 35) {
                    isScreenCapturingSupported = true;
                } else if (DetectRTC.browser.isFirefox && DetectRTC.browser.version >= 34) {
                    isScreenCapturingSupported = true;
                } else if (DetectRTC.browser.isEdge && DetectRTC.browser.version >= 17) {
                    isScreenCapturingSupported = true; // navigator.getDisplayMedia
                } else if (DetectRTC.osName === 'Android' && DetectRTC.browser.isChrome) {
                    isScreenCapturingSupported = true;
                }

                if (!/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
                    var isNonLocalHost = typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1;
                    if (isNonLocalHost && (DetectRTC.browser.isChrome || DetectRTC.browser.isEdge || DetectRTC.browser.isOpera)) {
                        isScreenCapturingSupported = false;
                    } else if (DetectRTC.browser.isFirefox) {
                        isScreenCapturingSupported = false;
                    }
                }
                DetectRTC.isScreenCapturingSupported = isScreenCapturingSupported;

                // --------- Detect if WebAudio API are supported
                var webAudio = {
                    isSupported: false,
                    isCreateMediaStreamSourceSupported: false
                };

                ['AudioContext', 'webkitAudioContext', 'mozAudioContext', 'msAudioContext'].forEach(function (item) {
                    if (webAudio.isSupported) {
                        return;
                    }

                    if (item in window) {
                        webAudio.isSupported = true;

                        if (window[item] && 'createMediaStreamSource' in window[item].prototype) {
                            webAudio.isCreateMediaStreamSourceSupported = true;
                        }
                    }
                });
                DetectRTC.isAudioContextSupported = webAudio.isSupported;
                DetectRTC.isCreateMediaStreamSourceSupported = webAudio.isCreateMediaStreamSourceSupported;

                // ---------- Detect if SCTP/RTP channels are supported.

                var isRtpDataChannelsSupported = false;
                if (DetectRTC.browser.isChrome && DetectRTC.browser.version > 31) {
                    isRtpDataChannelsSupported = true;
                }
                DetectRTC.isRtpDataChannelsSupported = isRtpDataChannelsSupported;

                var isSCTPSupportd = false;
                if (DetectRTC.browser.isFirefox && DetectRTC.browser.version > 28) {
                    isSCTPSupportd = true;
                } else if (DetectRTC.browser.isChrome && DetectRTC.browser.version > 25) {
                    isSCTPSupportd = true;
                } else if (DetectRTC.browser.isOpera && DetectRTC.browser.version >= 11) {
                    isSCTPSupportd = true;
                }
                DetectRTC.isSctpDataChannelsSupported = isSCTPSupportd;

                // ---------

                DetectRTC.isMobileDevice = isMobileDevice; // "isMobileDevice" boolean is defined in "getBrowserInfo.js"

                // ------
                var isGetUserMediaSupported = false;
                if (navigator.getUserMedia) {
                    isGetUserMediaSupported = true;
                } else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    isGetUserMediaSupported = true;
                }

                if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
                    if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
                        isGetUserMediaSupported = 'Requires HTTPs';
                    }
                }

                if (DetectRTC.osName === 'Nodejs') {
                    isGetUserMediaSupported = false;
                }
                DetectRTC.isGetUserMediaSupported = isGetUserMediaSupported;

                var displayResolution = '';
                if (screen.width) {
                    var width = screen.width ? screen.width : '';
                    var height = screen.height ? screen.height : '';
                    displayResolution += '' + width + ' x ' + height;
                }
                DetectRTC.displayResolution = displayResolution;

                function getAspectRatio(w, h) {
                    function gcd(a, b) {
                        return b == 0 ? a : gcd(b, a % b);
                    }
                    var r = gcd(w, h);
                    return w / r / (h / r);
                }

                DetectRTC.displayAspectRatio = getAspectRatio(screen.width, screen.height).toFixed(2);

                // ----------
                DetectRTC.isCanvasSupportsStreamCapturing = isCanvasSupportsStreamCapturing;
                DetectRTC.isVideoSupportsStreamCapturing = isVideoSupportsStreamCapturing;

                if (DetectRTC.browser.name == 'Chrome' && DetectRTC.browser.version >= 53) {
                    if (!DetectRTC.isCanvasSupportsStreamCapturing) {
                        DetectRTC.isCanvasSupportsStreamCapturing = 'Requires chrome flag: enable-experimental-web-platform-features';
                    }

                    if (!DetectRTC.isVideoSupportsStreamCapturing) {
                        DetectRTC.isVideoSupportsStreamCapturing = 'Requires chrome flag: enable-experimental-web-platform-features';
                    }
                }

                // ------
                DetectRTC.DetectLocalIPAddress = DetectLocalIPAddress;

                DetectRTC.isWebSocketsSupported = 'WebSocket' in window && 2 === window.WebSocket.CLOSING;
                DetectRTC.isWebSocketsBlocked = !DetectRTC.isWebSocketsSupported;

                if (DetectRTC.osName === 'Nodejs') {
                    DetectRTC.isWebSocketsSupported = true;
                    DetectRTC.isWebSocketsBlocked = false;
                }

                DetectRTC.checkWebSocketsSupport = function (callback) {
                    callback = callback || function () {};
                    try {
                        var starttime;
                        var websocket = new WebSocket('wss://echo.websocket.org:443/');
                        websocket.onopen = function () {
                            DetectRTC.isWebSocketsBlocked = false;
                            starttime = new Date().getTime();
                            websocket.send('ping');
                        };
                        websocket.onmessage = function () {
                            DetectRTC.WebsocketLatency = new Date().getTime() - starttime + 'ms';
                            callback();
                            websocket.close();
                            websocket = null;
                        };
                        websocket.onerror = function () {
                            DetectRTC.isWebSocketsBlocked = true;
                            callback();
                        };
                    } catch (e) {
                        DetectRTC.isWebSocketsBlocked = true;
                        callback();
                    }
                };

                // -------
                DetectRTC.load = function (callback) {
                    callback = callback || function () {};
                    checkDeviceSupport(callback);
                };

                // check for microphone/camera support!
                if (typeof checkDeviceSupport === 'function') {
                    // checkDeviceSupport();
                }

                if (typeof MediaDevices !== 'undefined') {
                    DetectRTC.MediaDevices = MediaDevices;
                } else {
                    DetectRTC.MediaDevices = [];
                }

                DetectRTC.hasMicrophone = hasMicrophone;
                DetectRTC.hasSpeakers = hasSpeakers;
                DetectRTC.hasWebcam = hasWebcam;

                DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;
                DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;

                DetectRTC.audioInputDevices = audioInputDevices;
                DetectRTC.audioOutputDevices = audioOutputDevices;
                DetectRTC.videoInputDevices = videoInputDevices;

                // ------
                var isSetSinkIdSupported = false;
                if (typeof document !== 'undefined' && typeof document.createElement === 'function' && 'setSinkId' in document.createElement('video')) {
                    isSetSinkIdSupported = true;
                }
                DetectRTC.isSetSinkIdSupported = isSetSinkIdSupported;

                // -----
                var isRTPSenderReplaceTracksSupported = false;
                if (DetectRTC.browser.isFirefox && typeof mozRTCPeerConnection !== 'undefined' /*&& DetectRTC.browser.version > 39*/) {
                        /*global mozRTCPeerConnection:true */
                        if ('getSenders' in mozRTCPeerConnection.prototype) {
                            isRTPSenderReplaceTracksSupported = true;
                        }
                    } else if (DetectRTC.browser.isChrome && typeof webkitRTCPeerConnection !== 'undefined') {
                    /*global webkitRTCPeerConnection:true */
                    if ('getSenders' in webkitRTCPeerConnection.prototype) {
                        isRTPSenderReplaceTracksSupported = true;
                    }
                }
                DetectRTC.isRTPSenderReplaceTracksSupported = isRTPSenderReplaceTracksSupported;

                //------
                var isRemoteStreamProcessingSupported = false;
                if (DetectRTC.browser.isFirefox && DetectRTC.browser.version > 38) {
                    isRemoteStreamProcessingSupported = true;
                }
                DetectRTC.isRemoteStreamProcessingSupported = isRemoteStreamProcessingSupported;

                //-------
                var isApplyConstraintsSupported = false;

                /*global MediaStreamTrack:true */
                if (typeof MediaStreamTrack !== 'undefined' && 'applyConstraints' in MediaStreamTrack.prototype) {
                    isApplyConstraintsSupported = true;
                }
                DetectRTC.isApplyConstraintsSupported = isApplyConstraintsSupported;

                //-------
                var isMultiMonitorScreenCapturingSupported = false;
                if (DetectRTC.browser.isFirefox && DetectRTC.browser.version >= 43) {
                    // version 43 merely supports platforms for multi-monitors
                    // version 44 will support exact multi-monitor selection i.e. you can select any monitor for screen capturing.
                    isMultiMonitorScreenCapturingSupported = true;
                }
                DetectRTC.isMultiMonitorScreenCapturingSupported = isMultiMonitorScreenCapturingSupported;

                DetectRTC.isPromisesSupported = !!('Promise' in window);

                // version is generated by "grunt"
                DetectRTC.version = '1.3.9';

                if (typeof DetectRTC === 'undefined') {
                    window.DetectRTC = {};
                }

                var MediaStream = window.MediaStream;

                if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
                    MediaStream = webkitMediaStream;
                }

                if (typeof MediaStream !== 'undefined' && typeof MediaStream === 'function') {
                    DetectRTC.MediaStream = Object.keys(MediaStream.prototype);
                } else DetectRTC.MediaStream = false;

                if (typeof MediaStreamTrack !== 'undefined') {
                    DetectRTC.MediaStreamTrack = Object.keys(MediaStreamTrack.prototype);
                } else DetectRTC.MediaStreamTrack = false;

                var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;

                if (typeof RTCPeerConnection !== 'undefined') {
                    DetectRTC.RTCPeerConnection = Object.keys(RTCPeerConnection.prototype);
                } else DetectRTC.RTCPeerConnection = false;

                window.DetectRTC = DetectRTC;

                if (typeof module !== 'undefined' /* && !!module.exports*/) {
                        module.exports = DetectRTC;
                    }

                if (typeof define === 'function' && define.amd) {
                    define('DetectRTC', [], function () {
                        return DetectRTC;
                    });
                }
            })();

            // globals.js

            if (typeof cordova !== 'undefined') {
                DetectRTC.isMobileDevice = true;
                DetectRTC.browser.name = 'Chrome';
            }

            if (navigator && navigator.userAgent && navigator.userAgent.indexOf('Crosswalk') !== -1) {
                DetectRTC.isMobileDevice = true;
                DetectRTC.browser.name = 'Chrome';
            }

            function fireEvent(obj, eventName, args) {
                if (typeof CustomEvent === 'undefined') {
                    return;
                }

                var eventDetail = {
                    arguments: args,
                    __exposedProps__: args
                };

                var event = new CustomEvent(eventName, eventDetail);
                obj.dispatchEvent(event);
            }

            function setHarkEvents(connection, streamEvent) {
                if (!streamEvent.stream || !getTracks(streamEvent.stream, 'audio').length) return;

                if (!connection || !streamEvent) {
                    throw 'Both arguments are required.';
                }

                if (!connection.onspeaking || !connection.onsilence) {
                    return;
                }

                if (typeof hark === 'undefined') {
                    throw 'hark.js not found.';
                }

                hark(streamEvent.stream, {
                    onspeaking: function () {
                        connection.onspeaking(streamEvent);
                    },
                    onsilence: function () {
                        connection.onsilence(streamEvent);
                    },
                    onvolumechange: function (volume, threshold) {
                        if (!connection.onvolumechange) {
                            return;
                        }
                        connection.onvolumechange(merge({
                            volume: volume,
                            threshold: threshold
                        }, streamEvent));
                    }
                });
            }

            function setMuteHandlers(connection, streamEvent) {
                if (!streamEvent.stream || !streamEvent.stream || !streamEvent.stream.addEventListener) return;

                streamEvent.stream.addEventListener('mute', function (event) {
                    event = connection.streamEvents[streamEvent.streamid];

                    event.session = {
                        audio: event.muteType === 'audio',
                        video: event.muteType === 'video'
                    };

                    connection.onmute(event);
                }, false);

                streamEvent.stream.addEventListener('unmute', function (event) {
                    event = connection.streamEvents[streamEvent.streamid];

                    event.session = {
                        audio: event.unmuteType === 'audio',
                        video: event.unmuteType === 'video'
                    };

                    connection.onunmute(event);
                }, false);
            }

            function getRandomString() {
                if (window.crypto && window.crypto.getRandomValues && navigator.userAgent.indexOf('Safari') === -1) {
                    var a = window.crypto.getRandomValues(new Uint32Array(3)),
                        token = '';
                    for (var i = 0, l = a.length; i < l; i++) {
                        token += a[i].toString(36);
                    }
                    return token;
                } else {
                    return (Math.random() * new Date().getTime()).toString(36).replace(/\./g, '');
                }
            }

            // Get HTMLAudioElement/HTMLVideoElement accordingly
            // todo: add API documentation for connection.autoCreateMediaElement

            function getRMCMediaElement(stream, callback, connection) {
                if (!connection.autoCreateMediaElement) {
                    callback({});
                    return;
                }

                var isAudioOnly = false;
                if (!getTracks(stream, 'video').length && !stream.isVideo && !stream.isScreen) {
                    isAudioOnly = true;
                }

                if (DetectRTC.browser.name === 'Firefox') {
                    if (connection.session.video || connection.session.screen) {
                        isAudioOnly = false;
                    }
                }

                var mediaElement = document.createElement(isAudioOnly ? 'audio' : 'video');

                mediaElement.srcObject = stream;

                mediaElement.setAttribute('autoplay', true);
                mediaElement.setAttribute('playsinline', true);
                mediaElement.setAttribute('controls', true);
                mediaElement.setAttribute('muted', false);
                mediaElement.setAttribute('volume', 1);

                // http://goo.gl/WZ5nFl
                // Firefox don't yet support onended for any stream (remote/local)
                if (DetectRTC.browser.name === 'Firefox') {
                    var streamEndedEvent = 'ended';

                    if ('oninactive' in mediaElement) {
                        streamEndedEvent = 'inactive';
                    }

                    mediaElement.addEventListener(streamEndedEvent, function () {
                        // fireEvent(stream, streamEndedEvent, stream);
                        currentUserMediaRequest.remove(stream.idInstance);

                        if (stream.type === 'local') {
                            streamEndedEvent = 'ended';

                            if ('oninactive' in stream) {
                                streamEndedEvent = 'inactive';
                            }

                            StreamsHandler.onSyncNeeded(stream.streamid, streamEndedEvent);

                            connection.attachStreams.forEach(function (aStream, idx) {
                                if (stream.streamid === aStream.streamid) {
                                    delete connection.attachStreams[idx];
                                }
                            });

                            var newStreamsArray = [];
                            connection.attachStreams.forEach(function (aStream) {
                                if (aStream) {
                                    newStreamsArray.push(aStream);
                                }
                            });
                            connection.attachStreams = newStreamsArray;

                            var streamEvent = connection.streamEvents[stream.streamid];

                            if (streamEvent) {
                                connection.onstreamended(streamEvent);
                                return;
                            }
                            if (this.parentNode) {
                                this.parentNode.removeChild(this);
                            }
                        }
                    }, false);
                }

                var played = mediaElement.play();
                if (typeof played !== 'undefined') {
                    var cbFired = false;
                    setTimeout(function () {
                        if (!cbFired) {
                            cbFired = true;
                            callback(mediaElement);
                        }
                    }, 1000);
                    played.then(function () {
                        if (cbFired) return;
                        cbFired = true;
                        callback(mediaElement);
                    }).catch(function (error) {
                        if (cbFired) return;
                        cbFired = true;
                        callback(mediaElement);
                    });
                } else {
                    callback(mediaElement);
                }
            }

            // if IE
            if (!window.addEventListener) {
                window.addEventListener = function (el, eventName, eventHandler) {
                    if (!el.attachEvent) {
                        return;
                    }
                    el.attachEvent('on' + eventName, eventHandler);
                };
            }

            function listenEventHandler(eventName, eventHandler) {
                window.removeEventListener(eventName, eventHandler);
                window.addEventListener(eventName, eventHandler, false);
            }

            window.attachEventListener = function (video, type, listener, useCapture) {
                video.addEventListener(type, listener, useCapture);
            };

            function removeNullEntries(array) {
                var newArray = [];
                array.forEach(function (item) {
                    if (item) {
                        newArray.push(item);
                    }
                });
                return newArray;
            }

            function isData(session) {
                return !session.audio && !session.video && !session.screen && session.data;
            }

            function isNull(obj) {
                return typeof obj === 'undefined';
            }

            function isString(obj) {
                return typeof obj === 'string';
            }

            var MediaStream = window.MediaStream;

            if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
                MediaStream = webkitMediaStream;
            }

            /*global MediaStream:true */
            if (typeof MediaStream !== 'undefined') {
                if (!('stop' in MediaStream.prototype)) {
                    MediaStream.prototype.stop = function () {
                        this.getTracks().forEach(function (track) {
                            track.stop();
                        });
                    };
                }
            }

            function isAudioPlusTab(connection, audioPlusTab) {
                if (connection.session.audio && connection.session.audio === 'two-way') {
                    return false;
                }

                if (DetectRTC.browser.name === 'Firefox' && audioPlusTab !== false) {
                    return true;
                }

                if (DetectRTC.browser.name !== 'Chrome' || DetectRTC.browser.version < 50) return false;

                if (typeof audioPlusTab === true) {
                    return true;
                }

                if (typeof audioPlusTab === 'undefined' && connection.session.audio && connection.session.screen && !connection.session.video) {
                    audioPlusTab = true;
                    return true;
                }

                return false;
            }

            function getAudioScreenConstraints(screen_constraints) {
                if (DetectRTC.browser.name === 'Firefox') {
                    return true;
                }

                if (DetectRTC.browser.name !== 'Chrome') return false;

                return {
                    mandatory: {
                        chromeMediaSource: screen_constraints.mandatory.chromeMediaSource,
                        chromeMediaSourceId: screen_constraints.mandatory.chromeMediaSourceId
                    }
                };
            }

            window.iOSDefaultAudioOutputDevice = window.iOSDefaultAudioOutputDevice || 'speaker'; // earpiece or speaker

            function getTracks(stream, kind) {
                if (!stream || !stream.getTracks) {
                    return [];
                }

                return stream.getTracks().filter(function (t) {
                    return t.kind === (kind || 'audio');
                });
            }

            function isUnifiedPlanSupportedDefault() {
                var canAddTransceiver = false;

                try {
                    if (typeof RTCRtpTransceiver === 'undefined') return false;
                    if (!('currentDirection' in RTCRtpTransceiver.prototype)) return false;

                    var tempPc = new RTCPeerConnection();

                    try {
                        tempPc.addTransceiver('audio');
                        canAddTransceiver = true;
                    } catch (e) {}

                    tempPc.close();
                } catch (e) {
                    canAddTransceiver = false;
                }

                return canAddTransceiver && isUnifiedPlanSuppored();
            }

            function isUnifiedPlanSuppored() {
                var isUnifiedPlanSupported = false;

                try {
                    var pc = new RTCPeerConnection({
                        sdpSemantics: 'unified-plan'
                    });

                    try {
                        var config = pc.getConfiguration();
                        if (config.sdpSemantics == 'unified-plan') isUnifiedPlanSupported = true;else if (config.sdpSemantics == 'plan-b') isUnifiedPlanSupported = false;else isUnifiedPlanSupported = false;
                    } catch (e) {
                        isUnifiedPlanSupported = false;
                    }
                } catch (e) {
                    isUnifiedPlanSupported = false;
                }

                return isUnifiedPlanSupported;
            }

            // ios-hacks.js

            function setCordovaAPIs() {
                // if (DetectRTC.osName !== 'iOS') return;
                if (typeof cordova === 'undefined' || typeof cordova.plugins === 'undefined' || typeof cordova.plugins.iosrtc === 'undefined') return;

                var iosrtc = cordova.plugins.iosrtc;
                window.webkitRTCPeerConnection = iosrtc.RTCPeerConnection;
                window.RTCSessionDescription = iosrtc.RTCSessionDescription;
                window.RTCIceCandidate = iosrtc.RTCIceCandidate;
                window.MediaStream = iosrtc.MediaStream;
                window.MediaStreamTrack = iosrtc.MediaStreamTrack;
                navigator.getUserMedia = navigator.webkitGetUserMedia = iosrtc.getUserMedia;

                iosrtc.debug.enable('iosrtc*');
                if (typeof iosrtc.selectAudioOutput == 'function') {
                    iosrtc.selectAudioOutput(window.iOSDefaultAudioOutputDevice || 'speaker'); // earpiece or speaker
                }
                iosrtc.registerGlobals();
            }

            document.addEventListener('deviceready', setCordovaAPIs, false);
            setCordovaAPIs();

            // RTCPeerConnection.js

            var defaults = {};

            function setSdpConstraints(config) {
                var sdpConstraints = {
                    OfferToReceiveAudio: !!config.OfferToReceiveAudio,
                    OfferToReceiveVideo: !!config.OfferToReceiveVideo
                };

                return sdpConstraints;
            }

            var RTCPeerConnection;
            if (typeof window.RTCPeerConnection !== 'undefined') {
                RTCPeerConnection = window.RTCPeerConnection;
            } else if (typeof mozRTCPeerConnection !== 'undefined') {
                RTCPeerConnection = mozRTCPeerConnection;
            } else if (typeof webkitRTCPeerConnection !== 'undefined') {
                RTCPeerConnection = webkitRTCPeerConnection;
            }

            var RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription;
            var RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;
            var MediaStreamTrack = window.MediaStreamTrack;

            function PeerInitiator(config) {
                if (typeof window.RTCPeerConnection !== 'undefined') {
                    RTCPeerConnection = window.RTCPeerConnection;
                } else if (typeof mozRTCPeerConnection !== 'undefined') {
                    RTCPeerConnection = mozRTCPeerConnection;
                } else if (typeof webkitRTCPeerConnection !== 'undefined') {
                    RTCPeerConnection = webkitRTCPeerConnection;
                }

                RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription;
                RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;
                MediaStreamTrack = window.MediaStreamTrack;

                if (!RTCPeerConnection) {
                    throw 'WebRTC 1.0 (RTCPeerConnection) API are NOT available in this browser.';
                }

                var connection = config.rtcMultiConnection;

                this.extra = config.remoteSdp ? config.remoteSdp.extra : connection.extra;
                this.userid = config.userid;
                this.streams = [];
                this.channels = config.channels || [];
                this.connectionDescription = config.connectionDescription;

                this.addStream = function (session) {
                    connection.addStream(session, self.userid);
                };

                this.removeStream = function (streamid) {
                    connection.removeStream(streamid, self.userid);
                };

                var self = this;

                if (config.remoteSdp) {
                    this.connectionDescription = config.remoteSdp.connectionDescription;
                }

                var allRemoteStreams = {};

                defaults.sdpConstraints = setSdpConstraints({
                    OfferToReceiveAudio: true,
                    OfferToReceiveVideo: true
                });

                var peer;

                var renegotiatingPeer = !!config.renegotiatingPeer;
                if (config.remoteSdp) {
                    renegotiatingPeer = !!config.remoteSdp.renegotiatingPeer;
                }

                var localStreams = [];
                connection.attachStreams.forEach(function (stream) {
                    if (!!stream) {
                        localStreams.push(stream);
                    }
                });

                if (!renegotiatingPeer) {
                    var iceTransports = 'all';
                    if (connection.candidates.turn || connection.candidates.relay) {
                        if (!connection.candidates.stun && !connection.candidates.reflexive && !connection.candidates.host) {
                            iceTransports = 'relay';
                        }
                    }

                    try {
                        // ref: developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration
                        var params = {
                            iceServers: connection.iceServers,
                            iceTransportPolicy: connection.iceTransportPolicy || iceTransports
                        };

                        if (typeof connection.iceCandidatePoolSize !== 'undefined') {
                            params.iceCandidatePoolSize = connection.iceCandidatePoolSize;
                        }

                        if (typeof connection.bundlePolicy !== 'undefined') {
                            params.bundlePolicy = connection.bundlePolicy;
                        }

                        if (typeof connection.rtcpMuxPolicy !== 'undefined') {
                            params.rtcpMuxPolicy = connection.rtcpMuxPolicy;
                        }

                        if (!!connection.sdpSemantics) {
                            params.sdpSemantics = connection.sdpSemantics || 'unified-plan';
                        }

                        if (!connection.iceServers || !connection.iceServers.length) {
                            params = null;
                            connection.optionalArgument = null;
                        }

                        peer = new RTCPeerConnection(params, connection.optionalArgument);
                    } catch (e) {
                        try {
                            var params = {
                                iceServers: connection.iceServers
                            };

                            peer = new RTCPeerConnection(params);
                        } catch (e) {
                            peer = new RTCPeerConnection();
                        }
                    }
                } else {
                    peer = config.peerRef;
                }

                if (!peer.getRemoteStreams && peer.getReceivers) {
                    peer.getRemoteStreams = function () {
                        var stream = new MediaStream();
                        peer.getReceivers().forEach(function (receiver) {
                            stream.addTrack(receiver.track);
                        });
                        return [stream];
                    };
                }

                if (!peer.getLocalStreams && peer.getSenders) {
                    peer.getLocalStreams = function () {
                        var stream = new MediaStream();
                        peer.getSenders().forEach(function (sender) {
                            stream.addTrack(sender.track);
                        });
                        return [stream];
                    };
                }

                peer.onicecandidate = function (event) {
                    if (!event.candidate) {
                        if (!connection.trickleIce) {
                            var localSdp = peer.localDescription;
                            config.onLocalSdp({
                                type: localSdp.type,
                                sdp: localSdp.sdp,
                                remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,
                                renegotiatingPeer: !!config.renegotiatingPeer || false,
                                connectionDescription: self.connectionDescription,
                                dontGetRemoteStream: !!config.dontGetRemoteStream,
                                extra: connection ? connection.extra : {},
                                streamsToShare: streamsToShare
                            });
                        }
                        return;
                    }

                    if (!connection.trickleIce) return;
                    config.onLocalCandidate({
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    });
                };

                localStreams.forEach(function (localStream) {
                    if (config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.dontGetRemoteStream) {
                        return;
                    }

                    if (config.dontAttachLocalStream) {
                        return;
                    }

                    localStream = connection.beforeAddingStream(localStream, self);

                    if (!localStream) return;

                    peer.getLocalStreams().forEach(function (stream) {
                        if (localStream && stream.id == localStream.id) {
                            localStream = null;
                        }
                    });

                    if (localStream && localStream.getTracks) {
                        localStream.getTracks().forEach(function (track) {
                            try {
                                // last parameter is redundant for unified-plan
                                // starting from chrome version 72
                                peer.addTrack(track, localStream);
                            } catch (e) {}
                        });
                    }
                });

                peer.oniceconnectionstatechange = peer.onsignalingstatechange = function () {
                    var extra = self.extra;
                    if (connection.peers[self.userid]) {
                        extra = connection.peers[self.userid].extra || extra;
                    }

                    if (!peer) {
                        return;
                    }

                    config.onPeerStateChanged({
                        iceConnectionState: peer.iceConnectionState,
                        iceGatheringState: peer.iceGatheringState,
                        signalingState: peer.signalingState,
                        extra: extra,
                        userid: self.userid
                    });

                    if (peer && peer.iceConnectionState && peer.iceConnectionState.search(/closed|failed/gi) !== -1 && self.streams instanceof Array) {
                        self.streams.forEach(function (stream) {
                            var streamEvent = connection.streamEvents[stream.id] || {
                                streamid: stream.id,
                                stream: stream,
                                type: 'remote'
                            };

                            connection.onstreamended(streamEvent);
                        });
                    }
                };

                var sdpConstraints = {
                    OfferToReceiveAudio: !!localStreams.length,
                    OfferToReceiveVideo: !!localStreams.length
                };

                if (config.localPeerSdpConstraints) sdpConstraints = config.localPeerSdpConstraints;

                defaults.sdpConstraints = setSdpConstraints(sdpConstraints);

                var streamObject;
                var dontDuplicate = {};

                peer.ontrack = function (event) {
                    if (!event || event.type !== 'track') return;

                    event.stream = event.streams[event.streams.length - 1];

                    if (!event.stream.id) {
                        event.stream.id = event.track.id;
                    }

                    if (dontDuplicate[event.stream.id] && DetectRTC.browser.name !== 'Safari') {
                        if (event.track) {
                            event.track.onended = function () {
                                // event.track.onmute = 
                                peer && peer.onremovestream(event);
                            };
                        }
                        return;
                    }

                    dontDuplicate[event.stream.id] = event.stream.id;

                    var streamsToShare = {};
                    if (config.remoteSdp && config.remoteSdp.streamsToShare) {
                        streamsToShare = config.remoteSdp.streamsToShare;
                    } else if (config.streamsToShare) {
                        streamsToShare = config.streamsToShare;
                    }

                    var streamToShare = streamsToShare[event.stream.id];
                    if (streamToShare) {
                        event.stream.isAudio = streamToShare.isAudio;
                        event.stream.isVideo = streamToShare.isVideo;
                        event.stream.isScreen = streamToShare.isScreen;
                    } else {
                        event.stream.isVideo = !!getTracks(event.stream, 'video').length;
                        event.stream.isAudio = !event.stream.isVideo;
                        event.stream.isScreen = false;
                    }

                    event.stream.streamid = event.stream.id;

                    allRemoteStreams[event.stream.id] = event.stream;
                    config.onRemoteStream(event.stream);

                    event.stream.getTracks().forEach(function (track) {
                        track.onended = function () {
                            // track.onmute = 
                            peer && peer.onremovestream(event);
                        };
                    });

                    event.stream.onremovetrack = function () {
                        peer && peer.onremovestream(event);
                    };
                };

                peer.onremovestream = function (event) {
                    // this event doesn't works anymore
                    event.stream.streamid = event.stream.id;

                    if (allRemoteStreams[event.stream.id]) {
                        delete allRemoteStreams[event.stream.id];
                    }

                    config.onRemoteStreamRemoved(event.stream);
                };

                if (typeof peer.removeStream !== 'function') {
                    // removeStream backward compatibility
                    peer.removeStream = function (stream) {
                        stream.getTracks().forEach(function (track) {
                            peer.removeTrack(track, stream);
                        });
                    };
                }

                this.addRemoteCandidate = function (remoteCandidate) {
                    peer.addIceCandidate(new RTCIceCandidate(remoteCandidate));
                };

                function oldAddRemoteSdp(remoteSdp, cb) {
                    cb = cb || function () {};

                    if (DetectRTC.browser.name !== 'Safari') {
                        remoteSdp.sdp = connection.processSdp(remoteSdp.sdp);
                    }
                    peer.setRemoteDescription(new RTCSessionDescription(remoteSdp), cb, function (error) {
                        if (!!connection.enableLogs) {
                            console.error('setRemoteDescription failed', '\n', error, '\n', remoteSdp.sdp);
                        }

                        cb();
                    });
                }

                this.addRemoteSdp = function (remoteSdp, cb) {
                    cb = cb || function () {};

                    if (DetectRTC.browser.name !== 'Safari') {
                        remoteSdp.sdp = connection.processSdp(remoteSdp.sdp);
                    }

                    peer.setRemoteDescription(new RTCSessionDescription(remoteSdp)).then(cb, function (error) {
                        if (!!connection.enableLogs) {
                            console.error('setRemoteDescription failed', '\n', error, '\n', remoteSdp.sdp);
                        }

                        cb();
                    }).catch(function (error) {
                        if (!!connection.enableLogs) {
                            console.error('setRemoteDescription failed', '\n', error, '\n', remoteSdp.sdp);
                        }

                        cb();
                    });
                };

                var isOfferer = true;

                if (config.remoteSdp) {
                    isOfferer = false;
                }

                this.createDataChannel = function () {
                    var channel = peer.createDataChannel('sctp', {});
                    setChannelEvents(channel);
                };

                if (connection.session.data === true && !renegotiatingPeer) {
                    if (!isOfferer) {
                        peer.ondatachannel = function (event) {
                            var channel = event.channel;
                            setChannelEvents(channel);
                        };
                    } else {
                        this.createDataChannel();
                    }
                }

                this.enableDisableVideoEncoding = function (enable) {
                    var rtcp;
                    peer.getSenders().forEach(function (sender) {
                        if (!rtcp && sender.track.kind === 'video') {
                            rtcp = sender;
                        }
                    });

                    if (!rtcp || !rtcp.getParameters) return;

                    var parameters = rtcp.getParameters();
                    parameters.encodings[1] && (parameters.encodings[1].active = !!enable);
                    parameters.encodings[2] && (parameters.encodings[2].active = !!enable);
                    rtcp.setParameters(parameters);
                };

                if (config.remoteSdp) {
                    if (config.remoteSdp.remotePeerSdpConstraints) {
                        sdpConstraints = config.remoteSdp.remotePeerSdpConstraints;
                    }
                    defaults.sdpConstraints = setSdpConstraints(sdpConstraints);
                    this.addRemoteSdp(config.remoteSdp, function () {
                        createOfferOrAnswer('createAnswer');
                    });
                }

                function setChannelEvents(channel) {
                    // force ArrayBuffer in Firefox; which uses "Blob" by default.
                    channel.binaryType = 'arraybuffer';

                    channel.onmessage = function (event) {
                        config.onDataChannelMessage(event.data);
                    };

                    channel.onopen = function () {
                        config.onDataChannelOpened(channel);
                    };

                    channel.onerror = function (error) {
                        config.onDataChannelError(error);
                    };

                    channel.onclose = function (event) {
                        config.onDataChannelClosed(event);
                    };

                    channel.internalSend = channel.send;
                    channel.send = function (data) {
                        if (channel.readyState !== 'open') {
                            return;
                        }

                        channel.internalSend(data);
                    };

                    peer.channel = channel;
                }

                if (connection.session.audio == 'two-way' || connection.session.video == 'two-way' || connection.session.screen == 'two-way') {
                    defaults.sdpConstraints = setSdpConstraints({
                        OfferToReceiveAudio: connection.session.audio == 'two-way' || config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.OfferToReceiveAudio,
                        OfferToReceiveVideo: connection.session.video == 'two-way' || connection.session.screen == 'two-way' || config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.OfferToReceiveAudio
                    });
                }

                var streamsToShare = {};
                peer.getLocalStreams().forEach(function (stream) {
                    streamsToShare[stream.streamid] = {
                        isAudio: !!stream.isAudio,
                        isVideo: !!stream.isVideo,
                        isScreen: !!stream.isScreen
                    };
                });

                function oldCreateOfferOrAnswer(_method) {
                    peer[_method](function (localSdp) {
                        if (DetectRTC.browser.name !== 'Safari') {
                            localSdp.sdp = connection.processSdp(localSdp.sdp);
                        }
                        peer.setLocalDescription(localSdp, function () {
                            if (!connection.trickleIce) return;

                            config.onLocalSdp({
                                type: localSdp.type,
                                sdp: localSdp.sdp,
                                remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,
                                renegotiatingPeer: !!config.renegotiatingPeer || false,
                                connectionDescription: self.connectionDescription,
                                dontGetRemoteStream: !!config.dontGetRemoteStream,
                                extra: connection ? connection.extra : {},
                                streamsToShare: streamsToShare
                            });

                            connection.onSettingLocalDescription(self);
                        }, function (error) {
                            if (!!connection.enableLogs) {
                                console.error('setLocalDescription-error', error);
                            }
                        });
                    }, function (error) {
                        if (!!connection.enableLogs) {
                            console.error('sdp-' + _method + '-error', error);
                        }
                    }, defaults.sdpConstraints);
                }

                function createOfferOrAnswer(_method) {
                    peer[_method](defaults.sdpConstraints).then(function (localSdp) {
                        if (DetectRTC.browser.name !== 'Safari') {
                            localSdp.sdp = connection.processSdp(localSdp.sdp);
                        }
                        peer.setLocalDescription(localSdp).then(function () {
                            if (!connection.trickleIce) return;

                            config.onLocalSdp({
                                type: localSdp.type,
                                sdp: localSdp.sdp,
                                remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,
                                renegotiatingPeer: !!config.renegotiatingPeer || false,
                                connectionDescription: self.connectionDescription,
                                dontGetRemoteStream: !!config.dontGetRemoteStream,
                                extra: connection ? connection.extra : {},
                                streamsToShare: streamsToShare
                            });

                            connection.onSettingLocalDescription(self);
                        }, function (error) {
                            if (!connection.enableLogs) return;
                            console.error('setLocalDescription error', error);
                        });
                    }, function (error) {
                        if (!!connection.enableLogs) {
                            console.error('sdp-error', error);
                        }
                    });
                }

                if (isOfferer) {
                    createOfferOrAnswer('createOffer');
                }

                peer.nativeClose = peer.close;
                peer.close = function () {
                    if (!peer) {
                        return;
                    }

                    try {
                        if (peer.nativeClose !== peer.close) {
                            peer.nativeClose();
                        }
                    } catch (e) {}

                    peer = null;
                    self.peer = null;
                };

                this.peer = peer;
            }

            // CodecsHandler.js

            var CodecsHandler = function () {
                // use "RTCRtpTransceiver.setCodecPreferences"
                function preferCodec(sdp, codecName) {
                    var info = splitLines(sdp);

                    if (!info.videoCodecNumbers) {
                        return sdp;
                    }

                    if (codecName === 'vp8' && info.vp8LineNumber === info.videoCodecNumbers[0]) {
                        return sdp;
                    }

                    if (codecName === 'vp9' && info.vp9LineNumber === info.videoCodecNumbers[0]) {
                        return sdp;
                    }

                    if (codecName === 'h264' && info.h264LineNumber === info.videoCodecNumbers[0]) {
                        return sdp;
                    }

                    sdp = preferCodecHelper(sdp, codecName, info);

                    return sdp;
                }

                function preferCodecHelper(sdp, codec, info, ignore) {
                    var preferCodecNumber = '';

                    if (codec === 'vp8') {
                        if (!info.vp8LineNumber) {
                            return sdp;
                        }
                        preferCodecNumber = info.vp8LineNumber;
                    }

                    if (codec === 'vp9') {
                        if (!info.vp9LineNumber) {
                            return sdp;
                        }
                        preferCodecNumber = info.vp9LineNumber;
                    }

                    if (codec === 'h264') {
                        if (!info.h264LineNumber) {
                            return sdp;
                        }

                        preferCodecNumber = info.h264LineNumber;
                    }

                    var newLine = info.videoCodecNumbersOriginal.split('SAVPF')[0] + 'SAVPF ';

                    var newOrder = [preferCodecNumber];

                    if (ignore) {
                        newOrder = [];
                    }

                    info.videoCodecNumbers.forEach(function (codecNumber) {
                        if (codecNumber === preferCodecNumber) return;
                        newOrder.push(codecNumber);
                    });

                    newLine += newOrder.join(' ');

                    sdp = sdp.replace(info.videoCodecNumbersOriginal, newLine);
                    return sdp;
                }

                function splitLines(sdp) {
                    var info = {};
                    sdp.split('\n').forEach(function (line) {
                        if (line.indexOf('m=video') === 0) {
                            info.videoCodecNumbers = [];
                            line.split('SAVPF')[1].split(' ').forEach(function (codecNumber) {
                                codecNumber = codecNumber.trim();
                                if (!codecNumber || !codecNumber.length) return;
                                info.videoCodecNumbers.push(codecNumber);
                                info.videoCodecNumbersOriginal = line;
                            });
                        }

                        if (line.indexOf('VP8/90000') !== -1 && !info.vp8LineNumber) {
                            info.vp8LineNumber = line.replace('a=rtpmap:', '').split(' ')[0];
                        }

                        if (line.indexOf('VP9/90000') !== -1 && !info.vp9LineNumber) {
                            info.vp9LineNumber = line.replace('a=rtpmap:', '').split(' ')[0];
                        }

                        if (line.indexOf('H264/90000') !== -1 && !info.h264LineNumber) {
                            info.h264LineNumber = line.replace('a=rtpmap:', '').split(' ')[0];
                        }
                    });

                    return info;
                }

                function removeVPX(sdp) {
                    var info = splitLines(sdp);

                    // last parameter below means: ignore these codecs
                    sdp = preferCodecHelper(sdp, 'vp9', info, true);
                    sdp = preferCodecHelper(sdp, 'vp8', info, true);

                    return sdp;
                }

                function disableNACK(sdp) {
                    if (!sdp || typeof sdp !== 'string') {
                        throw 'Invalid arguments.';
                    }

                    sdp = sdp.replace('a=rtcp-fb:126 nack\r\n', '');
                    sdp = sdp.replace('a=rtcp-fb:126 nack pli\r\n', 'a=rtcp-fb:126 pli\r\n');
                    sdp = sdp.replace('a=rtcp-fb:97 nack\r\n', '');
                    sdp = sdp.replace('a=rtcp-fb:97 nack pli\r\n', 'a=rtcp-fb:97 pli\r\n');

                    return sdp;
                }

                function prioritize(codecMimeType, peer) {
                    if (!peer || !peer.getSenders || !peer.getSenders().length) {
                        return;
                    }

                    if (!codecMimeType || typeof codecMimeType !== 'string') {
                        throw 'Invalid arguments.';
                    }

                    peer.getSenders().forEach(function (sender) {
                        var params = sender.getParameters();
                        for (var i = 0; i < params.codecs.length; i++) {
                            if (params.codecs[i].mimeType == codecMimeType) {
                                params.codecs.unshift(params.codecs.splice(i, 1));
                                break;
                            }
                        }
                        sender.setParameters(params);
                    });
                }

                function removeNonG722(sdp) {
                    return sdp.replace(/m=audio ([0-9]+) RTP\/SAVPF ([0-9 ]*)/g, 'm=audio $1 RTP\/SAVPF 9');
                }

                function setBAS(sdp, bandwidth, isScreen) {
                    if (!bandwidth) {
                        return sdp;
                    }

                    if (typeof isFirefox !== 'undefined' && isFirefox) {
                        return sdp;
                    }

                    if (isScreen) {
                        if (!bandwidth.screen) {
                            console.warn('It seems that you are not using bandwidth for screen. Screen sharing is expected to fail.');
                        } else if (bandwidth.screen < 300) {
                            console.warn('It seems that you are using wrong bandwidth value for screen. Screen sharing is expected to fail.');
                        }
                    }

                    // if screen; must use at least 300kbs
                    if (bandwidth.screen && isScreen) {
                        sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
                        sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + bandwidth.screen + '\r\n');
                    }

                    // remove existing bandwidth lines
                    if (bandwidth.audio || bandwidth.video) {
                        sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
                    }

                    if (bandwidth.audio) {
                        sdp = sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + bandwidth.audio + '\r\n');
                    }

                    if (bandwidth.screen) {
                        sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + bandwidth.screen + '\r\n');
                    } else if (bandwidth.video) {
                        sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + bandwidth.video + '\r\n');
                    }

                    return sdp;
                }

                // Find the line in sdpLines that starts with |prefix|, and, if specified,
                // contains |substr| (case-insensitive search).
                function findLine(sdpLines, prefix, substr) {
                    return findLineInRange(sdpLines, 0, -1, prefix, substr);
                }

                // Find the line in sdpLines[startLine...endLine - 1] that starts with |prefix|
                // and, if specified, contains |substr| (case-insensitive search).
                function findLineInRange(sdpLines, startLine, endLine, prefix, substr) {
                    var realEndLine = endLine !== -1 ? endLine : sdpLines.length;
                    for (var i = startLine; i < realEndLine; ++i) {
                        if (sdpLines[i].indexOf(prefix) === 0) {
                            if (!substr || sdpLines[i].toLowerCase().indexOf(substr.toLowerCase()) !== -1) {
                                return i;
                            }
                        }
                    }
                    return null;
                }

                // Gets the codec payload type from an a=rtpmap:X line.
                function getCodecPayloadType(sdpLine) {
                    var pattern = new RegExp('a=rtpmap:(\\d+) \\w+\\/\\d+');
                    var result = sdpLine.match(pattern);
                    return result && result.length === 2 ? result[1] : null;
                }

                function setVideoBitrates(sdp, params) {
                    params = params || {};
                    var xgoogle_min_bitrate = params.min;
                    var xgoogle_max_bitrate = params.max;

                    var sdpLines = sdp.split('\r\n');

                    // VP8
                    var vp8Index = findLine(sdpLines, 'a=rtpmap', 'VP8/90000');
                    var vp8Payload;
                    if (vp8Index) {
                        vp8Payload = getCodecPayloadType(sdpLines[vp8Index]);
                    }

                    if (!vp8Payload) {
                        return sdp;
                    }

                    var rtxIndex = findLine(sdpLines, 'a=rtpmap', 'rtx/90000');
                    var rtxPayload;
                    if (rtxIndex) {
                        rtxPayload = getCodecPayloadType(sdpLines[rtxIndex]);
                    }

                    if (!rtxIndex) {
                        return sdp;
                    }

                    var rtxFmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + rtxPayload.toString());
                    if (rtxFmtpLineIndex !== null) {
                        var appendrtxNext = '\r\n';
                        appendrtxNext += 'a=fmtp:' + vp8Payload + ' x-google-min-bitrate=' + (xgoogle_min_bitrate || '228') + '; x-google-max-bitrate=' + (xgoogle_max_bitrate || '228');
                        sdpLines[rtxFmtpLineIndex] = sdpLines[rtxFmtpLineIndex].concat(appendrtxNext);
                        sdp = sdpLines.join('\r\n');
                    }

                    return sdp;
                }

                function setOpusAttributes(sdp, params) {
                    params = params || {};

                    var sdpLines = sdp.split('\r\n');

                    // Opus
                    var opusIndex = findLine(sdpLines, 'a=rtpmap', 'opus/48000');
                    var opusPayload;
                    if (opusIndex) {
                        opusPayload = getCodecPayloadType(sdpLines[opusIndex]);
                    }

                    if (!opusPayload) {
                        return sdp;
                    }

                    var opusFmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + opusPayload.toString());
                    if (opusFmtpLineIndex === null) {
                        return sdp;
                    }

                    var appendOpusNext = '';
                    appendOpusNext += '; stereo=' + (typeof params.stereo != 'undefined' ? params.stereo : '1');
                    appendOpusNext += '; sprop-stereo=' + (typeof params['sprop-stereo'] != 'undefined' ? params['sprop-stereo'] : '1');

                    if (typeof params.maxaveragebitrate != 'undefined') {
                        appendOpusNext += '; maxaveragebitrate=' + (params.maxaveragebitrate || 128 * 1024 * 8);
                    }

                    if (typeof params.maxplaybackrate != 'undefined') {
                        appendOpusNext += '; maxplaybackrate=' + (params.maxplaybackrate || 128 * 1024 * 8);
                    }

                    if (typeof params.cbr != 'undefined') {
                        appendOpusNext += '; cbr=' + (typeof params.cbr != 'undefined' ? params.cbr : '1');
                    }

                    if (typeof params.useinbandfec != 'undefined') {
                        appendOpusNext += '; useinbandfec=' + params.useinbandfec;
                    }

                    if (typeof params.usedtx != 'undefined') {
                        appendOpusNext += '; usedtx=' + params.usedtx;
                    }

                    if (typeof params.maxptime != 'undefined') {
                        appendOpusNext += '\r\na=maxptime:' + params.maxptime;
                    }

                    sdpLines[opusFmtpLineIndex] = sdpLines[opusFmtpLineIndex].concat(appendOpusNext);

                    sdp = sdpLines.join('\r\n');
                    return sdp;
                }

                // forceStereoAudio => via webrtcexample.com
                // requires getUserMedia => echoCancellation:false
                function forceStereoAudio(sdp) {
                    var sdpLines = sdp.split('\r\n');
                    var fmtpLineIndex = null;
                    for (var i = 0; i < sdpLines.length; i++) {
                        if (sdpLines[i].search('opus/48000') !== -1) {
                            var opusPayload = extractSdp(sdpLines[i], /:(\d+) opus\/48000/i);
                            break;
                        }
                    }
                    for (var i = 0; i < sdpLines.length; i++) {
                        if (sdpLines[i].search('a=fmtp') !== -1) {
                            var payload = extractSdp(sdpLines[i], /a=fmtp:(\d+)/);
                            if (payload === opusPayload) {
                                fmtpLineIndex = i;
                                break;
                            }
                        }
                    }
                    if (fmtpLineIndex === null) return sdp;
                    sdpLines[fmtpLineIndex] = sdpLines[fmtpLineIndex].concat('; stereo=1; sprop-stereo=1');
                    sdp = sdpLines.join('\r\n');
                    return sdp;
                }

                return {
                    removeVPX: removeVPX,
                    disableNACK: disableNACK,
                    prioritize: prioritize,
                    removeNonG722: removeNonG722,
                    setApplicationSpecificBandwidth: function (sdp, bandwidth, isScreen) {
                        return setBAS(sdp, bandwidth, isScreen);
                    },
                    setVideoBitrates: function (sdp, params) {
                        return setVideoBitrates(sdp, params);
                    },
                    setOpusAttributes: function (sdp, params) {
                        return setOpusAttributes(sdp, params);
                    },
                    preferVP9: function (sdp) {
                        return preferCodec(sdp, 'vp9');
                    },
                    preferCodec: preferCodec,
                    forceStereoAudio: forceStereoAudio
                };
            }();

            // backward compatibility
            window.BandwidthHandler = CodecsHandler;

            // OnIceCandidateHandler.js

            var OnIceCandidateHandler = function () {
                function processCandidates(connection, icePair) {
                    var candidate = icePair.candidate;

                    var iceRestrictions = connection.candidates;
                    var stun = iceRestrictions.stun;
                    var turn = iceRestrictions.turn;

                    if (!isNull(iceRestrictions.reflexive)) {
                        stun = iceRestrictions.reflexive;
                    }

                    if (!isNull(iceRestrictions.relay)) {
                        turn = iceRestrictions.relay;
                    }

                    if (!iceRestrictions.host && !!candidate.match(/typ host/g)) {
                        return;
                    }

                    if (!turn && !!candidate.match(/typ relay/g)) {
                        return;
                    }

                    if (!stun && !!candidate.match(/typ srflx/g)) {
                        return;
                    }

                    var protocol = connection.iceProtocols;

                    if (!protocol.udp && !!candidate.match(/ udp /g)) {
                        return;
                    }

                    if (!protocol.tcp && !!candidate.match(/ tcp /g)) {
                        return;
                    }

                    if (connection.enableLogs) {
                        console.debug('Your candidate pairs:', candidate);
                    }

                    return {
                        candidate: candidate,
                        sdpMid: icePair.sdpMid,
                        sdpMLineIndex: icePair.sdpMLineIndex
                    };
                }

                return {
                    processCandidates: processCandidates
                };
            }();

            // IceServersHandler.js

            var IceServersHandler = function () {
                function getIceServers(connection) {
                    // resiprocate: 3344+4433
                    // pions: 7575
                    var iceServers = [{
                        'urls': ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302', 'stun:stun.l.google.com:19302?transport=udp']
                    }];

                    return iceServers;
                }

                return {
                    getIceServers: getIceServers
                };
            }();

            // getUserMediaHandler.js

            function setStreamType(constraints, stream) {
                if (constraints.mandatory && constraints.mandatory.chromeMediaSource) {
                    stream.isScreen = true;
                } else if (constraints.mozMediaSource || constraints.mediaSource) {
                    stream.isScreen = true;
                } else if (constraints.video) {
                    stream.isVideo = true;
                } else if (constraints.audio) {
                    stream.isAudio = true;
                }
            }

            // allow users to manage this object (to support re-capturing of screen/etc.)
            window.currentUserMediaRequest = {
                streams: [],
                mutex: false,
                queueRequests: [],
                remove: function (idInstance) {
                    this.mutex = false;

                    var stream = this.streams[idInstance];
                    if (!stream) {
                        return;
                    }

                    stream = stream.stream;

                    var options = stream.currentUserMediaRequestOptions;

                    if (this.queueRequests.indexOf(options)) {
                        delete this.queueRequests[this.queueRequests.indexOf(options)];
                        this.queueRequests = removeNullEntries(this.queueRequests);
                    }

                    this.streams[idInstance].stream = null;
                    delete this.streams[idInstance];
                }
            };

            function getUserMediaHandler(options) {
                if (currentUserMediaRequest.mutex === true) {
                    currentUserMediaRequest.queueRequests.push(options);
                    return;
                }
                currentUserMediaRequest.mutex = true;

                // easy way to match
                var idInstance = JSON.stringify(options.localMediaConstraints);

                function streaming(stream, returnBack) {
                    setStreamType(options.localMediaConstraints, stream);

                    var streamEndedEvent = 'ended';

                    if ('oninactive' in stream) {
                        streamEndedEvent = 'inactive';
                    }
                    stream.addEventListener(streamEndedEvent, function () {
                        delete currentUserMediaRequest.streams[idInstance];

                        currentUserMediaRequest.mutex = false;
                        if (currentUserMediaRequest.queueRequests.indexOf(options)) {
                            delete currentUserMediaRequest.queueRequests[currentUserMediaRequest.queueRequests.indexOf(options)];
                            currentUserMediaRequest.queueRequests = removeNullEntries(currentUserMediaRequest.queueRequests);
                        }
                    }, false);

                    currentUserMediaRequest.streams[idInstance] = {
                        stream: stream
                    };
                    currentUserMediaRequest.mutex = false;

                    if (currentUserMediaRequest.queueRequests.length) {
                        getUserMediaHandler(currentUserMediaRequest.queueRequests.shift());
                    }

                    // callback
                    options.onGettingLocalMedia(stream, returnBack);
                }

                if (currentUserMediaRequest.streams[idInstance]) {
                    streaming(currentUserMediaRequest.streams[idInstance].stream, true);
                } else {
                    var isBlackBerry = !!/BB10|BlackBerry/i.test(navigator.userAgent || '');
                    if (isBlackBerry || typeof navigator.mediaDevices === 'undefined' || typeof navigator.mediaDevices.getUserMedia !== 'function') {
                        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                        navigator.getUserMedia(options.localMediaConstraints, function (stream) {
                            stream.streamid = stream.streamid || stream.id || getRandomString();
                            stream.idInstance = idInstance;
                            streaming(stream);
                        }, function (error) {
                            options.onLocalMediaError(error, options.localMediaConstraints);
                        });
                        return;
                    }

                    if (typeof navigator.mediaDevices === 'undefined') {
                        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                        var getUserMediaSuccess = function () {};
                        var getUserMediaFailure = function () {};

                        var getUserMediaStream, getUserMediaError;
                        navigator.mediaDevices = {
                            getUserMedia: function (hints) {
                                navigator.getUserMedia(hints, function (getUserMediaSuccess) {
                                    getUserMediaSuccess(stream);
                                    getUserMediaStream = stream;
                                }, function (error) {
                                    getUserMediaFailure(error);
                                    getUserMediaError = error;
                                });

                                return {
                                    then: function (successCB) {
                                        if (getUserMediaStream) {
                                            successCB(getUserMediaStream);
                                            return;
                                        }

                                        getUserMediaSuccess = successCB;

                                        return {
                                            then: function (failureCB) {
                                                if (getUserMediaError) {
                                                    failureCB(getUserMediaError);
                                                    return;
                                                }

                                                getUserMediaFailure = failureCB;
                                            }
                                        };
                                    }
                                };
                            }
                        };
                    }

                    if (options.localMediaConstraints.isScreen === true) {
                        if (navigator.mediaDevices.getDisplayMedia) {
                            navigator.mediaDevices.getDisplayMedia(options.localMediaConstraints).then(function (stream) {
                                stream.streamid = stream.streamid || stream.id || getRandomString();
                                stream.idInstance = idInstance;

                                streaming(stream);
                            }).catch(function (error) {
                                options.onLocalMediaError(error, options.localMediaConstraints);
                            });
                        } else if (navigator.getDisplayMedia) {
                            navigator.getDisplayMedia(options.localMediaConstraints).then(function (stream) {
                                stream.streamid = stream.streamid || stream.id || getRandomString();
                                stream.idInstance = idInstance;

                                streaming(stream);
                            }).catch(function (error) {
                                options.onLocalMediaError(error, options.localMediaConstraints);
                            });
                        } else {
                            throw new Error('getDisplayMedia API is not availabe in this browser.');
                        }
                        return;
                    }

                    navigator.mediaDevices.getUserMedia(options.localMediaConstraints).then(function (stream) {
                        stream.streamid = stream.streamid || stream.id || getRandomString();
                        stream.idInstance = idInstance;

                        streaming(stream);
                    }).catch(function (error) {
                        options.onLocalMediaError(error, options.localMediaConstraints);
                    });
                }
            }

            // StreamsHandler.js

            var StreamsHandler = function () {
                function handleType(type) {
                    if (!type) {
                        return;
                    }

                    if (typeof type === 'string' || typeof type === 'undefined') {
                        return type;
                    }

                    if (type.audio && type.video) {
                        return null;
                    }

                    if (type.audio) {
                        return 'audio';
                    }

                    if (type.video) {
                        return 'video';
                    }

                    return;
                }

                function setHandlers(stream, syncAction, connection) {
                    if (!stream || !stream.addEventListener) return;

                    if (typeof syncAction == 'undefined' || syncAction == true) {
                        var streamEndedEvent = 'ended';

                        if ('oninactive' in stream) {
                            streamEndedEvent = 'inactive';
                        }

                        stream.addEventListener(streamEndedEvent, function () {
                            StreamsHandler.onSyncNeeded(this.streamid, streamEndedEvent);
                        }, false);
                    }

                    stream.mute = function (type, isSyncAction) {
                        type = handleType(type);

                        if (typeof isSyncAction !== 'undefined') {
                            syncAction = isSyncAction;
                        }

                        if (typeof type == 'undefined' || type == 'audio') {
                            getTracks(stream, 'audio').forEach(function (track) {
                                track.enabled = false;
                                connection.streamEvents[stream.streamid].isAudioMuted = true;
                            });
                        }

                        if (typeof type == 'undefined' || type == 'video') {
                            getTracks(stream, 'video').forEach(function (track) {
                                track.enabled = false;
                            });
                        }

                        if (typeof syncAction == 'undefined' || syncAction == true) {
                            StreamsHandler.onSyncNeeded(stream.streamid, 'mute', type);
                        }

                        connection.streamEvents[stream.streamid].muteType = type || 'both';

                        fireEvent(stream, 'mute', type);
                    };

                    stream.unmute = function (type, isSyncAction) {
                        type = handleType(type);

                        if (typeof isSyncAction !== 'undefined') {
                            syncAction = isSyncAction;
                        }

                        graduallyIncreaseVolume();

                        if (typeof type == 'undefined' || type == 'audio') {
                            getTracks(stream, 'audio').forEach(function (track) {
                                track.enabled = true;
                                connection.streamEvents[stream.streamid].isAudioMuted = false;
                            });
                        }

                        if (typeof type == 'undefined' || type == 'video') {
                            getTracks(stream, 'video').forEach(function (track) {
                                track.enabled = true;
                            });

                            // make sure that video unmute doesn't affects audio
                            if (typeof type !== 'undefined' && type == 'video' && connection.streamEvents[stream.streamid].isAudioMuted) {
                                (function looper(times) {
                                    if (!times) {
                                        times = 0;
                                    }

                                    times++;

                                    // check until five-seconds
                                    if (times < 100 && connection.streamEvents[stream.streamid].isAudioMuted) {
                                        stream.mute('audio');

                                        setTimeout(function () {
                                            looper(times);
                                        }, 50);
                                    }
                                })();
                            }
                        }

                        if (typeof syncAction == 'undefined' || syncAction == true) {
                            StreamsHandler.onSyncNeeded(stream.streamid, 'unmute', type);
                        }

                        connection.streamEvents[stream.streamid].unmuteType = type || 'both';

                        fireEvent(stream, 'unmute', type);
                    };

                    function graduallyIncreaseVolume() {
                        if (!connection.streamEvents[stream.streamid].mediaElement) {
                            return;
                        }

                        var mediaElement = connection.streamEvents[stream.streamid].mediaElement;
                        mediaElement.volume = 0;
                        afterEach(200, 5, function () {
                            try {
                                mediaElement.volume += .20;
                            } catch (e) {
                                mediaElement.volume = 1;
                            }
                        });
                    }
                }

                function afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes) {
                    startedTimes = (startedTimes || 0) + 1;
                    if (startedTimes >= numberOfTimes) return;

                    setTimeout(function () {
                        callback();
                        afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes);
                    }, setTimeoutInteval);
                }

                return {
                    setHandlers: setHandlers,
                    onSyncNeeded: function (streamid, action, type) {}
                };
            }();

            // TextReceiver.js & TextSender.js

            function TextReceiver(connection) {
                var content = {};

                function receive(data, userid, extra) {
                    // uuid is used to uniquely identify sending instance
                    var uuid = data.uuid;
                    if (!content[uuid]) {
                        content[uuid] = [];
                    }

                    content[uuid].push(data.message);

                    if (data.last) {
                        var message = content[uuid].join('');
                        if (data.isobject) {
                            message = JSON.parse(message);
                        }

                        // latency detection
                        var receivingTime = new Date().getTime();
                        var latency = receivingTime - data.sendingTime;

                        var e = {
                            data: message,
                            userid: userid,
                            extra: extra,
                            latency: latency
                        };

                        if (connection.autoTranslateText) {
                            e.original = e.data;
                            connection.Translator.TranslateText(e.data, function (translatedText) {
                                e.data = translatedText;
                                connection.onmessage(e);
                            });
                        } else {
                            connection.onmessage(e);
                        }

                        delete content[uuid];
                    }
                }

                return {
                    receive: receive
                };
            }

            // TextSender.js
            var TextSender = {
                send: function (config) {
                    var connection = config.connection;

                    var channel = config.channel,
                        remoteUserId = config.remoteUserId,
                        initialText = config.text,
                        packetSize = connection.chunkSize || 1000,
                        textToTransfer = '',
                        isobject = false;

                    if (!isString(initialText)) {
                        isobject = true;
                        initialText = JSON.stringify(initialText);
                    }

                    // uuid is used to uniquely identify sending instance
                    var uuid = getRandomString();
                    var sendingTime = new Date().getTime();

                    sendText(initialText);

                    function sendText(textMessage, text) {
                        var data = {
                            type: 'text',
                            uuid: uuid,
                            sendingTime: sendingTime
                        };

                        if (textMessage) {
                            text = textMessage;
                            data.packets = parseInt(text.length / packetSize);
                        }

                        if (text.length > packetSize) {
                            data.message = text.slice(0, packetSize);
                        } else {
                            data.message = text;
                            data.last = true;
                            data.isobject = isobject;
                        }

                        channel.send(data, remoteUserId);

                        textToTransfer = text.slice(data.message.length);

                        if (textToTransfer.length) {
                            setTimeout(function () {
                                sendText(null, textToTransfer);
                            }, connection.chunkInterval || 100);
                        }
                    }
                }
            };

            // FileProgressBarHandler.js

            var FileProgressBarHandler = function () {
                function handle(connection) {
                    var progressHelper = {};

                    // www.RTCMultiConnection.org/docs/onFileStart/
                    connection.onFileStart = function (file) {
                        var div = document.createElement('div');
                        div.title = file.name;
                        div.innerHTML = '<label>0%</label> <progress></progress>';

                        if (file.remoteUserId) {
                            div.innerHTML += ' (Sharing with:' + file.remoteUserId + ')';
                        }

                        if (!connection.filesContainer) {
                            connection.filesContainer = document.body || document.documentElement;
                        }

                        connection.filesContainer.insertBefore(div, connection.filesContainer.firstChild);

                        if (!file.remoteUserId) {
                            progressHelper[file.uuid] = {
                                div: div,
                                progress: div.querySelector('progress'),
                                label: div.querySelector('label')
                            };
                            progressHelper[file.uuid].progress.max = file.maxChunks;
                            return;
                        }

                        if (!progressHelper[file.uuid]) {
                            progressHelper[file.uuid] = {};
                        }

                        progressHelper[file.uuid][file.remoteUserId] = {
                            div: div,
                            progress: div.querySelector('progress'),
                            label: div.querySelector('label')
                        };
                        progressHelper[file.uuid][file.remoteUserId].progress.max = file.maxChunks;
                    };

                    // www.RTCMultiConnection.org/docs/onFileProgress/
                    connection.onFileProgress = function (chunk) {
                        var helper = progressHelper[chunk.uuid];
                        if (!helper) {
                            return;
                        }
                        if (chunk.remoteUserId) {
                            helper = progressHelper[chunk.uuid][chunk.remoteUserId];
                            if (!helper) {
                                return;
                            }
                        }

                        helper.progress.value = chunk.currentPosition || chunk.maxChunks || helper.progress.max;
                        updateLabel(helper.progress, helper.label);
                    };

                    // www.RTCMultiConnection.org/docs/onFileEnd/
                    connection.onFileEnd = function (file) {
                        var helper = progressHelper[file.uuid];
                        if (!helper) {
                            console.error('No such progress-helper element exist.', file);
                            return;
                        }

                        if (file.remoteUserId) {
                            helper = progressHelper[file.uuid][file.remoteUserId];
                            if (!helper) {
                                return;
                            }
                        }

                        var div = helper.div;
                        if (file.type.indexOf('image') != -1) {
                            div.innerHTML = '<a href="' + file.url + '" download="' + file.name + '">Download <strong style="color:red;">' + file.name + '</strong> </a><br /><img src="' + file.url + '" title="' + file.name + '" style="max-width: 80%;">';
                        } else {
                            div.innerHTML = '<a href="' + file.url + '" download="' + file.name + '">Download <strong style="color:red;">' + file.name + '</strong> </a><br /><iframe src="' + file.url + '" title="' + file.name + '" style="width: 80%;border: 0;height: inherit;margin-top:1em;"></iframe>';
                        }
                    };

                    function updateLabel(progress, label) {
                        if (progress.position === -1) {
                            return;
                        }

                        var position = +progress.position.toFixed(2).split('.')[1] || 100;
                        label.innerHTML = position + '%';
                    }
                }

                return {
                    handle: handle
                };
            }();

            // TranslationHandler.js

            var TranslationHandler = function () {
                function handle(connection) {
                    connection.autoTranslateText = false;
                    connection.language = 'en';
                    connection.googKey = 'AIzaSyCgB5hmFY74WYB-EoWkhr9cAGr6TiTHrEE';

                    // www.RTCMultiConnection.org/docs/Translator/
                    connection.Translator = {
                        TranslateText: function (text, callback) {
                            // if(location.protocol === 'https:') return callback(text);

                            var newScript = document.createElement('script');
                            newScript.type = 'text/javascript';

                            var sourceText = encodeURIComponent(text); // escape

                            var randomNumber = 'method' + connection.token();
                            window[randomNumber] = function (response) {
                                if (response.data && response.data.translations[0] && callback) {
                                    callback(response.data.translations[0].translatedText);
                                    return;
                                }

                                if (response.error && response.error.message === 'Daily Limit Exceeded') {
                                    console.error('Text translation failed. Error message: "Daily Limit Exceeded."');
                                    return;
                                }

                                if (response.error) {
                                    console.error(response.error.message);
                                    return;
                                }

                                console.error(response);
                            };

                            var source = 'https://www.googleapis.com/language/translate/v2?key=' + connection.googKey + '&target=' + (connection.language || 'en-US') + '&callback=window.' + randomNumber + '&q=' + sourceText;
                            newScript.src = source;
                            document.getElementsByTagName('head')[0].appendChild(newScript);
                        },
                        getListOfLanguages: function (callback) {
                            var xhr = new XMLHttpRequest();
                            xhr.onreadystatechange = function () {
                                if (xhr.readyState == XMLHttpRequest.DONE) {
                                    var response = JSON.parse(xhr.responseText);

                                    if (response && response.data && response.data.languages) {
                                        callback(response.data.languages);
                                        return;
                                    }

                                    if (response.error && response.error.message === 'Daily Limit Exceeded') {
                                        console.error('Text translation failed. Error message: "Daily Limit Exceeded."');
                                        return;
                                    }

                                    if (response.error) {
                                        console.error(response.error.message);
                                        return;
                                    }

                                    console.error(response);
                                }
                            };
                            var url = 'https://www.googleapis.com/language/translate/v2/languages?key=' + connection.googKey + '&target=en';
                            xhr.open('GET', url, true);
                            xhr.send(null);
                        }
                    };
                }

                return {
                    handle: handle
                };
            }();

            // _____________________
            // RTCMultiConnection.js

            (function (connection) {
                forceOptions = forceOptions || {
                    useDefaultDevices: true
                };

                connection.channel = connection.sessionid = (roomid || location.href.replace(/\/|:|#|\?|\$|\^|%|\.|`|~|!|\+|@|\[|\||]|\|*. /g, '').split('\n').join('').split('\r').join('')) + '';

                var mPeer = new MultiPeers(connection);

                var preventDuplicateOnStreamEvents = {};
                mPeer.onGettingLocalMedia = function (stream, callback) {
                    callback = callback || function () {};

                    if (preventDuplicateOnStreamEvents[stream.streamid]) {
                        callback();
                        return;
                    }
                    preventDuplicateOnStreamEvents[stream.streamid] = true;

                    try {
                        stream.type = 'local';
                    } catch (e) {}

                    connection.setStreamEndHandler(stream);

                    getRMCMediaElement(stream, function (mediaElement) {
                        mediaElement.id = stream.streamid;
                        mediaElement.muted = true;
                        mediaElement.volume = 0;

                        if (connection.attachStreams.indexOf(stream) === -1) {
                            connection.attachStreams.push(stream);
                        }

                        if (typeof StreamsHandler !== 'undefined') {
                            StreamsHandler.setHandlers(stream, true, connection);
                        }
                        var isAudioMuted = stream.getAudioTracks().filter(function (track) {
                            return track.enabled;
                        }).length === 0;

                        connection.streamEvents[stream.streamid] = {
                            stream: stream,
                            type: 'local',
                            mediaElement: mediaElement,
                            userid: connection.userid,
                            extra: connection.extra,
                            streamid: stream.streamid,
                            isAudioMuted: isAudioMuted
                        };

                        try {
                            setHarkEvents(connection, connection.streamEvents[stream.streamid]);
                            setMuteHandlers(connection, connection.streamEvents[stream.streamid]);

                            connection.onstream(connection.streamEvents[stream.streamid]);
                        } catch (e) {
                            //
                        }

                        callback();
                    }, connection);
                };

                mPeer.onGettingRemoteMedia = function (stream, remoteUserId) {
                    try {
                        stream.type = 'remote';
                    } catch (e) {}

                    connection.setStreamEndHandler(stream, 'remote-stream');

                    getRMCMediaElement(stream, function (mediaElement) {
                        mediaElement.id = stream.streamid;

                        if (typeof StreamsHandler !== 'undefined') {
                            StreamsHandler.setHandlers(stream, false, connection);
                        }

                        connection.streamEvents[stream.streamid] = {
                            stream: stream,
                            type: 'remote',
                            userid: remoteUserId,
                            extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                            mediaElement: mediaElement,
                            streamid: stream.streamid
                        };

                        setMuteHandlers(connection, connection.streamEvents[stream.streamid]);

                        connection.onstream(connection.streamEvents[stream.streamid]);
                    }, connection);
                };

                mPeer.onRemovingRemoteMedia = function (stream, remoteUserId) {
                    var streamEvent = connection.streamEvents[stream.streamid];
                    if (!streamEvent) {
                        streamEvent = {
                            stream: stream,
                            type: 'remote',
                            userid: remoteUserId,
                            extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                            streamid: stream.streamid,
                            mediaElement: connection.streamEvents[stream.streamid] ? connection.streamEvents[stream.streamid].mediaElement : null
                        };
                    }

                    if (connection.peersBackup[streamEvent.userid]) {
                        streamEvent.extra = connection.peersBackup[streamEvent.userid].extra;
                    }

                    connection.onstreamended(streamEvent);

                    delete connection.streamEvents[stream.streamid];
                };

                mPeer.onNegotiationNeeded = function (message, remoteUserId, callback) {
                    callback = callback || function () {};

                    remoteUserId = remoteUserId || message.remoteUserId;
                    message = message || '';

                    // usually a message looks like this
                    var messageToDeliver = {
                        remoteUserId: remoteUserId,
                        message: message,
                        sender: connection.userid
                    };

                    if (message.remoteUserId && message.message && message.sender) {
                        // if a code is manually passing required data
                        messageToDeliver = message;
                    }

                    connectSocket(function () {
                        connection.socket.emit(connection.socketMessageEvent, messageToDeliver, callback);
                    });
                };

                function onUserLeft(remoteUserId) {
                    connection.deletePeer(remoteUserId);
                }

                mPeer.onUserLeft = onUserLeft;
                mPeer.disconnectWith = function (remoteUserId, callback) {
                    if (connection.socket) {
                        connection.socket.emit('disconnect-with', remoteUserId, callback || function () {});
                    }

                    connection.deletePeer(remoteUserId);
                };

                connection.socketOptions = {
                    // 'force new connection': true, // For SocketIO version < 1.0
                    // 'forceNew': true, // For SocketIO version >= 1.0
                    'transport': 'polling' // fixing transport:unknown issues
                };

                function connectSocket(connectCallback) {
                    connection.socketAutoReConnect = true;

                    if (connection.socket) {
                        // todo: check here readySate/etc. to make sure socket is still opened
                        if (connectCallback) {
                            connectCallback(connection.socket);
                        }
                        return;
                    }

                    if (typeof SocketConnection === 'undefined') {
                        if (typeof FirebaseConnection !== 'undefined') {
                            window.SocketConnection = FirebaseConnection;
                        } else if (typeof PubNubConnection !== 'undefined') {
                            window.SocketConnection = PubNubConnection;
                        } else {
                            throw 'SocketConnection.js seems missed.';
                        }
                    }

                    new SocketConnection(connection, function (s) {
                        if (connectCallback) {
                            connectCallback(connection.socket);
                        }
                    });
                }

                // 1st paramter is roomid
                // 2rd paramter is a callback function
                connection.openOrJoin = function (roomid, callback) {
                    callback = callback || function () {};

                    connection.checkPresence(roomid, function (isRoomExist, roomid) {
                        if (isRoomExist) {
                            connection.sessionid = roomid;

                            var localPeerSdpConstraints = false;
                            var remotePeerSdpConstraints = false;
                            var isOneWay = !!connection.session.oneway;
                            var isDataOnly = isData(connection.session);

                            remotePeerSdpConstraints = {
                                OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            };

                            localPeerSdpConstraints = {
                                OfferToReceiveAudio: isOneWay ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: isOneWay ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            };

                            var connectionDescription = {
                                remoteUserId: connection.sessionid,
                                message: {
                                    newParticipationRequest: true,
                                    isOneWay: isOneWay,
                                    isDataOnly: isDataOnly,
                                    localPeerSdpConstraints: localPeerSdpConstraints,
                                    remotePeerSdpConstraints: remotePeerSdpConstraints
                                },
                                sender: connection.userid
                            };

                            beforeJoin(connectionDescription.message, function () {
                                joinRoom(connectionDescription, callback);
                            });
                            return;
                        }

                        connection.waitingForLocalMedia = true;
                        connection.isInitiator = true;

                        connection.sessionid = roomid || connection.sessionid;

                        if (isData(connection.session)) {
                            openRoom(callback);
                            return;
                        }

                        connection.captureUserMedia(function () {
                            openRoom(callback);
                        });
                    });
                };

                // don't allow someone to join this person until he has the media
                connection.waitingForLocalMedia = false;

                connection.open = function (roomid, callback) {
                    callback = callback || function () {};

                    connection.waitingForLocalMedia = true;
                    connection.isInitiator = true;

                    connection.sessionid = roomid || connection.sessionid;

                    connectSocket(function () {
                        if (isData(connection.session)) {
                            openRoom(callback);
                            return;
                        }

                        connection.captureUserMedia(function () {
                            openRoom(callback);
                        });
                    });
                };

                // this object keeps extra-data records for all connected users
                // this object is never cleared so you can always access extra-data even if a user left
                connection.peersBackup = {};

                connection.deletePeer = function (remoteUserId) {
                    if (!remoteUserId || !connection.peers[remoteUserId]) {
                        return;
                    }

                    var eventObject = {
                        userid: remoteUserId,
                        extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {}
                    };

                    if (connection.peersBackup[eventObject.userid]) {
                        eventObject.extra = connection.peersBackup[eventObject.userid].extra;
                    }

                    connection.onleave(eventObject);

                    if (!!connection.peers[remoteUserId]) {
                        connection.peers[remoteUserId].streams.forEach(function (stream) {
                            stream.stop();
                        });

                        var peer = connection.peers[remoteUserId].peer;
                        if (peer && peer.iceConnectionState !== 'closed') {
                            try {
                                peer.close();
                            } catch (e) {}
                        }

                        if (connection.peers[remoteUserId]) {
                            connection.peers[remoteUserId].peer = null;
                            delete connection.peers[remoteUserId];
                        }
                    }
                };

                connection.rejoin = function (connectionDescription) {
                    if (connection.isInitiator || !connectionDescription || !Object.keys(connectionDescription).length) {
                        return;
                    }

                    var extra = {};

                    if (connection.peers[connectionDescription.remoteUserId]) {
                        extra = connection.peers[connectionDescription.remoteUserId].extra;
                        connection.deletePeer(connectionDescription.remoteUserId);
                    }

                    if (connectionDescription && connectionDescription.remoteUserId) {
                        connection.join(connectionDescription.remoteUserId);

                        connection.onReConnecting({
                            userid: connectionDescription.remoteUserId,
                            extra: extra
                        });
                    }
                };

                connection.join = function (remoteUserId, options) {
                    connection.sessionid = (remoteUserId ? remoteUserId.sessionid || remoteUserId.remoteUserId || remoteUserId : false) || connection.sessionid;
                    connection.sessionid += '';

                    var localPeerSdpConstraints = false;
                    var remotePeerSdpConstraints = false;
                    var isOneWay = false;
                    var isDataOnly = false;

                    if (remoteUserId && remoteUserId.session || !remoteUserId || typeof remoteUserId === 'string') {
                        var session = remoteUserId ? remoteUserId.session || connection.session : connection.session;

                        isOneWay = !!session.oneway;
                        isDataOnly = isData(session);

                        remotePeerSdpConstraints = {
                            OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                            OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                        };

                        localPeerSdpConstraints = {
                            OfferToReceiveAudio: isOneWay ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                            OfferToReceiveVideo: isOneWay ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                        };
                    }

                    options = options || {};

                    var cb = function () {};
                    if (typeof options === 'function') {
                        cb = options;
                        options = {};
                    }

                    if (typeof options.localPeerSdpConstraints !== 'undefined') {
                        localPeerSdpConstraints = options.localPeerSdpConstraints;
                    }

                    if (typeof options.remotePeerSdpConstraints !== 'undefined') {
                        remotePeerSdpConstraints = options.remotePeerSdpConstraints;
                    }

                    if (typeof options.isOneWay !== 'undefined') {
                        isOneWay = options.isOneWay;
                    }

                    if (typeof options.isDataOnly !== 'undefined') {
                        isDataOnly = options.isDataOnly;
                    }

                    var connectionDescription = {
                        remoteUserId: connection.sessionid,
                        message: {
                            newParticipationRequest: true,
                            isOneWay: isOneWay,
                            isDataOnly: isDataOnly,
                            localPeerSdpConstraints: localPeerSdpConstraints,
                            remotePeerSdpConstraints: remotePeerSdpConstraints
                        },
                        sender: connection.userid
                    };

                    beforeJoin(connectionDescription.message, function () {
                        connectSocket(function () {
                            joinRoom(connectionDescription, cb);
                        });
                    });
                    return connectionDescription;
                };

                function joinRoom(connectionDescription, cb) {
                    connection.socket.emit('join-room', {
                        sessionid: connection.sessionid,
                        session: connection.session,
                        mediaConstraints: connection.mediaConstraints,
                        sdpConstraints: connection.sdpConstraints,
                        streams: getStreamInfoForAdmin(),
                        extra: connection.extra,
                        password: typeof connection.password !== 'undefined' && typeof connection.password !== 'object' ? connection.password : ''
                    }, function (isRoomJoined, error) {
                        if (isRoomJoined === true) {
                            if (connection.enableLogs) {
                                console.log('isRoomJoined: ', isRoomJoined, ' roomid: ', connection.sessionid);
                            }

                            if (!!connection.peers[connection.sessionid]) {
                                // on socket disconnect & reconnect
                                return;
                            }

                            mPeer.onNegotiationNeeded(connectionDescription);
                        }

                        if (isRoomJoined === false) {
                            if (connection.enableLogs) {
                                console.warn('isRoomJoined: ', error, ' roomid: ', connection.sessionid);
                            }

                            // [disabled] retry after 3 seconds
                            // sst: enabled
                            setTimeout(function () {
                                joinRoom(connectionDescription, cb);
                            }, 3000);
                        }

                        cb(isRoomJoined, connection.sessionid, error);
                    });
                }

                connection.publicRoomIdentifier = '';

                function openRoom(callback) {
                    if (connection.enableLogs) {
                        console.log('Sending open-room signal to socket.io');
                    }

                    connection.waitingForLocalMedia = false;
                    connection.socket.emit('open-room', {
                        sessionid: connection.sessionid,
                        session: connection.session,
                        mediaConstraints: connection.mediaConstraints,
                        sdpConstraints: connection.sdpConstraints,
                        streams: getStreamInfoForAdmin(),
                        extra: connection.extra,
                        identifier: connection.publicRoomIdentifier,
                        password: typeof connection.password !== 'undefined' && typeof connection.password !== 'object' ? connection.password : ''
                    }, function (isRoomOpened, error) {
                        if (isRoomOpened === true) {
                            if (connection.enableLogs) {
                                console.log('isRoomOpened: ', isRoomOpened, ' roomid: ', connection.sessionid);
                            }
                            callback(isRoomOpened, connection.sessionid);
                        }

                        if (isRoomOpened === false) {
                            if (connection.enableLogs) {
                                console.warn('isRoomOpened: ', error, ' roomid: ', connection.sessionid);
                            }

                            callback(isRoomOpened, connection.sessionid, error);
                        }
                    });
                }

                function getStreamInfoForAdmin() {
                    try {
                        return connection.streamEvents.selectAll('local').map(function (event) {
                            return {
                                streamid: event.streamid,
                                tracks: event.stream.getTracks().length
                            };
                        });
                    } catch (e) {
                        return [];
                    }
                }

                function beforeJoin(userPreferences, callback) {
                    if (connection.dontCaptureUserMedia || userPreferences.isDataOnly) {
                        callback();
                        return;
                    }

                    var localMediaConstraints = {};

                    if (userPreferences.localPeerSdpConstraints.OfferToReceiveAudio) {
                        localMediaConstraints.audio = connection.mediaConstraints.audio;
                    }

                    if (userPreferences.localPeerSdpConstraints.OfferToReceiveVideo) {
                        localMediaConstraints.video = connection.mediaConstraints.video;
                    }

                    var session = userPreferences.session || connection.session;

                    if (session.oneway && session.audio !== 'two-way' && session.video !== 'two-way' && session.screen !== 'two-way') {
                        callback();
                        return;
                    }

                    if (session.oneway && session.audio && session.audio === 'two-way') {
                        session = {
                            audio: true
                        };
                    }

                    if (session.audio || session.video || session.screen) {
                        if (session.screen) {
                            if (DetectRTC.browser.name === 'Edge') {
                                navigator.getDisplayMedia({
                                    video: true,
                                    audio: isAudioPlusTab(connection)
                                }).then(function (screen) {
                                    screen.isScreen = true;
                                    mPeer.onGettingLocalMedia(screen);

                                    if ((session.audio || session.video) && !isAudioPlusTab(connection)) {
                                        connection.invokeGetUserMedia(null, callback);
                                    } else {
                                        callback(screen);
                                    }
                                }, function (error) {
                                    console.error('Unable to capture screen on Edge. HTTPs and version 17+ is required.');
                                });
                            } else {
                                connection.invokeGetUserMedia({
                                    audio: isAudioPlusTab(connection),
                                    video: true,
                                    isScreen: true
                                }, (session.audio || session.video) && !isAudioPlusTab(connection) ? connection.invokeGetUserMedia(null, callback) : callback);
                            }
                        } else if (session.audio || session.video) {
                            connection.invokeGetUserMedia(null, callback, session);
                        }
                    }
                }

                connection.getUserMedia = connection.captureUserMedia = function (callback, sessionForced) {
                    callback = callback || function () {};
                    var session = sessionForced || connection.session;

                    if (connection.dontCaptureUserMedia || isData(session)) {
                        callback();
                        return;
                    }

                    if (session.audio || session.video || session.screen) {
                        if (session.screen) {
                            if (DetectRTC.browser.name === 'Edge') {
                                navigator.getDisplayMedia({
                                    video: true,
                                    audio: isAudioPlusTab(connection)
                                }).then(function (screen) {
                                    screen.isScreen = true;
                                    mPeer.onGettingLocalMedia(screen);

                                    if ((session.audio || session.video) && !isAudioPlusTab(connection)) {
                                        var nonScreenSession = {};
                                        for (var s in session) {
                                            if (s !== 'screen') {
                                                nonScreenSession[s] = session[s];
                                            }
                                        }
                                        connection.invokeGetUserMedia(sessionForced, callback, nonScreenSession);
                                        return;
                                    }
                                    callback(screen);
                                }, function (error) {
                                    console.error('Unable to capture screen on Edge. HTTPs and version 17+ is required.');
                                });
                            } else {
                                connection.invokeGetUserMedia({
                                    audio: isAudioPlusTab(connection),
                                    video: true,
                                    isScreen: true
                                }, function (stream) {
                                    if ((session.audio || session.video) && !isAudioPlusTab(connection)) {
                                        var nonScreenSession = {};
                                        for (var s in session) {
                                            if (s !== 'screen') {
                                                nonScreenSession[s] = session[s];
                                            }
                                        }
                                        connection.invokeGetUserMedia(sessionForced, callback, nonScreenSession);
                                        return;
                                    }
                                    callback(stream);
                                });
                            }
                        } else if (session.audio || session.video) {
                            connection.invokeGetUserMedia(sessionForced, callback, session);
                        }
                    }
                };

                connection.onbeforeunload = function (arg1, dontCloseSocket) {
                    if (!connection.closeBeforeUnload) {
                        return;
                    }

                    connection.peers.getAllParticipants().forEach(function (participant) {
                        mPeer.onNegotiationNeeded({
                            userLeft: true
                        }, participant);

                        if (connection.peers[participant] && connection.peers[participant].peer) {
                            connection.peers[participant].peer.close();
                        }

                        delete connection.peers[participant];
                    });

                    if (!dontCloseSocket) {
                        connection.closeSocket();
                    }

                    connection.isInitiator = false;
                };

                if (!window.ignoreBeforeUnload) {
                    // user can implement its own version of window.onbeforeunload
                    connection.closeBeforeUnload = true;
                    window.addEventListener('beforeunload', connection.onbeforeunload, false);
                } else {
                    connection.closeBeforeUnload = false;
                }

                connection.userid = getRandomString();
                connection.changeUserId = function (newUserId, callback) {
                    callback = callback || function () {};
                    connection.userid = newUserId || getRandomString();
                    connection.socket.emit('changed-uuid', connection.userid, callback);
                };

                connection.extra = {};
                connection.attachStreams = [];

                connection.session = {
                    audio: true,
                    video: true
                };

                connection.enableFileSharing = false;

                // all values in kbps
                connection.bandwidth = {
                    screen: false,
                    audio: false,
                    video: false
                };

                connection.codecs = {
                    audio: 'opus',
                    video: 'VP9'
                };

                connection.processSdp = function (sdp) {
                    // ignore SDP modification if unified-pan is supported
                    if (isUnifiedPlanSupportedDefault()) {
                        return sdp;
                    }

                    if (DetectRTC.browser.name === 'Safari') {
                        return sdp;
                    }

                    if (connection.codecs.video.toUpperCase() === 'VP8') {
                        sdp = CodecsHandler.preferCodec(sdp, 'vp8');
                    }

                    if (connection.codecs.video.toUpperCase() === 'VP9') {
                        sdp = CodecsHandler.preferCodec(sdp, 'vp9');
                    }

                    if (connection.codecs.video.toUpperCase() === 'H264') {
                        sdp = CodecsHandler.preferCodec(sdp, 'h264');
                    }

                    if (connection.codecs.audio === 'G722') {
                        sdp = CodecsHandler.removeNonG722(sdp);
                    }

                    if (DetectRTC.browser.name === 'Firefox') {
                        return sdp;
                    }

                    if (connection.bandwidth.video || connection.bandwidth.screen) {
                        sdp = CodecsHandler.setApplicationSpecificBandwidth(sdp, connection.bandwidth, !!connection.session.screen);
                    }

                    if (connection.bandwidth.video) {
                        sdp = CodecsHandler.setVideoBitrates(sdp, {
                            min: connection.bandwidth.video * 8 * 1024,
                            max: connection.bandwidth.video * 8 * 1024
                        });
                    }

                    if (connection.bandwidth.audio) {
                        sdp = CodecsHandler.setOpusAttributes(sdp, {
                            maxaveragebitrate: connection.bandwidth.audio * 8 * 1024,
                            maxplaybackrate: connection.bandwidth.audio * 8 * 1024,
                            stereo: 1,
                            maxptime: 3
                        });
                    }

                    return sdp;
                };

                if (typeof CodecsHandler !== 'undefined') {
                    connection.BandwidthHandler = connection.CodecsHandler = CodecsHandler;
                }

                connection.mediaConstraints = {
                    audio: {
                        mandatory: {},
                        optional: connection.bandwidth.audio ? [{
                            bandwidth: connection.bandwidth.audio * 8 * 1024 || 128 * 8 * 1024
                        }] : []
                    },
                    video: {
                        mandatory: {},
                        optional: connection.bandwidth.video ? [{
                            bandwidth: connection.bandwidth.video * 8 * 1024 || 128 * 8 * 1024
                        }, {
                            facingMode: 'user'
                        }] : [{
                            facingMode: 'user'
                        }]
                    }
                };

                if (DetectRTC.browser.name === 'Firefox') {
                    connection.mediaConstraints = {
                        audio: true,
                        video: true
                    };
                }

                if (!forceOptions.useDefaultDevices && !DetectRTC.isMobileDevice) {
                    DetectRTC.load(function () {
                        var lastAudioDevice, lastVideoDevice;
                        // it will force RTCMultiConnection to capture last-devices
                        // i.e. if external microphone is attached to system, we should prefer it over built-in devices.
                        DetectRTC.MediaDevices.forEach(function (device) {
                            if (device.kind === 'audioinput' && connection.mediaConstraints.audio !== false) {
                                lastAudioDevice = device;
                            }

                            if (device.kind === 'videoinput' && connection.mediaConstraints.video !== false) {
                                lastVideoDevice = device;
                            }
                        });

                        if (lastAudioDevice) {
                            if (DetectRTC.browser.name === 'Firefox') {
                                if (connection.mediaConstraints.audio !== true) {
                                    connection.mediaConstraints.audio.deviceId = lastAudioDevice.id;
                                } else {
                                    connection.mediaConstraints.audio = {
                                        deviceId: lastAudioDevice.id
                                    };
                                }
                                return;
                            }

                            if (connection.mediaConstraints.audio == true) {
                                connection.mediaConstraints.audio = {
                                    mandatory: {},
                                    optional: []
                                };
                            }

                            if (!connection.mediaConstraints.audio.optional) {
                                connection.mediaConstraints.audio.optional = [];
                            }

                            var optional = [{
                                sourceId: lastAudioDevice.id
                            }];

                            connection.mediaConstraints.audio.optional = optional.concat(connection.mediaConstraints.audio.optional);
                        }

                        if (lastVideoDevice) {
                            if (DetectRTC.browser.name === 'Firefox') {
                                if (connection.mediaConstraints.video !== true) {
                                    connection.mediaConstraints.video.deviceId = lastVideoDevice.id;
                                } else {
                                    connection.mediaConstraints.video = {
                                        deviceId: lastVideoDevice.id
                                    };
                                }
                                return;
                            }

                            if (connection.mediaConstraints.video == true) {
                                connection.mediaConstraints.video = {
                                    mandatory: {},
                                    optional: []
                                };
                            }

                            if (!connection.mediaConstraints.video.optional) {
                                connection.mediaConstraints.video.optional = [];
                            }

                            var optional = [{
                                sourceId: lastVideoDevice.id
                            }];

                            connection.mediaConstraints.video.optional = optional.concat(connection.mediaConstraints.video.optional);
                        }
                    });
                }

                connection.sdpConstraints = {
                    mandatory: {
                        OfferToReceiveAudio: true,
                        OfferToReceiveVideo: true
                    },
                    optional: [{
                        VoiceActivityDetection: false
                    }]
                };

                connection.sdpSemantics = null; // "unified-plan" or "plan-b", ref: webrtc.org/web-apis/chrome/unified-plan/
                connection.iceCandidatePoolSize = null; // 0
                connection.bundlePolicy = null; // max-bundle
                connection.rtcpMuxPolicy = null; // "require" or "negotiate"
                connection.iceTransportPolicy = null; // "relay" or "all"
                connection.optionalArgument = {
                    optional: [{
                        DtlsSrtpKeyAgreement: true
                    }, {
                        googImprovedWifiBwe: true
                    }, {
                        googScreencastMinBitrate: 300
                    }, {
                        googIPv6: true
                    }, {
                        googDscp: true
                    }, {
                        googCpuUnderuseThreshold: 55
                    }, {
                        googCpuOveruseThreshold: 85
                    }, {
                        googSuspendBelowMinBitrate: true
                    }, {
                        googCpuOveruseDetection: true
                    }],
                    mandatory: {}
                };

                connection.iceServers = IceServersHandler.getIceServers(connection);

                connection.candidates = {
                    host: true,
                    stun: true,
                    turn: true
                };

                connection.iceProtocols = {
                    tcp: true,
                    udp: true
                };

                // EVENTs
                connection.onopen = function (event) {
                    if (!!connection.enableLogs) {
                        console.info('Data connection has been opened between you & ', event.userid);
                    }
                };

                connection.onclose = function (event) {
                    if (!!connection.enableLogs) {
                        console.warn('Data connection has been closed between you & ', event.userid);
                    }
                };

                connection.onerror = function (error) {
                    if (!!connection.enableLogs) {
                        console.error(error.userid, 'data-error', error);
                    }
                };

                connection.onmessage = function (event) {
                    if (!!connection.enableLogs) {
                        console.debug('data-message', event.userid, event.data);
                    }
                };

                connection.send = function (data, remoteUserId) {
                    connection.peers.send(data, remoteUserId);
                };

                connection.close = connection.disconnect = connection.leave = function () {
                    connection.onbeforeunload(false, true);
                };

                connection.closeEntireSession = function (callback) {
                    callback = callback || function () {};
                    connection.socket.emit('close-entire-session', function looper() {
                        if (connection.getAllParticipants().length) {
                            setTimeout(looper, 100);
                            return;
                        }

                        connection.onEntireSessionClosed({
                            sessionid: connection.sessionid,
                            userid: connection.userid,
                            extra: connection.extra
                        });

                        connection.changeUserId(null, function () {
                            connection.close();
                            callback();
                        });
                    });
                };

                connection.onEntireSessionClosed = function (event) {
                    if (!connection.enableLogs) return;
                    console.info('Entire session is closed: ', event.sessionid, event.extra);
                };

                connection.onstream = function (e) {
                    var parentNode = connection.videosContainer;
                    parentNode.insertBefore(e.mediaElement, parentNode.firstChild);
                    var played = e.mediaElement.play();

                    if (typeof played !== 'undefined') {
                        played.catch(function () {
                            /*** iOS 11 doesn't allow automatic play and rejects ***/
                        }).then(function () {
                            setTimeout(function () {
                                e.mediaElement.play();
                            }, 2000);
                        });
                        return;
                    }

                    setTimeout(function () {
                        e.mediaElement.play();
                    }, 2000);
                };

                connection.onstreamended = function (e) {
                    if (!e.mediaElement) {
                        e.mediaElement = document.getElementById(e.streamid);
                    }

                    if (!e.mediaElement || !e.mediaElement.parentNode) {
                        return;
                    }

                    e.mediaElement.parentNode.removeChild(e.mediaElement);
                };

                connection.direction = 'many-to-many';

                connection.removeStream = function (streamid, remoteUserId) {
                    var stream;
                    connection.attachStreams.forEach(function (localStream) {
                        if (localStream.id === streamid) {
                            stream = localStream;
                        }
                    });

                    if (!stream) {
                        console.warn('No such stream exist.', streamid);
                        return;
                    }

                    connection.peers.getAllParticipants().forEach(function (participant) {
                        if (remoteUserId && participant !== remoteUserId) {
                            return;
                        }

                        var user = connection.peers[participant];
                        try {
                            user.peer.removeStream(stream);
                        } catch (e) {}
                    });

                    connection.renegotiate();
                };

                connection.addStream = function (session, remoteUserId) {
                    if (!!session.getTracks) {
                        if (connection.attachStreams.indexOf(session) === -1) {
                            if (!session.streamid) {
                                session.streamid = session.id;
                            }

                            connection.attachStreams.push(session);
                        }
                        connection.renegotiate(remoteUserId);
                        return;
                    }

                    if (isData(session)) {
                        connection.renegotiate(remoteUserId);
                        return;
                    }

                    if (session.audio || session.video || session.screen) {
                        if (session.screen) {
                            if (DetectRTC.browser.name === 'Edge') {
                                navigator.getDisplayMedia({
                                    video: true,
                                    audio: isAudioPlusTab(connection)
                                }).then(function (screen) {
                                    screen.isScreen = true;
                                    mPeer.onGettingLocalMedia(screen);

                                    if ((session.audio || session.video) && !isAudioPlusTab(connection)) {
                                        connection.invokeGetUserMedia(null, function (stream) {
                                            gumCallback(stream);
                                        });
                                    } else {
                                        gumCallback(screen);
                                    }
                                }, function (error) {
                                    console.error('Unable to capture screen on Edge. HTTPs and version 17+ is required.');
                                });
                            } else {
                                connection.invokeGetUserMedia({
                                    audio: isAudioPlusTab(connection),
                                    video: true,
                                    isScreen: true
                                }, function (stream) {
                                    if ((session.audio || session.video) && !isAudioPlusTab(connection)) {
                                        connection.invokeGetUserMedia(null, function (stream) {
                                            gumCallback(stream);
                                        });
                                    } else {
                                        gumCallback(stream);
                                    }
                                });
                            }
                        } else if (session.audio || session.video) {
                            connection.invokeGetUserMedia(null, gumCallback);
                        }
                    }

                    function gumCallback(stream) {
                        if (session.streamCallback) {
                            session.streamCallback(stream);
                        }

                        connection.renegotiate(remoteUserId);
                    }
                };

                connection.invokeGetUserMedia = function (localMediaConstraints, callback, session) {
                    if (!session) {
                        session = connection.session;
                    }

                    if (!localMediaConstraints) {
                        localMediaConstraints = connection.mediaConstraints;
                    }

                    getUserMediaHandler({
                        onGettingLocalMedia: function (stream) {
                            var videoConstraints = localMediaConstraints.video;
                            if (videoConstraints) {
                                if (videoConstraints.mediaSource || videoConstraints.mozMediaSource) {
                                    stream.isScreen = true;
                                } else if (videoConstraints.mandatory && videoConstraints.mandatory.chromeMediaSource) {
                                    stream.isScreen = true;
                                }
                            }

                            if (!stream.isScreen) {
                                stream.isVideo = !!getTracks(stream, 'video').length;
                                stream.isAudio = !stream.isVideo && getTracks(stream, 'audio').length;
                            }

                            mPeer.onGettingLocalMedia(stream, function () {
                                if (typeof callback === 'function') {
                                    callback(stream);
                                }
                            });
                        },
                        onLocalMediaError: function (error, constraints) {
                            mPeer.onLocalMediaError(error, constraints);
                        },
                        localMediaConstraints: localMediaConstraints || {
                            audio: session.audio ? localMediaConstraints.audio : false,
                            video: session.video ? localMediaConstraints.video : false
                        }
                    });
                };

                function applyConstraints(stream, mediaConstraints) {
                    if (!stream) {
                        if (!!connection.enableLogs) {
                            console.error('No stream to applyConstraints.');
                        }
                        return;
                    }

                    if (mediaConstraints.audio) {
                        getTracks(stream, 'audio').forEach(function (track) {
                            track.applyConstraints(mediaConstraints.audio);
                        });
                    }

                    if (mediaConstraints.video) {
                        getTracks(stream, 'video').forEach(function (track) {
                            track.applyConstraints(mediaConstraints.video);
                        });
                    }
                }

                connection.applyConstraints = function (mediaConstraints, streamid) {
                    if (!MediaStreamTrack || !MediaStreamTrack.prototype.applyConstraints) {
                        alert('track.applyConstraints is NOT supported in your browser.');
                        return;
                    }

                    if (streamid) {
                        var stream;
                        if (connection.streamEvents[streamid]) {
                            stream = connection.streamEvents[streamid].stream;
                        }
                        applyConstraints(stream, mediaConstraints);
                        return;
                    }

                    connection.attachStreams.forEach(function (stream) {
                        applyConstraints(stream, mediaConstraints);
                    });
                };

                function replaceTrack(track, remoteUserId, isVideoTrack) {
                    if (remoteUserId) {
                        mPeer.replaceTrack(track, remoteUserId, isVideoTrack);
                        return;
                    }

                    connection.peers.getAllParticipants().forEach(function (participant) {
                        mPeer.replaceTrack(track, participant, isVideoTrack);
                    });
                }

                connection.replaceTrack = function (session, remoteUserId, isVideoTrack) {
                    session = session || {};

                    if (!RTCPeerConnection.prototype.getSenders) {
                        connection.addStream(session);
                        return;
                    }

                    if (session instanceof MediaStreamTrack) {
                        replaceTrack(session, remoteUserId, isVideoTrack);
                        return;
                    }

                    if (session instanceof MediaStream) {
                        if (getTracks(session, 'video').length) {
                            replaceTrack(getTracks(session, 'video')[0], remoteUserId, true);
                        }

                        if (getTracks(session, 'audio').length) {
                            replaceTrack(getTracks(session, 'audio')[0], remoteUserId, false);
                        }
                        return;
                    }

                    if (isData(session)) {
                        throw 'connection.replaceTrack requires audio and/or video and/or screen.';
                        return;
                    }

                    if (session.audio || session.video || session.screen) {
                        if (session.screen) {
                            if (DetectRTC.browser.name === 'Edge') {
                                navigator.getDisplayMedia({
                                    video: true,
                                    audio: isAudioPlusTab(connection)
                                }).then(function (screen) {
                                    screen.isScreen = true;
                                    mPeer.onGettingLocalMedia(screen);

                                    if ((session.audio || session.video) && !isAudioPlusTab(connection)) {
                                        connection.invokeGetUserMedia(null, gumCallback);
                                    } else {
                                        gumCallback(screen);
                                    }
                                }, function (error) {
                                    console.error('Unable to capture screen on Edge. HTTPs and version 17+ is required.');
                                });
                            } else {
                                connection.invokeGetUserMedia({
                                    audio: isAudioPlusTab(connection),
                                    video: true,
                                    isScreen: true
                                }, (session.audio || session.video) && !isAudioPlusTab(connection) ? connection.invokeGetUserMedia(null, gumCallback) : gumCallback);
                            }
                        } else if (session.audio || session.video) {
                            connection.invokeGetUserMedia(null, gumCallback);
                        }
                    }

                    function gumCallback(stream) {
                        connection.replaceTrack(stream, remoteUserId, isVideoTrack || session.video || session.screen);
                    }
                };

                connection.resetTrack = function (remoteUsersIds, isVideoTrack) {
                    if (!remoteUsersIds) {
                        remoteUsersIds = connection.getAllParticipants();
                    }

                    if (typeof remoteUsersIds == 'string') {
                        remoteUsersIds = [remoteUsersIds];
                    }

                    remoteUsersIds.forEach(function (participant) {
                        var peer = connection.peers[participant].peer;

                        if ((typeof isVideoTrack === 'undefined' || isVideoTrack === true) && peer.lastVideoTrack) {
                            connection.replaceTrack(peer.lastVideoTrack, participant, true);
                        }

                        if ((typeof isVideoTrack === 'undefined' || isVideoTrack === false) && peer.lastAudioTrack) {
                            connection.replaceTrack(peer.lastAudioTrack, participant, false);
                        }
                    });
                };

                connection.renegotiate = function (remoteUserId) {
                    if (remoteUserId) {
                        mPeer.renegotiatePeer(remoteUserId);
                        return;
                    }

                    connection.peers.getAllParticipants().forEach(function (participant) {
                        mPeer.renegotiatePeer(participant);
                    });
                };

                connection.setStreamEndHandler = function (stream, isRemote) {
                    if (!stream || !stream.addEventListener) return;

                    isRemote = !!isRemote;

                    if (stream.alreadySetEndHandler) {
                        return;
                    }
                    stream.alreadySetEndHandler = true;

                    var streamEndedEvent = 'ended';

                    if ('oninactive' in stream) {
                        streamEndedEvent = 'inactive';
                    }

                    stream.addEventListener(streamEndedEvent, function () {
                        if (stream.idInstance) {
                            currentUserMediaRequest.remove(stream.idInstance);
                        }

                        if (!isRemote) {
                            // reset attachStreams
                            var streams = [];
                            connection.attachStreams.forEach(function (s) {
                                if (s.id != stream.id) {
                                    streams.push(s);
                                }
                            });
                            connection.attachStreams = streams;
                        }

                        // connection.renegotiate();

                        var streamEvent = connection.streamEvents[stream.streamid];
                        if (!streamEvent) {
                            streamEvent = {
                                stream: stream,
                                streamid: stream.streamid,
                                type: isRemote ? 'remote' : 'local',
                                userid: connection.userid,
                                extra: connection.extra,
                                mediaElement: connection.streamEvents[stream.streamid] ? connection.streamEvents[stream.streamid].mediaElement : null
                            };
                        }

                        if (isRemote && connection.peers[streamEvent.userid]) {
                            // reset remote "streams"
                            var peer = connection.peers[streamEvent.userid].peer;
                            var streams = [];
                            peer.getRemoteStreams().forEach(function (s) {
                                if (s.id != stream.id) {
                                    streams.push(s);
                                }
                            });
                            connection.peers[streamEvent.userid].streams = streams;
                        }

                        if (streamEvent.userid === connection.userid && streamEvent.type === 'remote') {
                            return;
                        }

                        if (connection.peersBackup[streamEvent.userid]) {
                            streamEvent.extra = connection.peersBackup[streamEvent.userid].extra;
                        }

                        connection.onstreamended(streamEvent);

                        delete connection.streamEvents[stream.streamid];
                    }, false);
                };

                connection.onMediaError = function (error, constraints) {
                    if (!!connection.enableLogs) {
                        console.error(error, constraints);
                    }
                };

                connection.autoCloseEntireSession = false;

                connection.filesContainer = connection.videosContainer = document.body || document.documentElement;
                connection.isInitiator = false;

                connection.shareFile = mPeer.shareFile;
                if (typeof FileProgressBarHandler !== 'undefined') {
                    FileProgressBarHandler.handle(connection);
                }

                if (typeof TranslationHandler !== 'undefined') {
                    TranslationHandler.handle(connection);
                }

                connection.token = getRandomString;

                connection.onNewParticipant = function (participantId, userPreferences) {
                    connection.acceptParticipationRequest(participantId, userPreferences);
                };

                connection.acceptParticipationRequest = function (participantId, userPreferences) {
                    if (userPreferences.successCallback) {
                        userPreferences.successCallback();
                        delete userPreferences.successCallback;
                    }

                    mPeer.createNewPeer(participantId, userPreferences);
                };

                if (typeof StreamsHandler !== 'undefined') {
                    connection.StreamsHandler = StreamsHandler;
                }

                connection.onleave = function (userid) {};

                connection.invokeSelectFileDialog = function (callback) {
                    var selector = new FileSelector();
                    selector.accept = '*.*';
                    selector.selectSingleFile(callback);
                };

                connection.onmute = function (e) {
                    if (!e || !e.mediaElement) {
                        return;
                    }

                    if (e.muteType === 'both' || e.muteType === 'video') {
                        e.mediaElement.src = null;
                        var paused = e.mediaElement.pause();
                        if (typeof paused !== 'undefined') {
                            paused.then(function () {
                                e.mediaElement.poster = e.snapshot || 'https://cdn.webrtc-experiment.com/images/muted.png';
                            });
                        } else {
                            e.mediaElement.poster = e.snapshot || 'https://cdn.webrtc-experiment.com/images/muted.png';
                        }
                    } else if (e.muteType === 'audio') {
                        e.mediaElement.muted = true;
                    }
                };

                connection.onunmute = function (e) {
                    if (!e || !e.mediaElement || !e.stream) {
                        return;
                    }

                    if (e.unmuteType === 'both' || e.unmuteType === 'video') {
                        e.mediaElement.poster = null;
                        e.mediaElement.srcObject = e.stream;
                        e.mediaElement.play();
                    } else if (e.unmuteType === 'audio') {
                        e.mediaElement.muted = false;
                    }
                };

                connection.onExtraDataUpdated = function (event) {
                    event.status = 'online';
                    connection.onUserStatusChanged(event, true);
                };

                connection.getAllParticipants = function (sender) {
                    return connection.peers.getAllParticipants(sender);
                };

                if (typeof StreamsHandler !== 'undefined') {
                    StreamsHandler.onSyncNeeded = function (streamid, action, type) {
                        connection.peers.getAllParticipants().forEach(function (participant) {
                            mPeer.onNegotiationNeeded({
                                streamid: streamid,
                                action: action,
                                streamSyncNeeded: true,
                                type: type || 'both'
                            }, participant);
                        });
                    };
                }

                connection.connectSocket = function (callback) {
                    connectSocket(callback);
                };

                connection.closeSocket = function () {
                    try {
                        io.sockets = {};
                    } catch (e) {};

                    if (!connection.socket) return;

                    if (typeof connection.socket.disconnect === 'function') {
                        connection.socket.disconnect();
                    }

                    if (typeof connection.socket.resetProps === 'function') {
                        connection.socket.resetProps();
                    }

                    connection.socket = null;
                };

                connection.getSocket = function (callback) {
                    if (!callback && connection.enableLogs) {
                        console.warn('getSocket.callback paramter is required.');
                    }

                    callback = callback || function () {};

                    if (!connection.socket) {
                        connectSocket(function () {
                            callback(connection.socket);
                        });
                    } else {
                        callback(connection.socket);
                    }

                    return connection.socket; // callback is preferred over return-statement
                };

                connection.getRemoteStreams = mPeer.getRemoteStreams;

                var skipStreams = ['selectFirst', 'selectAll', 'forEach'];

                connection.streamEvents = {
                    selectFirst: function (options) {
                        return connection.streamEvents.selectAll(options)[0];
                    },
                    selectAll: function (options) {
                        if (!options) {
                            // default will always be all streams
                            options = {
                                local: true,
                                remote: true,
                                isScreen: true,
                                isAudio: true,
                                isVideo: true
                            };
                        }

                        if (options == 'local') {
                            options = {
                                local: true
                            };
                        }

                        if (options == 'remote') {
                            options = {
                                remote: true
                            };
                        }

                        if (options == 'screen') {
                            options = {
                                isScreen: true
                            };
                        }

                        if (options == 'audio') {
                            options = {
                                isAudio: true
                            };
                        }

                        if (options == 'video') {
                            options = {
                                isVideo: true
                            };
                        }

                        var streams = [];
                        Object.keys(connection.streamEvents).forEach(function (key) {
                            var event = connection.streamEvents[key];

                            if (skipStreams.indexOf(key) !== -1) return;
                            var ignore = true;

                            if (options.local && event.type === 'local') {
                                ignore = false;
                            }

                            if (options.remote && event.type === 'remote') {
                                ignore = false;
                            }

                            if (options.isScreen && event.stream.isScreen) {
                                ignore = false;
                            }

                            if (options.isVideo && event.stream.isVideo) {
                                ignore = false;
                            }

                            if (options.isAudio && event.stream.isAudio) {
                                ignore = false;
                            }

                            if (options.userid && event.userid === options.userid) {
                                ignore = false;
                            }

                            if (ignore === false) {
                                streams.push(event);
                            }
                        });

                        return streams;
                    }
                };

                connection.socketURL = '/'; // generated via config.json
                connection.socketMessageEvent = 'RTCMultiConnection-Message'; // generated via config.json
                connection.socketCustomEvent = 'RTCMultiConnection-Custom-Message'; // generated via config.json
                connection.DetectRTC = DetectRTC;

                connection.setCustomSocketEvent = function (customEvent) {
                    if (customEvent) {
                        connection.socketCustomEvent = customEvent;
                    }

                    if (!connection.socket) {
                        return;
                    }

                    connection.socket.emit('set-custom-socket-event-listener', connection.socketCustomEvent);
                };

                connection.getNumberOfBroadcastViewers = function (broadcastId, callback) {
                    if (!connection.socket || !broadcastId || !callback) return;

                    connection.socket.emit('get-number-of-users-in-specific-broadcast', broadcastId, callback);
                };

                connection.onNumberOfBroadcastViewersUpdated = function (event) {
                    if (!connection.enableLogs || !connection.isInitiator) return;
                    console.info('Number of broadcast (', event.broadcastId, ') viewers', event.numberOfBroadcastViewers);
                };

                connection.onUserStatusChanged = function (event, dontWriteLogs) {
                    if (!!connection.enableLogs && !dontWriteLogs) {
                        console.info(event.userid, event.status);
                    }
                };

                connection.getUserMediaHandler = getUserMediaHandler;
                connection.multiPeersHandler = mPeer;
                connection.enableLogs = true;
                connection.setCustomSocketHandler = function (customSocketHandler) {
                    if (typeof SocketConnection !== 'undefined') {
                        SocketConnection = customSocketHandler;
                    }
                };

                // default value should be 15k because [old]Firefox's receiving limit is 16k!
                // however 64k works chrome-to-chrome
                connection.chunkSize = 40 * 1000;

                connection.maxParticipantsAllowed = 1000;

                // eject or leave single user
                connection.disconnectWith = mPeer.disconnectWith;

                // check if room exist on server
                // we will pass roomid to the server and wait for callback (i.e. server's response)
                connection.checkPresence = function (roomid, callback) {
                    roomid = roomid || connection.sessionid;

                    if (SocketConnection.name === 'SSEConnection') {
                        SSEConnection.checkPresence(roomid, function (isRoomExist, _roomid, extra) {
                            if (!connection.socket) {
                                if (!isRoomExist) {
                                    connection.userid = _roomid;
                                }

                                connection.connectSocket(function () {
                                    callback(isRoomExist, _roomid, extra);
                                });
                                return;
                            }
                            callback(isRoomExist, _roomid);
                        });
                        return;
                    }

                    if (!connection.socket) {
                        connection.connectSocket(function () {
                            connection.checkPresence(roomid, callback);
                        });
                        return;
                    }

                    connection.socket.emit('check-presence', roomid + '', function (isRoomExist, _roomid, extra) {
                        if (connection.enableLogs) {
                            console.log('checkPresence.isRoomExist: ', isRoomExist, ' roomid: ', _roomid);
                        }
                        callback(isRoomExist, _roomid, extra);
                    });
                };

                connection.onReadyForOffer = function (remoteUserId, userPreferences) {
                    connection.multiPeersHandler.createNewPeer(remoteUserId, userPreferences);
                };

                connection.setUserPreferences = function (userPreferences) {
                    if (connection.dontAttachStream) {
                        userPreferences.dontAttachLocalStream = true;
                    }

                    if (connection.dontGetRemoteStream) {
                        userPreferences.dontGetRemoteStream = true;
                    }

                    return userPreferences;
                };

                connection.updateExtraData = function () {
                    connection.socket.emit('extra-data-updated', connection.extra);
                };

                connection.enableScalableBroadcast = false;
                connection.maxRelayLimitPerUser = 3; // each broadcast should serve only 3 users

                connection.dontCaptureUserMedia = false;
                connection.dontAttachStream = false;
                connection.dontGetRemoteStream = false;

                connection.onReConnecting = function (event) {
                    if (connection.enableLogs) {
                        console.info('ReConnecting with', event.userid, '...');
                    }
                };

                connection.beforeAddingStream = function (stream) {
                    return stream;
                };

                connection.beforeRemovingStream = function (stream) {
                    return stream;
                };

                if (typeof isChromeExtensionAvailable !== 'undefined') {
                    connection.checkIfChromeExtensionAvailable = isChromeExtensionAvailable;
                }

                if (typeof isFirefoxExtensionAvailable !== 'undefined') {
                    connection.checkIfChromeExtensionAvailable = isFirefoxExtensionAvailable;
                }

                if (typeof getChromeExtensionStatus !== 'undefined') {
                    connection.getChromeExtensionStatus = getChromeExtensionStatus;
                }

                connection.modifyScreenConstraints = function (screen_constraints) {
                    return screen_constraints;
                };

                connection.onPeerStateChanged = function (state) {
                    if (connection.enableLogs) {
                        if (state.iceConnectionState.search(/closed|failed/gi) !== -1) {
                            console.error('Peer connection is closed between you & ', state.userid, state.extra, 'state:', state.iceConnectionState);
                        }
                    }
                };

                connection.isOnline = true;

                listenEventHandler('online', function () {
                    connection.isOnline = true;
                });

                listenEventHandler('offline', function () {
                    connection.isOnline = false;
                });

                connection.isLowBandwidth = false;
                if (navigator && navigator.connection && navigator.connection.type) {
                    connection.isLowBandwidth = navigator.connection.type.toString().toLowerCase().search(/wifi|cell/g) !== -1;
                    if (connection.isLowBandwidth) {
                        connection.bandwidth = {
                            audio: false,
                            video: false,
                            screen: false
                        };

                        if (connection.mediaConstraints.audio && connection.mediaConstraints.audio.optional && connection.mediaConstraints.audio.optional.length) {
                            var newArray = [];
                            connection.mediaConstraints.audio.optional.forEach(function (opt) {
                                if (typeof opt.bandwidth === 'undefined') {
                                    newArray.push(opt);
                                }
                            });
                            connection.mediaConstraints.audio.optional = newArray;
                        }

                        if (connection.mediaConstraints.video && connection.mediaConstraints.video.optional && connection.mediaConstraints.video.optional.length) {
                            var newArray = [];
                            connection.mediaConstraints.video.optional.forEach(function (opt) {
                                if (typeof opt.bandwidth === 'undefined') {
                                    newArray.push(opt);
                                }
                            });
                            connection.mediaConstraints.video.optional = newArray;
                        }
                    }
                }

                connection.getExtraData = function (remoteUserId, callback) {
                    if (!remoteUserId) throw 'remoteUserId is required.';

                    if (typeof callback === 'function') {
                        connection.socket.emit('get-remote-user-extra-data', remoteUserId, function (extra, remoteUserId, error) {
                            callback(extra, remoteUserId, error);
                        });
                        return;
                    }

                    if (!connection.peers[remoteUserId]) {
                        if (connection.peersBackup[remoteUserId]) {
                            return connection.peersBackup[remoteUserId].extra;
                        }
                        return {};
                    }

                    return connection.peers[remoteUserId].extra;
                };

                if (!!forceOptions.autoOpenOrJoin) {
                    connection.openOrJoin(connection.sessionid);
                }

                connection.onUserIdAlreadyTaken = function (useridAlreadyTaken, yourNewUserId) {
                    // via #683
                    connection.close();
                    connection.closeSocket();

                    connection.isInitiator = false;
                    connection.userid = connection.token();

                    connection.join(connection.sessionid);

                    if (connection.enableLogs) {
                        console.warn('Userid already taken.', useridAlreadyTaken, 'Your new userid:', connection.userid);
                    }
                };

                connection.trickleIce = true;
                connection.version = '3.7.0';

                connection.onSettingLocalDescription = function (event) {
                    if (connection.enableLogs) {
                        console.info('Set local description for remote user', event.userid);
                    }
                };

                connection.resetScreen = function () {
                    sourceId = null;
                    if (DetectRTC && DetectRTC.screen) {
                        delete DetectRTC.screen.sourceId;
                    }

                    currentUserMediaRequest = {
                        streams: [],
                        mutex: false,
                        queueRequests: []
                    };
                };

                // if disabled, "event.mediaElement" for "onstream" will be NULL
                connection.autoCreateMediaElement = true;

                // set password
                connection.password = null;

                // set password
                connection.setPassword = function (password, callback) {
                    callback = callback || function () {};
                    if (connection.socket) {
                        connection.socket.emit('set-password', password, callback);
                    } else {
                        connection.password = password;
                        callback(true, connection.sessionid, null);
                    }
                };

                connection.onSocketDisconnect = function (event) {
                    if (connection.enableLogs) {
                        console.warn('socket.io connection is closed');
                    }
                };

                connection.onSocketError = function (event) {
                    if (connection.enableLogs) {
                        console.warn('socket.io connection is failed');
                    }
                };

                // error messages
                connection.errors = {
                    ROOM_NOT_AVAILABLE: 'Room not available',
                    INVALID_PASSWORD: 'Invalid password',
                    USERID_NOT_AVAILABLE: 'User ID does not exist',
                    ROOM_PERMISSION_DENIED: 'Room permission denied',
                    ROOM_FULL: 'Room full',
                    DID_NOT_JOIN_ANY_ROOM: 'Did not join any room yet',
                    INVALID_SOCKET: 'Invalid socket',
                    PUBLIC_IDENTIFIER_MISSING: 'publicRoomIdentifier is required',
                    INVALID_ADMIN_CREDENTIAL: 'Invalid username or password attempted'
                };
            })(this);
        };

        if (typeof module !== 'undefined' /* && !!module.exports*/) {
                module.exports = exports = RTCMultiConnection;
            }

        if (typeof define === 'function' && define.amd) {
            define('RTCMultiConnection', [], function () {
                return RTCMultiConnection;
            });
        }
    })(this);

    return _retrieveGlobal();
});
(function() {
var define = $__System.amdDefine;
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define("1f", [], factory);
  else if (typeof exports === 'object')
    exports["io"] = factory();
  else
    root["io"] = factory();
})(this, function() {
  return (function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId])
        return installedModules[moduleId].exports;
      var module = installedModules[moduleId] = {
        exports: {},
        id: moduleId,
        loaded: false
      };
      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
      module.loaded = true;
      return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.p = "";
    return __webpack_require__(0);
  })([function(module, exports, __webpack_require__) {
    'use strict';
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var url = __webpack_require__(1);
    var parser = __webpack_require__(7);
    var Manager = __webpack_require__(17);
    var debug = __webpack_require__(3)('socket.io-client');
    module.exports = exports = lookup;
    var cache = exports.managers = {};
    function lookup(uri, opts) {
      if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
        opts = uri;
        uri = undefined;
      }
      opts = opts || {};
      var parsed = url(uri);
      var source = parsed.source;
      var id = parsed.id;
      var path = parsed.path;
      var sameNamespace = cache[id] && path in cache[id].nsps;
      var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
      var io;
      if (newConnection) {
        debug('ignoring socket cache for %s', source);
        io = Manager(source, opts);
      } else {
        if (!cache[id]) {
          debug('new io instance for %s', source);
          cache[id] = Manager(source, opts);
        }
        io = cache[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.query;
      } else if (opts && 'object' === _typeof(opts.query)) {
        opts.query = encodeQueryString(opts.query);
      }
      return io.socket(parsed.path, opts);
    }
    function encodeQueryString(obj) {
      var str = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
        }
      }
      return str.join('&');
    }
    exports.protocol = parser.protocol;
    exports.connect = lookup;
    exports.Manager = __webpack_require__(17);
    exports.Socket = __webpack_require__(44);
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      'use strict';
      var parseuri = __webpack_require__(2);
      var debug = __webpack_require__(3)('socket.io-client:url');
      module.exports = url;
      function url(uri, loc) {
        var obj = uri;
        loc = loc || global.location;
        if (null == uri)
          uri = loc.protocol + '//' + loc.host;
        if ('string' === typeof uri) {
          if ('/' === uri.charAt(0)) {
            if ('/' === uri.charAt(1)) {
              uri = loc.protocol + uri;
            } else {
              uri = loc.host + uri;
            }
          }
          if (!/^(https?|wss?):\/\//.test(uri)) {
            debug('protocol-less url %s', uri);
            if ('undefined' !== typeof loc) {
              uri = loc.protocol + '//' + uri;
            } else {
              uri = 'https://' + uri;
            }
          }
          debug('parse %s', uri);
          obj = parseuri(uri);
        }
        if (!obj.port) {
          if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = '80';
          } else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = '443';
          }
        }
        obj.path = obj.path || '/';
        var ipv6 = obj.host.indexOf(':') !== -1;
        var host = ipv6 ? '[' + obj.host + ']' : obj.host;
        obj.id = obj.protocol + '://' + host + ':' + obj.port;
        obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);
        return obj;
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
    module.exports = function parseuri(str) {
      var src = str,
          b = str.indexOf('['),
          e = str.indexOf(']');
      if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
      }
      var m = re.exec(str || ''),
          uri = {},
          i = 14;
      while (i--) {
        uri[parts[i]] = m[i] || '';
      }
      if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
      }
      return uri;
    };
  }, function(module, exports, __webpack_require__) {
    (function(process) {
      exports = module.exports = __webpack_require__(5);
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
      exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
      function useColors() {
        return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
      }
      exports.formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (err) {
          return '[UnexpectedJSONParseError]: ' + err.message;
        }
      };
      function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;
        args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
        if (!useColors)
          return args;
        var c = 'color: ' + this.color;
        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function(match) {
          if ('%%' === match)
            return;
          index++;
          if ('%c' === match) {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
        return args;
      }
      function log() {
        return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          if (null == namespaces) {
            exports.storage.removeItem('debug');
          } else {
            exports.storage.debug = namespaces;
          }
        } catch (e) {}
      }
      function load() {
        var r;
        try {
          return exports.storage.debug;
        } catch (e) {}
        if (typeof process !== 'undefined' && 'env' in process) {
          return process.env.DEBUG;
        }
      }
      exports.enable(load());
      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {}
      }
    }.call(exports, __webpack_require__(4)));
  }, function(module, exports) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }
    (function() {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    }());
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = '';
    process.versions = {};
    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.binding = function(name) {
      throw new Error('process.binding is not supported');
    };
    process.cwd = function() {
      return '/';
    };
    process.chdir = function(dir) {
      throw new Error('process.chdir is not supported');
    };
    process.umask = function() {
      return 0;
    };
  }, function(module, exports, __webpack_require__) {
    exports = module.exports = debug.debug = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = __webpack_require__(6);
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;
    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    function debug(namespace) {
      function disabled() {}
      disabled.enabled = false;
      function enabled() {
        var self = enabled;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        if (null == self.useColors)
          self.useColors = exports.useColors();
        if (null == self.color && self.useColors)
          self.color = selectColor();
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ('string' !== typeof args[0]) {
          args = ['%o'].concat(args);
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
          if (match === '%%')
            return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        args = exports.formatArgs.apply(self, args);
        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      enabled.enabled = true;
      var fn = exports.enabled(namespace) ? enabled : disabled;
      fn.namespace = namespace;
      return fn;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || '').split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    function disable() {
      exports.enable('');
    }
    function enabled(name) {
      var i,
          len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }, function(module, exports) {
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 10000) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (ms >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (ms >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (ms >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }
    function fmtLong(ms) {
      return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name;
      }
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
  }, function(module, exports, __webpack_require__) {
    var debug = __webpack_require__(8)('socket.io-parser');
    var json = __webpack_require__(11);
    var Emitter = __webpack_require__(13);
    var binary = __webpack_require__(14);
    var isBuf = __webpack_require__(16);
    exports.protocol = 4;
    exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];
    exports.CONNECT = 0;
    exports.DISCONNECT = 1;
    exports.EVENT = 2;
    exports.ACK = 3;
    exports.ERROR = 4;
    exports.BINARY_EVENT = 5;
    exports.BINARY_ACK = 6;
    exports.Encoder = Encoder;
    exports.Decoder = Decoder;
    function Encoder() {}
    Encoder.prototype.encode = function(obj, callback) {
      debug('encoding packet %j', obj);
      if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
        encodeAsBinary(obj, callback);
      } else {
        var encoding = encodeAsString(obj);
        callback([encoding]);
      }
    };
    function encodeAsString(obj) {
      var str = '';
      var nsp = false;
      str += obj.type;
      if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
        str += obj.attachments;
        str += '-';
      }
      if (obj.nsp && '/' != obj.nsp) {
        nsp = true;
        str += obj.nsp;
      }
      if (null != obj.id) {
        if (nsp) {
          str += ',';
          nsp = false;
        }
        str += obj.id;
      }
      if (null != obj.data) {
        if (nsp)
          str += ',';
        str += json.stringify(obj.data);
      }
      debug('encoded %j as %s', obj, str);
      return str;
    }
    function encodeAsBinary(obj, callback) {
      function writeEncoding(bloblessData) {
        var deconstruction = binary.deconstructPacket(bloblessData);
        var pack = encodeAsString(deconstruction.packet);
        var buffers = deconstruction.buffers;
        buffers.unshift(pack);
        callback(buffers);
      }
      binary.removeBlobs(obj, writeEncoding);
    }
    function Decoder() {
      this.reconstructor = null;
    }
    Emitter(Decoder.prototype);
    Decoder.prototype.add = function(obj) {
      var packet;
      if ('string' == typeof obj) {
        packet = decodeString(obj);
        if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
          this.reconstructor = new BinaryReconstructor(packet);
          if (this.reconstructor.reconPack.attachments === 0) {
            this.emit('decoded', packet);
          }
        } else {
          this.emit('decoded', packet);
        }
      } else if (isBuf(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error('got binary data when not reconstructing a packet');
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            this.emit('decoded', packet);
          }
        }
      } else {
        throw new Error('Unknown type: ' + obj);
      }
    };
    function decodeString(str) {
      var p = {};
      var i = 0;
      p.type = Number(str.charAt(0));
      if (null == exports.types[p.type])
        return error();
      if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
        var buf = '';
        while (str.charAt(++i) != '-') {
          buf += str.charAt(i);
          if (i == str.length)
            break;
        }
        if (buf != Number(buf) || str.charAt(i) != '-') {
          throw new Error('Illegal attachments');
        }
        p.attachments = Number(buf);
      }
      if ('/' == str.charAt(i + 1)) {
        p.nsp = '';
        while (++i) {
          var c = str.charAt(i);
          if (',' == c)
            break;
          p.nsp += c;
          if (i == str.length)
            break;
        }
      } else {
        p.nsp = '/';
      }
      var next = str.charAt(i + 1);
      if ('' !== next && Number(next) == next) {
        p.id = '';
        while (++i) {
          var c = str.charAt(i);
          if (null == c || Number(c) != c) {
            --i;
            break;
          }
          p.id += str.charAt(i);
          if (i == str.length)
            break;
        }
        p.id = Number(p.id);
      }
      if (str.charAt(++i)) {
        p = tryParse(p, str.substr(i));
      }
      debug('decoded %s as %j', str, p);
      return p;
    }
    function tryParse(p, str) {
      try {
        p.data = json.parse(str);
      } catch (e) {
        return error();
      }
      return p;
    }
    ;
    Decoder.prototype.destroy = function() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    };
    function BinaryReconstructor(packet) {
      this.reconPack = packet;
      this.buffers = [];
    }
    BinaryReconstructor.prototype.takeBinaryData = function(binData) {
      this.buffers.push(binData);
      if (this.buffers.length == this.reconPack.attachments) {
        var packet = binary.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    };
    BinaryReconstructor.prototype.finishedReconstruction = function() {
      this.reconPack = null;
      this.buffers = [];
    };
    function error(data) {
      return {
        type: exports.ERROR,
        data: 'parser error'
      };
    }
  }, function(module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(9);
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
    function useColors() {
      return ('WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
    }
    exports.formatters.j = function(v) {
      return JSON.stringify(v);
    };
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
      if (!useColors)
        return args;
      var c = 'color: ' + this.color;
      args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-z%]/g, function(match) {
        if ('%%' === match)
          return;
        index++;
        if ('%c' === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
      return args;
    }
    function log() {
      return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {}
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  }, function(module, exports, __webpack_require__) {
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = __webpack_require__(10);
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;
    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    function debug(namespace) {
      function disabled() {}
      disabled.enabled = false;
      function enabled() {
        var self = enabled;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        if (null == self.useColors)
          self.useColors = exports.useColors();
        if (null == self.color && self.useColors)
          self.color = selectColor();
        var args = Array.prototype.slice.call(arguments);
        args[0] = exports.coerce(args[0]);
        if ('string' !== typeof args[0]) {
          args = ['%o'].concat(args);
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
          if (match === '%%')
            return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        if ('function' === typeof exports.formatArgs) {
          args = exports.formatArgs.apply(self, args);
        }
        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      enabled.enabled = true;
      var fn = exports.enabled(namespace) ? enabled : disabled;
      fn.namespace = namespace;
      return fn;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || '').split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    function disable() {
      exports.enable('');
    }
    function enabled(name) {
      var i,
          len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }, function(module, exports) {
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      if ('string' == typeof val)
        return parse(val);
      return options.long ? long(val) : short(val);
    };
    function parse(str) {
      str = '' + str;
      if (str.length > 10000)
        return;
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match)
        return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
      }
    }
    function short(ms) {
      if (ms >= d)
        return Math.round(ms / d) + 'd';
      if (ms >= h)
        return Math.round(ms / h) + 'h';
      if (ms >= m)
        return Math.round(ms / m) + 'm';
      if (ms >= s)
        return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    function long(ms) {
      return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
    }
    function plural(ms, n, name) {
      if (ms < n)
        return;
      if (ms < n * 1.5)
        return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
  }, function(module, exports, __webpack_require__) {
    (function(module, global) {
      var define = false;
      ;
      (function() {
        var isLoader = typeof define === "function" && define.amd;
        var objectTypes = {
          "function": true,
          "object": true
        };
        var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
        var root = objectTypes[typeof window] && window || this,
            freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
        if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
          root = freeGlobal;
        }
        function runInContext(context, exports) {
          context || (context = root["Object"]());
          exports || (exports = root["Object"]());
          var Number = context["Number"] || root["Number"],
              String = context["String"] || root["String"],
              Object = context["Object"] || root["Object"],
              Date = context["Date"] || root["Date"],
              SyntaxError = context["SyntaxError"] || root["SyntaxError"],
              TypeError = context["TypeError"] || root["TypeError"],
              Math = context["Math"] || root["Math"],
              nativeJSON = context["JSON"] || root["JSON"];
          if (typeof nativeJSON == "object" && nativeJSON) {
            exports.stringify = nativeJSON.stringify;
            exports.parse = nativeJSON.parse;
          }
          var objectProto = Object.prototype,
              getClass = objectProto.toString,
              isProperty,
              forEach,
              undef;
          var isExtended = new Date(-3509827334573292);
          try {
            isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
          } catch (exception) {}
          function has(name) {
            if (has[name] !== undef) {
              return has[name];
            }
            var isSupported;
            if (name == "bug-string-char-index") {
              isSupported = "a"[0] != "a";
            } else if (name == "json") {
              isSupported = has("json-stringify") && has("json-parse");
            } else {
              var value,
                  serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
              if (name == "json-stringify") {
                var stringify = exports.stringify,
                    stringifySupported = typeof stringify == "function" && isExtended;
                if (stringifySupported) {
                  (value = function() {
                    return 1;
                  }).toJSON = value;
                  try {
                    stringifySupported = stringify(0) === "0" && stringify(new Number()) === "0" && stringify(new String()) == '""' && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && stringify(value) === "1" && stringify([value]) == "[1]" && stringify([undef]) == "[null]" && stringify(null) == "null" && stringify([undef, getClass, null]) == "[null,null,null]" && stringify({"a": [value, true, false, null, "\x00\b\n\f\r\t"]}) == serialized && stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" && stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' && stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' && stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                  } catch (exception) {
                    stringifySupported = false;
                  }
                }
                isSupported = stringifySupported;
              }
              if (name == "json-parse") {
                var parse = exports.parse;
                if (typeof parse == "function") {
                  try {
                    if (parse("0") === 0 && !parse(false)) {
                      value = parse(serialized);
                      var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                      if (parseSupported) {
                        try {
                          parseSupported = !parse('"\t"');
                        } catch (exception) {}
                        if (parseSupported) {
                          try {
                            parseSupported = parse("01") !== 1;
                          } catch (exception) {}
                        }
                        if (parseSupported) {
                          try {
                            parseSupported = parse("1.") !== 1;
                          } catch (exception) {}
                        }
                      }
                    }
                  } catch (exception) {
                    parseSupported = false;
                  }
                }
                isSupported = parseSupported;
              }
            }
            return has[name] = !!isSupported;
          }
          if (!has("json")) {
            var functionClass = "[object Function]",
                dateClass = "[object Date]",
                numberClass = "[object Number]",
                stringClass = "[object String]",
                arrayClass = "[object Array]",
                booleanClass = "[object Boolean]";
            var charIndexBuggy = has("bug-string-char-index");
            if (!isExtended) {
              var floor = Math.floor;
              var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
              var getDay = function(year, month) {
                return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
              };
            }
            if (!(isProperty = objectProto.hasOwnProperty)) {
              isProperty = function(property) {
                var members = {},
                    constructor;
                if ((members.__proto__ = null, members.__proto__ = {"toString": 1}, members).toString != getClass) {
                  isProperty = function(property) {
                    var original = this.__proto__,
                        result = property in (this.__proto__ = null, this);
                    this.__proto__ = original;
                    return result;
                  };
                } else {
                  constructor = members.constructor;
                  isProperty = function(property) {
                    var parent = (this.constructor || constructor).prototype;
                    return property in this && !(property in parent && this[property] === parent[property]);
                  };
                }
                members = null;
                return isProperty.call(this, property);
              };
            }
            forEach = function(object, callback) {
              var size = 0,
                  Properties,
                  members,
                  property;
              (Properties = function() {
                this.valueOf = 0;
              }).prototype.valueOf = 0;
              members = new Properties();
              for (property in members) {
                if (isProperty.call(members, property)) {
                  size++;
                }
              }
              Properties = members = null;
              if (!size) {
                members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
                forEach = function(object, callback) {
                  var isFunction = getClass.call(object) == functionClass,
                      property,
                      length;
                  var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
                  for (property in object) {
                    if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                      callback(property);
                    }
                  }
                  for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property))
                    ;
                };
              } else if (size == 2) {
                forEach = function(object, callback) {
                  var members = {},
                      isFunction = getClass.call(object) == functionClass,
                      property;
                  for (property in object) {
                    if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                      callback(property);
                    }
                  }
                };
              } else {
                forEach = function(object, callback) {
                  var isFunction = getClass.call(object) == functionClass,
                      property,
                      isConstructor;
                  for (property in object) {
                    if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                      callback(property);
                    }
                  }
                  if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                    callback(property);
                  }
                };
              }
              return forEach(object, callback);
            };
            if (!has("json-stringify")) {
              var Escapes = {
                92: "\\\\",
                34: '\\"',
                8: "\\b",
                12: "\\f",
                10: "\\n",
                13: "\\r",
                9: "\\t"
              };
              var leadingZeroes = "000000";
              var toPaddedString = function(width, value) {
                return (leadingZeroes + (value || 0)).slice(-width);
              };
              var unicodePrefix = "\\u00";
              var quote = function(value) {
                var result = '"',
                    index = 0,
                    length = value.length,
                    useCharIndex = !charIndexBuggy || length > 10;
                var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
                for (; index < length; index++) {
                  var charCode = value.charCodeAt(index);
                  switch (charCode) {
                    case 8:
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 34:
                    case 92:
                      result += Escapes[charCode];
                      break;
                    default:
                      if (charCode < 32) {
                        result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                        break;
                      }
                      result += useCharIndex ? symbols[index] : value.charAt(index);
                  }
                }
                return result + '"';
              };
              var serialize = function(property, object, callback, properties, whitespace, indentation, stack) {
                var value,
                    className,
                    year,
                    month,
                    date,
                    time,
                    hours,
                    minutes,
                    seconds,
                    milliseconds,
                    results,
                    element,
                    index,
                    length,
                    prefix,
                    result;
                try {
                  value = object[property];
                } catch (exception) {}
                if (typeof value == "object" && value) {
                  className = getClass.call(value);
                  if (className == dateClass && !isProperty.call(value, "toJSON")) {
                    if (value > -1 / 0 && value < 1 / 0) {
                      if (getDay) {
                        date = floor(value / 864e5);
                        for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++)
                          ;
                        for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++)
                          ;
                        date = 1 + date - getDay(year, month);
                        time = (value % 864e5 + 864e5) % 864e5;
                        hours = floor(time / 36e5) % 24;
                        minutes = floor(time / 6e4) % 60;
                        seconds = floor(time / 1e3) % 60;
                        milliseconds = time % 1e3;
                      } else {
                        year = value.getUTCFullYear();
                        month = value.getUTCMonth();
                        date = value.getUTCDate();
                        hours = value.getUTCHours();
                        minutes = value.getUTCMinutes();
                        seconds = value.getUTCSeconds();
                        milliseconds = value.getUTCMilliseconds();
                      }
                      value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + "." + toPaddedString(3, milliseconds) + "Z";
                    } else {
                      value = null;
                    }
                  } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
                    value = value.toJSON(property);
                  }
                }
                if (callback) {
                  value = callback.call(object, property, value);
                }
                if (value === null) {
                  return "null";
                }
                className = getClass.call(value);
                if (className == booleanClass) {
                  return "" + value;
                } else if (className == numberClass) {
                  return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                } else if (className == stringClass) {
                  return quote("" + value);
                }
                if (typeof value == "object") {
                  for (length = stack.length; length--; ) {
                    if (stack[length] === value) {
                      throw TypeError();
                    }
                  }
                  stack.push(value);
                  results = [];
                  prefix = indentation;
                  indentation += whitespace;
                  if (className == arrayClass) {
                    for (index = 0, length = value.length; index < length; index++) {
                      element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                      results.push(element === undef ? "null" : element);
                    }
                    result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                  } else {
                    forEach(properties || value, function(property) {
                      var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                      if (element !== undef) {
                        results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                      }
                    });
                    result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                  }
                  stack.pop();
                  return result;
                }
              };
              exports.stringify = function(source, filter, width) {
                var whitespace,
                    callback,
                    properties,
                    className;
                if (objectTypes[typeof filter] && filter) {
                  if ((className = getClass.call(filter)) == functionClass) {
                    callback = filter;
                  } else if (className == arrayClass) {
                    properties = {};
                    for (var index = 0,
                        length = filter.length,
                        value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1))
                      ;
                  }
                }
                if (width) {
                  if ((className = getClass.call(width)) == numberClass) {
                    if ((width -= width % 1) > 0) {
                      for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ")
                        ;
                    }
                  } else if (className == stringClass) {
                    whitespace = width.length <= 10 ? width : width.slice(0, 10);
                  }
                }
                return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
              };
            }
            if (!has("json-parse")) {
              var fromCharCode = String.fromCharCode;
              var Unescapes = {
                92: "\\",
                34: '"',
                47: "/",
                98: "\b",
                116: "\t",
                110: "\n",
                102: "\f",
                114: "\r"
              };
              var Index,
                  Source;
              var abort = function() {
                Index = Source = null;
                throw SyntaxError();
              };
              var lex = function() {
                var source = Source,
                    length = source.length,
                    value,
                    begin,
                    position,
                    isSigned,
                    charCode;
                while (Index < length) {
                  charCode = source.charCodeAt(Index);
                  switch (charCode) {
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                      Index++;
                      break;
                    case 123:
                    case 125:
                    case 91:
                    case 93:
                    case 58:
                    case 44:
                      value = charIndexBuggy ? source.charAt(Index) : source[Index];
                      Index++;
                      return value;
                    case 34:
                      for (value = "@", Index++; Index < length; ) {
                        charCode = source.charCodeAt(Index);
                        if (charCode < 32) {
                          abort();
                        } else if (charCode == 92) {
                          charCode = source.charCodeAt(++Index);
                          switch (charCode) {
                            case 92:
                            case 34:
                            case 47:
                            case 98:
                            case 116:
                            case 110:
                            case 102:
                            case 114:
                              value += Unescapes[charCode];
                              Index++;
                              break;
                            case 117:
                              begin = ++Index;
                              for (position = Index + 4; Index < position; Index++) {
                                charCode = source.charCodeAt(Index);
                                if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                  abort();
                                }
                              }
                              value += fromCharCode("0x" + source.slice(begin, Index));
                              break;
                            default:
                              abort();
                          }
                        } else {
                          if (charCode == 34) {
                            break;
                          }
                          charCode = source.charCodeAt(Index);
                          begin = Index;
                          while (charCode >= 32 && charCode != 92 && charCode != 34) {
                            charCode = source.charCodeAt(++Index);
                          }
                          value += source.slice(begin, Index);
                        }
                      }
                      if (source.charCodeAt(Index) == 34) {
                        Index++;
                        return value;
                      }
                      abort();
                    default:
                      begin = Index;
                      if (charCode == 45) {
                        isSigned = true;
                        charCode = source.charCodeAt(++Index);
                      }
                      if (charCode >= 48 && charCode <= 57) {
                        if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                          abort();
                        }
                        isSigned = false;
                        for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++)
                          ;
                        if (source.charCodeAt(Index) == 46) {
                          position = ++Index;
                          for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++)
                            ;
                          if (position == Index) {
                            abort();
                          }
                          Index = position;
                        }
                        charCode = source.charCodeAt(Index);
                        if (charCode == 101 || charCode == 69) {
                          charCode = source.charCodeAt(++Index);
                          if (charCode == 43 || charCode == 45) {
                            Index++;
                          }
                          for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++)
                            ;
                          if (position == Index) {
                            abort();
                          }
                          Index = position;
                        }
                        return +source.slice(begin, Index);
                      }
                      if (isSigned) {
                        abort();
                      }
                      if (source.slice(Index, Index + 4) == "true") {
                        Index += 4;
                        return true;
                      } else if (source.slice(Index, Index + 5) == "false") {
                        Index += 5;
                        return false;
                      } else if (source.slice(Index, Index + 4) == "null") {
                        Index += 4;
                        return null;
                      }
                      abort();
                  }
                }
                return "$";
              };
              var get = function(value) {
                var results,
                    hasMembers;
                if (value == "$") {
                  abort();
                }
                if (typeof value == "string") {
                  if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                    return value.slice(1);
                  }
                  if (value == "[") {
                    results = [];
                    for (; ; hasMembers || (hasMembers = true)) {
                      value = lex();
                      if (value == "]") {
                        break;
                      }
                      if (hasMembers) {
                        if (value == ",") {
                          value = lex();
                          if (value == "]") {
                            abort();
                          }
                        } else {
                          abort();
                        }
                      }
                      if (value == ",") {
                        abort();
                      }
                      results.push(get(value));
                    }
                    return results;
                  } else if (value == "{") {
                    results = {};
                    for (; ; hasMembers || (hasMembers = true)) {
                      value = lex();
                      if (value == "}") {
                        break;
                      }
                      if (hasMembers) {
                        if (value == ",") {
                          value = lex();
                          if (value == "}") {
                            abort();
                          }
                        } else {
                          abort();
                        }
                      }
                      if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                        abort();
                      }
                      results[value.slice(1)] = get(lex());
                    }
                    return results;
                  }
                  abort();
                }
                return value;
              };
              var update = function(source, property, callback) {
                var element = walk(source, property, callback);
                if (element === undef) {
                  delete source[property];
                } else {
                  source[property] = element;
                }
              };
              var walk = function(source, property, callback) {
                var value = source[property],
                    length;
                if (typeof value == "object" && value) {
                  if (getClass.call(value) == arrayClass) {
                    for (length = value.length; length--; ) {
                      update(value, length, callback);
                    }
                  } else {
                    forEach(value, function(property) {
                      update(value, property, callback);
                    });
                  }
                }
                return callback.call(source, property, value);
              };
              exports.parse = function(source, callback) {
                var result,
                    value;
                Index = 0;
                Source = "" + source;
                result = get(lex());
                if (lex() != "$") {
                  abort();
                }
                Index = Source = null;
                return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
              };
            }
          }
          exports["runInContext"] = runInContext;
          return exports;
        }
        if (freeExports && !isLoader) {
          runInContext(root, freeExports);
        } else {
          var nativeJSON = root.JSON,
              previousJSON = root["JSON3"],
              isRestored = false;
          var JSON3 = runInContext(root, (root["JSON3"] = {"noConflict": function() {
              if (!isRestored) {
                isRestored = true;
                root.JSON = nativeJSON;
                root["JSON3"] = previousJSON;
                nativeJSON = previousJSON = null;
              }
              return JSON3;
            }}));
          root.JSON = {
            "parse": JSON3.parse,
            "stringify": JSON3.stringify
          };
        }
        if (isLoader) {
          define(function() {
            return JSON3;
          });
        }
      }).call(this);
    }.call(exports, __webpack_require__(12)(module), (function() {
      return this;
    }())));
  }, function(module, exports) {
    module.exports = function(module) {
      if (!module.webpackPolyfill) {
        module.deprecate = function() {};
        module.paths = [];
        module.children = [];
        module.webpackPolyfill = 1;
      }
      return module;
    };
  }, function(module, exports) {
    module.exports = Emitter;
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    ;
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks[event] = this._callbacks[event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      var self = this;
      this._callbacks = this._callbacks || {};
      function on() {
        self.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks[event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks[event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1),
          callbacks = this._callbacks[event];
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0,
            len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks[event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var isArray = __webpack_require__(15);
      var isBuf = __webpack_require__(16);
      exports.deconstructPacket = function(packet) {
        var buffers = [];
        var packetData = packet.data;
        function _deconstructPacket(data) {
          if (!data)
            return data;
          if (isBuf(data)) {
            var placeholder = {
              _placeholder: true,
              num: buffers.length
            };
            buffers.push(data);
            return placeholder;
          } else if (isArray(data)) {
            var newData = new Array(data.length);
            for (var i = 0; i < data.length; i++) {
              newData[i] = _deconstructPacket(data[i]);
            }
            return newData;
          } else if ('object' == typeof data && !(data instanceof Date)) {
            var newData = {};
            for (var key in data) {
              newData[key] = _deconstructPacket(data[key]);
            }
            return newData;
          }
          return data;
        }
        var pack = packet;
        pack.data = _deconstructPacket(packetData);
        pack.attachments = buffers.length;
        return {
          packet: pack,
          buffers: buffers
        };
      };
      exports.reconstructPacket = function(packet, buffers) {
        var curPlaceHolder = 0;
        function _reconstructPacket(data) {
          if (data && data._placeholder) {
            var buf = buffers[data.num];
            return buf;
          } else if (isArray(data)) {
            for (var i = 0; i < data.length; i++) {
              data[i] = _reconstructPacket(data[i]);
            }
            return data;
          } else if (data && 'object' == typeof data) {
            for (var key in data) {
              data[key] = _reconstructPacket(data[key]);
            }
            return data;
          }
          return data;
        }
        packet.data = _reconstructPacket(packet.data);
        packet.attachments = undefined;
        return packet;
      };
      exports.removeBlobs = function(data, callback) {
        function _removeBlobs(obj, curKey, containingObject) {
          if (!obj)
            return obj;
          if ((global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
            pendingBlobs++;
            var fileReader = new FileReader();
            fileReader.onload = function() {
              if (containingObject) {
                containingObject[curKey] = this.result;
              } else {
                bloblessData = this.result;
              }
              if (!--pendingBlobs) {
                callback(bloblessData);
              }
            };
            fileReader.readAsArrayBuffer(obj);
          } else if (isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
              _removeBlobs(obj[i], i, obj);
            }
          } else if (obj && 'object' == typeof obj && !isBuf(obj)) {
            for (var key in obj) {
              _removeBlobs(obj[key], key, obj);
            }
          }
        }
        var pendingBlobs = 0;
        var bloblessData = data;
        _removeBlobs(bloblessData);
        if (!pendingBlobs) {
          callback(bloblessData);
        }
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    module.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
  }, function(module, exports) {
    (function(global) {
      module.exports = isBuf;
      function isBuf(obj) {
        return (global.Buffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer);
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var eio = __webpack_require__(18);
    var Socket = __webpack_require__(44);
    var Emitter = __webpack_require__(35);
    var parser = __webpack_require__(7);
    var on = __webpack_require__(46);
    var bind = __webpack_require__(47);
    var debug = __webpack_require__(3)('socket.io-client:manager');
    var indexOf = __webpack_require__(42);
    var Backoff = __webpack_require__(48);
    var has = Object.prototype.hasOwnProperty;
    module.exports = Manager;
    function Manager(uri, opts) {
      if (!(this instanceof Manager))
        return new Manager(uri, opts);
      if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
        opts = uri;
        uri = undefined;
      }
      opts = opts || {};
      opts.path = opts.path || '/socket.io';
      this.nsps = {};
      this.subs = [];
      this.opts = opts;
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1000);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
      this.randomizationFactor(opts.randomizationFactor || 0.5);
      this.backoff = new Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 20000 : opts.timeout);
      this.readyState = 'closed';
      this.uri = uri;
      this.connecting = [];
      this.lastPing = null;
      this.encoding = false;
      this.packetBuffer = [];
      this.encoder = new parser.Encoder();
      this.decoder = new parser.Decoder();
      this.autoConnect = opts.autoConnect !== false;
      if (this.autoConnect)
        this.open();
    }
    Manager.prototype.emitAll = function() {
      this.emit.apply(this, arguments);
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }
      }
    };
    Manager.prototype.updateSocketIds = function() {
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].id = this.engine.id;
        }
      }
    };
    Emitter(Manager.prototype);
    Manager.prototype.reconnection = function(v) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v;
      return this;
    };
    Manager.prototype.reconnectionAttempts = function(v) {
      if (!arguments.length)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    };
    Manager.prototype.reconnectionDelay = function(v) {
      if (!arguments.length)
        return this._reconnectionDelay;
      this._reconnectionDelay = v;
      this.backoff && this.backoff.setMin(v);
      return this;
    };
    Manager.prototype.randomizationFactor = function(v) {
      if (!arguments.length)
        return this._randomizationFactor;
      this._randomizationFactor = v;
      this.backoff && this.backoff.setJitter(v);
      return this;
    };
    Manager.prototype.reconnectionDelayMax = function(v) {
      if (!arguments.length)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      this.backoff && this.backoff.setMax(v);
      return this;
    };
    Manager.prototype.timeout = function(v) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v;
      return this;
    };
    Manager.prototype.maybeReconnectOnOpen = function() {
      if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    };
    Manager.prototype.open = Manager.prototype.connect = function(fn, opts) {
      debug('readyState %s', this.readyState);
      if (~this.readyState.indexOf('open'))
        return this;
      debug('opening %s', this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this.readyState = 'opening';
      this.skipReconnect = false;
      var openSub = on(socket, 'open', function() {
        self.onopen();
        fn && fn();
      });
      var errorSub = on(socket, 'error', function(data) {
        debug('connect_error');
        self.cleanup();
        self.readyState = 'closed';
        self.emitAll('connect_error', data);
        if (fn) {
          var err = new Error('Connection error');
          err.data = data;
          fn(err);
        } else {
          self.maybeReconnectOnOpen();
        }
      });
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug('connect attempt will timeout after %d', timeout);
        var timer = setTimeout(function() {
          debug('connect attempt timed out after %d', timeout);
          openSub.destroy();
          socket.close();
          socket.emit('error', 'timeout');
          self.emitAll('connect_timeout', timeout);
        }, timeout);
        this.subs.push({destroy: function destroy() {
            clearTimeout(timer);
          }});
      }
      this.subs.push(openSub);
      this.subs.push(errorSub);
      return this;
    };
    Manager.prototype.onopen = function() {
      debug('open');
      this.cleanup();
      this.readyState = 'open';
      this.emit('open');
      var socket = this.engine;
      this.subs.push(on(socket, 'data', bind(this, 'ondata')));
      this.subs.push(on(socket, 'ping', bind(this, 'onping')));
      this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
      this.subs.push(on(socket, 'error', bind(this, 'onerror')));
      this.subs.push(on(socket, 'close', bind(this, 'onclose')));
      this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
    };
    Manager.prototype.onping = function() {
      this.lastPing = new Date();
      this.emitAll('ping');
    };
    Manager.prototype.onpong = function() {
      this.emitAll('pong', new Date() - this.lastPing);
    };
    Manager.prototype.ondata = function(data) {
      this.decoder.add(data);
    };
    Manager.prototype.ondecoded = function(packet) {
      this.emit('packet', packet);
    };
    Manager.prototype.onerror = function(err) {
      debug('error', err);
      this.emitAll('error', err);
    };
    Manager.prototype.socket = function(nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
        var self = this;
        socket.on('connecting', onConnecting);
        socket.on('connect', function() {
          socket.id = self.engine.id;
        });
        if (this.autoConnect) {
          onConnecting();
        }
      }
      function onConnecting() {
        if (!~indexOf(self.connecting, socket)) {
          self.connecting.push(socket);
        }
      }
      return socket;
    };
    Manager.prototype.destroy = function(socket) {
      var index = indexOf(this.connecting, socket);
      if (~index)
        this.connecting.splice(index, 1);
      if (this.connecting.length)
        return;
      this.close();
    };
    Manager.prototype.packet = function(packet) {
      debug('writing packet %j', packet);
      var self = this;
      if (packet.query && packet.type === 0)
        packet.nsp += '?' + packet.query;
      if (!self.encoding) {
        self.encoding = true;
        this.encoder.encode(packet, function(encodedPackets) {
          for (var i = 0; i < encodedPackets.length; i++) {
            self.engine.write(encodedPackets[i], packet.options);
          }
          self.encoding = false;
          self.processPacketQueue();
        });
      } else {
        self.packetBuffer.push(packet);
      }
    };
    Manager.prototype.processPacketQueue = function() {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var pack = this.packetBuffer.shift();
        this.packet(pack);
      }
    };
    Manager.prototype.cleanup = function() {
      debug('cleanup');
      var subsLength = this.subs.length;
      for (var i = 0; i < subsLength; i++) {
        var sub = this.subs.shift();
        sub.destroy();
      }
      this.packetBuffer = [];
      this.encoding = false;
      this.lastPing = null;
      this.decoder.destroy();
    };
    Manager.prototype.close = Manager.prototype.disconnect = function() {
      debug('disconnect');
      this.skipReconnect = true;
      this.reconnecting = false;
      if ('opening' === this.readyState) {
        this.cleanup();
      }
      this.backoff.reset();
      this.readyState = 'closed';
      if (this.engine)
        this.engine.close();
    };
    Manager.prototype.onclose = function(reason) {
      debug('onclose');
      this.cleanup();
      this.backoff.reset();
      this.readyState = 'closed';
      this.emit('close', reason);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    };
    Manager.prototype.reconnect = function() {
      if (this.reconnecting || this.skipReconnect)
        return this;
      var self = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug('reconnect failed');
        this.backoff.reset();
        this.emitAll('reconnect_failed');
        this.reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug('will wait %dms before reconnect attempt', delay);
        this.reconnecting = true;
        var timer = setTimeout(function() {
          if (self.skipReconnect)
            return;
          debug('attempting reconnect');
          self.emitAll('reconnect_attempt', self.backoff.attempts);
          self.emitAll('reconnecting', self.backoff.attempts);
          if (self.skipReconnect)
            return;
          self.open(function(err) {
            if (err) {
              debug('reconnect attempt error');
              self.reconnecting = false;
              self.reconnect();
              self.emitAll('reconnect_error', err.data);
            } else {
              debug('reconnect success');
              self.onreconnect();
            }
          });
        }, delay);
        this.subs.push({destroy: function destroy() {
            clearTimeout(timer);
          }});
      }
    };
    Manager.prototype.onreconnect = function() {
      var attempt = this.backoff.attempts;
      this.reconnecting = false;
      this.backoff.reset();
      this.updateSocketIds();
      this.emitAll('reconnect', attempt);
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(19);
  }, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(20);
    module.exports.parser = __webpack_require__(27);
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var transports = __webpack_require__(21);
      var Emitter = __webpack_require__(35);
      var debug = __webpack_require__(3)('engine.io-client:socket');
      var index = __webpack_require__(42);
      var parser = __webpack_require__(27);
      var parseuri = __webpack_require__(2);
      var parsejson = __webpack_require__(43);
      var parseqs = __webpack_require__(36);
      module.exports = Socket;
      function Socket(uri, opts) {
        if (!(this instanceof Socket))
          return new Socket(uri, opts);
        opts = opts || {};
        if (uri && 'object' === typeof uri) {
          opts = uri;
          uri = null;
        }
        if (uri) {
          uri = parseuri(uri);
          opts.hostname = uri.host;
          opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
          opts.port = uri.port;
          if (uri.query)
            opts.query = uri.query;
        } else if (opts.host) {
          opts.hostname = parseuri(opts.host).host;
        }
        this.secure = null != opts.secure ? opts.secure : (global.location && 'https:' === location.protocol);
        if (opts.hostname && !opts.port) {
          opts.port = this.secure ? '443' : '80';
        }
        this.agent = opts.agent || false;
        this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
        this.port = opts.port || (global.location && location.port ? location.port : (this.secure ? 443 : 80));
        this.query = opts.query || {};
        if ('string' === typeof this.query)
          this.query = parseqs.decode(this.query);
        this.upgrade = false !== opts.upgrade;
        this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
        this.forceJSONP = !!opts.forceJSONP;
        this.jsonp = false !== opts.jsonp;
        this.forceBase64 = !!opts.forceBase64;
        this.enablesXDR = !!opts.enablesXDR;
        this.timestampParam = opts.timestampParam || 't';
        this.timestampRequests = opts.timestampRequests;
        this.transports = opts.transports || ['polling', 'websocket'];
        this.readyState = '';
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.policyPort = opts.policyPort || 843;
        this.rememberUpgrade = opts.rememberUpgrade || false;
        this.binaryType = null;
        this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
        this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;
        if (true === this.perMessageDeflate)
          this.perMessageDeflate = {};
        if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
          this.perMessageDeflate.threshold = 1024;
        }
        this.pfx = opts.pfx || null;
        this.key = opts.key || null;
        this.passphrase = opts.passphrase || null;
        this.cert = opts.cert || null;
        this.ca = opts.ca || null;
        this.ciphers = opts.ciphers || null;
        this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;
        this.forceNode = !!opts.forceNode;
        var freeGlobal = typeof global === 'object' && global;
        if (freeGlobal.global === freeGlobal) {
          if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
            this.extraHeaders = opts.extraHeaders;
          }
          if (opts.localAddress) {
            this.localAddress = opts.localAddress;
          }
        }
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        this.pingIntervalTimer = null;
        this.pingTimeoutTimer = null;
        this.open();
      }
      Socket.priorWebsocketSuccess = false;
      Emitter(Socket.prototype);
      Socket.protocol = parser.protocol;
      Socket.Socket = Socket;
      Socket.Transport = __webpack_require__(26);
      Socket.transports = __webpack_require__(21);
      Socket.parser = __webpack_require__(27);
      Socket.prototype.createTransport = function(name) {
        debug('creating transport "%s"', name);
        var query = clone(this.query);
        query.EIO = parser.protocol;
        query.transport = name;
        if (this.id)
          query.sid = this.id;
        var transport = new transports[name]({
          agent: this.agent,
          hostname: this.hostname,
          port: this.port,
          secure: this.secure,
          path: this.path,
          query: query,
          forceJSONP: this.forceJSONP,
          jsonp: this.jsonp,
          forceBase64: this.forceBase64,
          enablesXDR: this.enablesXDR,
          timestampRequests: this.timestampRequests,
          timestampParam: this.timestampParam,
          policyPort: this.policyPort,
          socket: this,
          pfx: this.pfx,
          key: this.key,
          passphrase: this.passphrase,
          cert: this.cert,
          ca: this.ca,
          ciphers: this.ciphers,
          rejectUnauthorized: this.rejectUnauthorized,
          perMessageDeflate: this.perMessageDeflate,
          extraHeaders: this.extraHeaders,
          forceNode: this.forceNode,
          localAddress: this.localAddress
        });
        return transport;
      };
      function clone(obj) {
        var o = {};
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            o[i] = obj[i];
          }
        }
        return o;
      }
      Socket.prototype.open = function() {
        var transport;
        if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
          transport = 'websocket';
        } else if (0 === this.transports.length) {
          var self = this;
          setTimeout(function() {
            self.emit('error', 'No transports available');
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }
        this.readyState = 'opening';
        try {
          transport = this.createTransport(transport);
        } catch (e) {
          this.transports.shift();
          this.open();
          return;
        }
        transport.open();
        this.setTransport(transport);
      };
      Socket.prototype.setTransport = function(transport) {
        debug('setting transport %s', transport.name);
        var self = this;
        if (this.transport) {
          debug('clearing existing transport %s', this.transport.name);
          this.transport.removeAllListeners();
        }
        this.transport = transport;
        transport.on('drain', function() {
          self.onDrain();
        }).on('packet', function(packet) {
          self.onPacket(packet);
        }).on('error', function(e) {
          self.onError(e);
        }).on('close', function() {
          self.onClose('transport close');
        });
      };
      Socket.prototype.probe = function(name) {
        debug('probing transport "%s"', name);
        var transport = this.createTransport(name, {probe: 1});
        var failed = false;
        var self = this;
        Socket.priorWebsocketSuccess = false;
        function onTransportOpen() {
          if (self.onlyBinaryUpgrades) {
            var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
            failed = failed || upgradeLosesBinary;
          }
          if (failed)
            return;
          debug('probe transport "%s" opened', name);
          transport.send([{
            type: 'ping',
            data: 'probe'
          }]);
          transport.once('packet', function(msg) {
            if (failed)
              return;
            if ('pong' === msg.type && 'probe' === msg.data) {
              debug('probe transport "%s" pong', name);
              self.upgrading = true;
              self.emit('upgrading', transport);
              if (!transport)
                return;
              Socket.priorWebsocketSuccess = 'websocket' === transport.name;
              debug('pausing current transport "%s"', self.transport.name);
              self.transport.pause(function() {
                if (failed)
                  return;
                if ('closed' === self.readyState)
                  return;
                debug('changing transport and sending upgrade packet');
                cleanup();
                self.setTransport(transport);
                transport.send([{type: 'upgrade'}]);
                self.emit('upgrade', transport);
                transport = null;
                self.upgrading = false;
                self.flush();
              });
            } else {
              debug('probe transport "%s" failed', name);
              var err = new Error('probe error');
              err.transport = transport.name;
              self.emit('upgradeError', err);
            }
          });
        }
        function freezeTransport() {
          if (failed)
            return;
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }
        function onerror(err) {
          var error = new Error('probe error: ' + err);
          error.transport = transport.name;
          freezeTransport();
          debug('probe transport "%s" failed because of error: %s', name, err);
          self.emit('upgradeError', error);
        }
        function onTransportClose() {
          onerror('transport closed');
        }
        function onclose() {
          onerror('socket closed');
        }
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            debug('"%s" works - aborting "%s"', to.name, transport.name);
            freezeTransport();
          }
        }
        function cleanup() {
          transport.removeListener('open', onTransportOpen);
          transport.removeListener('error', onerror);
          transport.removeListener('close', onTransportClose);
          self.removeListener('close', onclose);
          self.removeListener('upgrading', onupgrade);
        }
        transport.once('open', onTransportOpen);
        transport.once('error', onerror);
        transport.once('close', onTransportClose);
        this.once('close', onclose);
        this.once('upgrading', onupgrade);
        transport.open();
      };
      Socket.prototype.onOpen = function() {
        debug('socket open');
        this.readyState = 'open';
        Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
        this.emit('open');
        this.flush();
        if ('open' === this.readyState && this.upgrade && this.transport.pause) {
          debug('starting upgrade probes');
          for (var i = 0,
              l = this.upgrades.length; i < l; i++) {
            this.probe(this.upgrades[i]);
          }
        }
      };
      Socket.prototype.onPacket = function(packet) {
        if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
          debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
          this.emit('packet', packet);
          this.emit('heartbeat');
          switch (packet.type) {
            case 'open':
              this.onHandshake(parsejson(packet.data));
              break;
            case 'pong':
              this.setPing();
              this.emit('pong');
              break;
            case 'error':
              var err = new Error('server error');
              err.code = packet.data;
              this.onError(err);
              break;
            case 'message':
              this.emit('data', packet.data);
              this.emit('message', packet.data);
              break;
          }
        } else {
          debug('packet received with socket readyState "%s"', this.readyState);
        }
      };
      Socket.prototype.onHandshake = function(data) {
        this.emit('handshake', data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.onOpen();
        if ('closed' === this.readyState)
          return;
        this.setPing();
        this.removeListener('heartbeat', this.onHeartbeat);
        this.on('heartbeat', this.onHeartbeat);
      };
      Socket.prototype.onHeartbeat = function(timeout) {
        clearTimeout(this.pingTimeoutTimer);
        var self = this;
        self.pingTimeoutTimer = setTimeout(function() {
          if ('closed' === self.readyState)
            return;
          self.onClose('ping timeout');
        }, timeout || (self.pingInterval + self.pingTimeout));
      };
      Socket.prototype.setPing = function() {
        var self = this;
        clearTimeout(self.pingIntervalTimer);
        self.pingIntervalTimer = setTimeout(function() {
          debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
          self.ping();
          self.onHeartbeat(self.pingTimeout);
        }, self.pingInterval);
      };
      Socket.prototype.ping = function() {
        var self = this;
        this.sendPacket('ping', function() {
          self.emit('ping');
        });
      };
      Socket.prototype.onDrain = function() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
          this.emit('drain');
        } else {
          this.flush();
        }
      };
      Socket.prototype.flush = function() {
        if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          debug('flushing %d packets in socket', this.writeBuffer.length);
          this.transport.send(this.writeBuffer);
          this.prevBufferLen = this.writeBuffer.length;
          this.emit('flush');
        }
      };
      Socket.prototype.write = Socket.prototype.send = function(msg, options, fn) {
        this.sendPacket('message', msg, options, fn);
        return this;
      };
      Socket.prototype.sendPacket = function(type, data, options, fn) {
        if ('function' === typeof data) {
          fn = data;
          data = undefined;
        }
        if ('function' === typeof options) {
          fn = options;
          options = null;
        }
        if ('closing' === this.readyState || 'closed' === this.readyState) {
          return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        var packet = {
          type: type,
          data: data,
          options: options
        };
        this.emit('packetCreate', packet);
        this.writeBuffer.push(packet);
        if (fn)
          this.once('flush', fn);
        this.flush();
      };
      Socket.prototype.close = function() {
        if ('opening' === this.readyState || 'open' === this.readyState) {
          this.readyState = 'closing';
          var self = this;
          if (this.writeBuffer.length) {
            this.once('drain', function() {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }
        function close() {
          self.onClose('forced close');
          debug('socket closing - telling transport to close');
          self.transport.close();
        }
        function cleanupAndClose() {
          self.removeListener('upgrade', cleanupAndClose);
          self.removeListener('upgradeError', cleanupAndClose);
          close();
        }
        function waitForUpgrade() {
          self.once('upgrade', cleanupAndClose);
          self.once('upgradeError', cleanupAndClose);
        }
        return this;
      };
      Socket.prototype.onError = function(err) {
        debug('socket error %j', err);
        Socket.priorWebsocketSuccess = false;
        this.emit('error', err);
        this.onClose('transport error', err);
      };
      Socket.prototype.onClose = function(reason, desc) {
        if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
          debug('socket close with reason: "%s"', reason);
          var self = this;
          clearTimeout(this.pingIntervalTimer);
          clearTimeout(this.pingTimeoutTimer);
          this.transport.removeAllListeners('close');
          this.transport.close();
          this.transport.removeAllListeners();
          this.readyState = 'closed';
          this.id = null;
          this.emit('close', reason, desc);
          self.writeBuffer = [];
          self.prevBufferLen = 0;
        }
      };
      Socket.prototype.filterUpgrades = function(upgrades) {
        var filteredUpgrades = [];
        for (var i = 0,
            j = upgrades.length; i < j; i++) {
          if (~index(this.transports, upgrades[i]))
            filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var XMLHttpRequest = __webpack_require__(22);
      var XHR = __webpack_require__(24);
      var JSONP = __webpack_require__(39);
      var websocket = __webpack_require__(40);
      exports.polling = polling;
      exports.websocket = websocket;
      function polling(opts) {
        var xhr;
        var xd = false;
        var xs = false;
        var jsonp = false !== opts.jsonp;
        if (global.location) {
          var isSSL = 'https:' === location.protocol;
          var port = location.port;
          if (!port) {
            port = isSSL ? 443 : 80;
          }
          xd = opts.hostname !== location.hostname || port !== opts.port;
          xs = opts.secure !== isSSL;
        }
        opts.xdomain = xd;
        opts.xscheme = xs;
        xhr = new XMLHttpRequest(opts);
        if ('open' in xhr && !opts.forceJSONP) {
          return new XHR(opts);
        } else {
          if (!jsonp)
            throw new Error('JSONP disabled');
          return new JSONP(opts);
        }
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var hasCORS = __webpack_require__(23);
      module.exports = function(opts) {
        var xdomain = opts.xdomain;
        var xscheme = opts.xscheme;
        var enablesXDR = opts.enablesXDR;
        try {
          if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
            return new XMLHttpRequest();
          }
        } catch (e) {}
        try {
          if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
            return new XDomainRequest();
          }
        } catch (e) {}
        if (!xdomain) {
          try {
            return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
          } catch (e) {}
        }
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    try {
      module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
    } catch (err) {
      module.exports = false;
    }
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var XMLHttpRequest = __webpack_require__(22);
      var Polling = __webpack_require__(25);
      var Emitter = __webpack_require__(35);
      var inherit = __webpack_require__(37);
      var debug = __webpack_require__(3)('engine.io-client:polling-xhr');
      module.exports = XHR;
      module.exports.Request = Request;
      function empty() {}
      function XHR(opts) {
        Polling.call(this, opts);
        this.requestTimeout = opts.requestTimeout;
        if (global.location) {
          var isSSL = 'https:' === location.protocol;
          var port = location.port;
          if (!port) {
            port = isSSL ? 443 : 80;
          }
          this.xd = opts.hostname !== global.location.hostname || port !== opts.port;
          this.xs = opts.secure !== isSSL;
        } else {
          this.extraHeaders = opts.extraHeaders;
        }
      }
      inherit(XHR, Polling);
      XHR.prototype.supportsBinary = true;
      XHR.prototype.request = function(opts) {
        opts = opts || {};
        opts.uri = this.uri();
        opts.xd = this.xd;
        opts.xs = this.xs;
        opts.agent = this.agent || false;
        opts.supportsBinary = this.supportsBinary;
        opts.enablesXDR = this.enablesXDR;
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        opts.requestTimeout = this.requestTimeout;
        opts.extraHeaders = this.extraHeaders;
        return new Request(opts);
      };
      XHR.prototype.doWrite = function(data, fn) {
        var isBinary = typeof data !== 'string' && data !== undefined;
        var req = this.request({
          method: 'POST',
          data: data,
          isBinary: isBinary
        });
        var self = this;
        req.on('success', fn);
        req.on('error', function(err) {
          self.onError('xhr post error', err);
        });
        this.sendXhr = req;
      };
      XHR.prototype.doPoll = function() {
        debug('xhr poll');
        var req = this.request();
        var self = this;
        req.on('data', function(data) {
          self.onData(data);
        });
        req.on('error', function(err) {
          self.onError('xhr poll error', err);
        });
        this.pollXhr = req;
      };
      function Request(opts) {
        this.method = opts.method || 'GET';
        this.uri = opts.uri;
        this.xd = !!opts.xd;
        this.xs = !!opts.xs;
        this.async = false !== opts.async;
        this.data = undefined !== opts.data ? opts.data : null;
        this.agent = opts.agent;
        this.isBinary = opts.isBinary;
        this.supportsBinary = opts.supportsBinary;
        this.enablesXDR = opts.enablesXDR;
        this.requestTimeout = opts.requestTimeout;
        this.pfx = opts.pfx;
        this.key = opts.key;
        this.passphrase = opts.passphrase;
        this.cert = opts.cert;
        this.ca = opts.ca;
        this.ciphers = opts.ciphers;
        this.rejectUnauthorized = opts.rejectUnauthorized;
        this.extraHeaders = opts.extraHeaders;
        this.create();
      }
      Emitter(Request.prototype);
      Request.prototype.create = function() {
        var opts = {
          agent: this.agent,
          xdomain: this.xd,
          xscheme: this.xs,
          enablesXDR: this.enablesXDR
        };
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        var xhr = this.xhr = new XMLHttpRequest(opts);
        var self = this;
        try {
          debug('xhr open %s: %s', this.method, this.uri);
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.extraHeaders) {
              xhr.setDisableHeaderCheck(true);
              for (var i in this.extraHeaders) {
                if (this.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this.extraHeaders[i]);
                }
              }
            }
          } catch (e) {}
          if (this.supportsBinary) {
            xhr.responseType = 'arraybuffer';
          }
          if ('POST' === this.method) {
            try {
              if (this.isBinary) {
                xhr.setRequestHeader('Content-type', 'application/octet-stream');
              } else {
                xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
              }
            } catch (e) {}
          }
          try {
            xhr.setRequestHeader('Accept', '*/*');
          } catch (e) {}
          if ('withCredentials' in xhr) {
            xhr.withCredentials = true;
          }
          if (this.requestTimeout) {
            xhr.timeout = this.requestTimeout;
          }
          if (this.hasXDR()) {
            xhr.onload = function() {
              self.onLoad();
            };
            xhr.onerror = function() {
              self.onError(xhr.responseText);
            };
          } else {
            xhr.onreadystatechange = function() {
              if (4 !== xhr.readyState)
                return;
              if (200 === xhr.status || 1223 === xhr.status) {
                self.onLoad();
              } else {
                setTimeout(function() {
                  self.onError(xhr.status);
                }, 0);
              }
            };
          }
          debug('xhr data %s', this.data);
          xhr.send(this.data);
        } catch (e) {
          setTimeout(function() {
            self.onError(e);
          }, 0);
          return;
        }
        if (global.document) {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      };
      Request.prototype.onSuccess = function() {
        this.emit('success');
        this.cleanup();
      };
      Request.prototype.onData = function(data) {
        this.emit('data', data);
        this.onSuccess();
      };
      Request.prototype.onError = function(err) {
        this.emit('error', err);
        this.cleanup(true);
      };
      Request.prototype.cleanup = function(fromError) {
        if ('undefined' === typeof this.xhr || null === this.xhr) {
          return;
        }
        if (this.hasXDR()) {
          this.xhr.onload = this.xhr.onerror = empty;
        } else {
          this.xhr.onreadystatechange = empty;
        }
        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e) {}
        }
        if (global.document) {
          delete Request.requests[this.index];
        }
        this.xhr = null;
      };
      Request.prototype.onLoad = function() {
        var data;
        try {
          var contentType;
          try {
            contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
          } catch (e) {}
          if (contentType === 'application/octet-stream') {
            data = this.xhr.response || this.xhr.responseText;
          } else {
            if (!this.supportsBinary) {
              data = this.xhr.responseText;
            } else {
              try {
                data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
              } catch (e) {
                var ui8Arr = new Uint8Array(this.xhr.response);
                var dataArray = [];
                for (var idx = 0,
                    length = ui8Arr.length; idx < length; idx++) {
                  dataArray.push(ui8Arr[idx]);
                }
                data = String.fromCharCode.apply(null, dataArray);
              }
            }
          }
        } catch (e) {
          this.onError(e);
        }
        if (null != data) {
          this.onData(data);
        }
      };
      Request.prototype.hasXDR = function() {
        return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
      };
      Request.prototype.abort = function() {
        this.cleanup();
      };
      Request.requestsCount = 0;
      Request.requests = {};
      if (global.document) {
        if (global.attachEvent) {
          global.attachEvent('onunload', unloadHandler);
        } else if (global.addEventListener) {
          global.addEventListener('beforeunload', unloadHandler, false);
        }
      }
      function unloadHandler() {
        for (var i in Request.requests) {
          if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
          }
        }
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    var Transport = __webpack_require__(26);
    var parseqs = __webpack_require__(36);
    var parser = __webpack_require__(27);
    var inherit = __webpack_require__(37);
    var yeast = __webpack_require__(38);
    var debug = __webpack_require__(3)('engine.io-client:polling');
    module.exports = Polling;
    var hasXHR2 = (function() {
      var XMLHttpRequest = __webpack_require__(22);
      var xhr = new XMLHttpRequest({xdomain: false});
      return null != xhr.responseType;
    })();
    function Polling(opts) {
      var forceBase64 = (opts && opts.forceBase64);
      if (!hasXHR2 || forceBase64) {
        this.supportsBinary = false;
      }
      Transport.call(this, opts);
    }
    inherit(Polling, Transport);
    Polling.prototype.name = 'polling';
    Polling.prototype.doOpen = function() {
      this.poll();
    };
    Polling.prototype.pause = function(onPause) {
      var self = this;
      this.readyState = 'pausing';
      function pause() {
        debug('paused');
        self.readyState = 'paused';
        onPause();
      }
      if (this.polling || !this.writable) {
        var total = 0;
        if (this.polling) {
          debug('we are currently polling - waiting to pause');
          total++;
          this.once('pollComplete', function() {
            debug('pre-pause polling complete');
            --total || pause();
          });
        }
        if (!this.writable) {
          debug('we are currently writing - waiting to pause');
          total++;
          this.once('drain', function() {
            debug('pre-pause writing complete');
            --total || pause();
          });
        }
      } else {
        pause();
      }
    };
    Polling.prototype.poll = function() {
      debug('polling');
      this.polling = true;
      this.doPoll();
      this.emit('poll');
    };
    Polling.prototype.onData = function(data) {
      var self = this;
      debug('polling got data %s', data);
      var callback = function(packet, index, total) {
        if ('opening' === self.readyState) {
          self.onOpen();
        }
        if ('close' === packet.type) {
          self.onClose();
          return false;
        }
        self.onPacket(packet);
      };
      parser.decodePayload(data, this.socket.binaryType, callback);
      if ('closed' !== this.readyState) {
        this.polling = false;
        this.emit('pollComplete');
        if ('open' === this.readyState) {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    };
    Polling.prototype.doClose = function() {
      var self = this;
      function close() {
        debug('writing close packet');
        self.write([{type: 'close'}]);
      }
      if ('open' === this.readyState) {
        debug('transport open - closing');
        close();
      } else {
        debug('transport not open - deferring close');
        this.once('open', close);
      }
    };
    Polling.prototype.write = function(packets) {
      var self = this;
      this.writable = false;
      var callbackfn = function() {
        self.writable = true;
        self.emit('drain');
      };
      parser.encodePayload(packets, this.supportsBinary, function(data) {
        self.doWrite(data, callbackfn);
      });
    };
    Polling.prototype.uri = function() {
      var query = this.query || {};
      var schema = this.secure ? 'https' : 'http';
      var port = '';
      if (false !== this.timestampRequests) {
        query[this.timestampParam] = yeast();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (this.port && (('https' === schema && Number(this.port) !== 443) || ('http' === schema && Number(this.port) !== 80))) {
        port = ':' + this.port;
      }
      if (query.length) {
        query = '?' + query;
      }
      var ipv6 = this.hostname.indexOf(':') !== -1;
      return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
    };
  }, function(module, exports, __webpack_require__) {
    var parser = __webpack_require__(27);
    var Emitter = __webpack_require__(35);
    module.exports = Transport;
    function Transport(opts) {
      this.path = opts.path;
      this.hostname = opts.hostname;
      this.port = opts.port;
      this.secure = opts.secure;
      this.query = opts.query;
      this.timestampParam = opts.timestampParam;
      this.timestampRequests = opts.timestampRequests;
      this.readyState = '';
      this.agent = opts.agent || false;
      this.socket = opts.socket;
      this.enablesXDR = opts.enablesXDR;
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.forceNode = opts.forceNode;
      this.extraHeaders = opts.extraHeaders;
      this.localAddress = opts.localAddress;
    }
    Emitter(Transport.prototype);
    Transport.prototype.onError = function(msg, desc) {
      var err = new Error(msg);
      err.type = 'TransportError';
      err.description = desc;
      this.emit('error', err);
      return this;
    };
    Transport.prototype.open = function() {
      if ('closed' === this.readyState || '' === this.readyState) {
        this.readyState = 'opening';
        this.doOpen();
      }
      return this;
    };
    Transport.prototype.close = function() {
      if ('opening' === this.readyState || 'open' === this.readyState) {
        this.doClose();
        this.onClose();
      }
      return this;
    };
    Transport.prototype.send = function(packets) {
      if ('open' === this.readyState) {
        this.write(packets);
      } else {
        throw new Error('Transport not open');
      }
    };
    Transport.prototype.onOpen = function() {
      this.readyState = 'open';
      this.writable = true;
      this.emit('open');
    };
    Transport.prototype.onData = function(data) {
      var packet = parser.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    };
    Transport.prototype.onPacket = function(packet) {
      this.emit('packet', packet);
    };
    Transport.prototype.onClose = function() {
      this.readyState = 'closed';
      this.emit('close');
    };
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var keys = __webpack_require__(28);
      var hasBinary = __webpack_require__(29);
      var sliceBuffer = __webpack_require__(30);
      var after = __webpack_require__(31);
      var utf8 = __webpack_require__(32);
      var base64encoder;
      if (global && global.ArrayBuffer) {
        base64encoder = __webpack_require__(33);
      }
      var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
      var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);
      var dontSendBlobs = isAndroid || isPhantomJS;
      exports.protocol = 3;
      var packets = exports.packets = {
        open: 0,
        close: 1,
        ping: 2,
        pong: 3,
        message: 4,
        upgrade: 5,
        noop: 6
      };
      var packetslist = keys(packets);
      var err = {
        type: 'error',
        data: 'parser error'
      };
      var Blob = __webpack_require__(34);
      exports.encodePacket = function(packet, supportsBinary, utf8encode, callback) {
        if ('function' == typeof supportsBinary) {
          callback = supportsBinary;
          supportsBinary = false;
        }
        if ('function' == typeof utf8encode) {
          callback = utf8encode;
          utf8encode = null;
        }
        var data = (packet.data === undefined) ? undefined : packet.data.buffer || packet.data;
        if (global.ArrayBuffer && data instanceof ArrayBuffer) {
          return encodeArrayBuffer(packet, supportsBinary, callback);
        } else if (Blob && data instanceof global.Blob) {
          return encodeBlob(packet, supportsBinary, callback);
        }
        if (data && data.base64) {
          return encodeBase64Object(packet, callback);
        }
        var encoded = packets[packet.type];
        if (undefined !== packet.data) {
          encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
        }
        return callback('' + encoded);
      };
      function encodeBase64Object(packet, callback) {
        var message = 'b' + exports.packets[packet.type] + packet.data.data;
        return callback(message);
      }
      function encodeArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        var data = packet.data;
        var contentArray = new Uint8Array(data);
        var resultBuffer = new Uint8Array(1 + data.byteLength);
        resultBuffer[0] = packets[packet.type];
        for (var i = 0; i < contentArray.length; i++) {
          resultBuffer[i + 1] = contentArray[i];
        }
        return callback(resultBuffer.buffer);
      }
      function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        var fr = new FileReader();
        fr.onload = function() {
          packet.data = fr.result;
          exports.encodePacket(packet, supportsBinary, true, callback);
        };
        return fr.readAsArrayBuffer(packet.data);
      }
      function encodeBlob(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        if (dontSendBlobs) {
          return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
        }
        var length = new Uint8Array(1);
        length[0] = packets[packet.type];
        var blob = new Blob([length.buffer, packet.data]);
        return callback(blob);
      }
      exports.encodeBase64Packet = function(packet, callback) {
        var message = 'b' + exports.packets[packet.type];
        if (Blob && packet.data instanceof global.Blob) {
          var fr = new FileReader();
          fr.onload = function() {
            var b64 = fr.result.split(',')[1];
            callback(message + b64);
          };
          return fr.readAsDataURL(packet.data);
        }
        var b64data;
        try {
          b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
        } catch (e) {
          var typed = new Uint8Array(packet.data);
          var basic = new Array(typed.length);
          for (var i = 0; i < typed.length; i++) {
            basic[i] = typed[i];
          }
          b64data = String.fromCharCode.apply(null, basic);
        }
        message += global.btoa(b64data);
        return callback(message);
      };
      exports.decodePacket = function(data, binaryType, utf8decode) {
        if (data === undefined) {
          return err;
        }
        if (typeof data == 'string') {
          if (data.charAt(0) == 'b') {
            return exports.decodeBase64Packet(data.substr(1), binaryType);
          }
          if (utf8decode) {
            data = tryDecode(data);
            if (data === false) {
              return err;
            }
          }
          var type = data.charAt(0);
          if (Number(type) != type || !packetslist[type]) {
            return err;
          }
          if (data.length > 1) {
            return {
              type: packetslist[type],
              data: data.substring(1)
            };
          } else {
            return {type: packetslist[type]};
          }
        }
        var asArray = new Uint8Array(data);
        var type = asArray[0];
        var rest = sliceBuffer(data, 1);
        if (Blob && binaryType === 'blob') {
          rest = new Blob([rest]);
        }
        return {
          type: packetslist[type],
          data: rest
        };
      };
      function tryDecode(data) {
        try {
          data = utf8.decode(data);
        } catch (e) {
          return false;
        }
        return data;
      }
      exports.decodeBase64Packet = function(msg, binaryType) {
        var type = packetslist[msg.charAt(0)];
        if (!base64encoder) {
          return {
            type: type,
            data: {
              base64: true,
              data: msg.substr(1)
            }
          };
        }
        var data = base64encoder.decode(msg.substr(1));
        if (binaryType === 'blob' && Blob) {
          data = new Blob([data]);
        }
        return {
          type: type,
          data: data
        };
      };
      exports.encodePayload = function(packets, supportsBinary, callback) {
        if (typeof supportsBinary == 'function') {
          callback = supportsBinary;
          supportsBinary = null;
        }
        var isBinary = hasBinary(packets);
        if (supportsBinary && isBinary) {
          if (Blob && !dontSendBlobs) {
            return exports.encodePayloadAsBlob(packets, callback);
          }
          return exports.encodePayloadAsArrayBuffer(packets, callback);
        }
        if (!packets.length) {
          return callback('0:');
        }
        function setLengthHeader(message) {
          return message.length + ':' + message;
        }
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
            doneCallback(null, setLengthHeader(message));
          });
        }
        map(packets, encodeOne, function(err, results) {
          return callback(results.join(''));
        });
      };
      function map(ary, each, done) {
        var result = new Array(ary.length);
        var next = after(ary.length, done);
        var eachWithIndex = function(i, el, cb) {
          each(el, function(error, msg) {
            result[i] = msg;
            cb(error, result);
          });
        };
        for (var i = 0; i < ary.length; i++) {
          eachWithIndex(i, ary[i], next);
        }
      }
      exports.decodePayload = function(data, binaryType, callback) {
        if (typeof data != 'string') {
          return exports.decodePayloadAsBinary(data, binaryType, callback);
        }
        if (typeof binaryType === 'function') {
          callback = binaryType;
          binaryType = null;
        }
        var packet;
        if (data == '') {
          return callback(err, 0, 1);
        }
        var length = '',
            n,
            msg;
        for (var i = 0,
            l = data.length; i < l; i++) {
          var chr = data.charAt(i);
          if (':' != chr) {
            length += chr;
          } else {
            if ('' == length || (length != (n = Number(length)))) {
              return callback(err, 0, 1);
            }
            msg = data.substr(i + 1, n);
            if (length != msg.length) {
              return callback(err, 0, 1);
            }
            if (msg.length) {
              packet = exports.decodePacket(msg, binaryType, true);
              if (err.type == packet.type && err.data == packet.data) {
                return callback(err, 0, 1);
              }
              var ret = callback(packet, i + n, l);
              if (false === ret)
                return;
            }
            i += n;
            length = '';
          }
        }
        if (length != '') {
          return callback(err, 0, 1);
        }
      };
      exports.encodePayloadAsArrayBuffer = function(packets, callback) {
        if (!packets.length) {
          return callback(new ArrayBuffer(0));
        }
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, true, true, function(data) {
            return doneCallback(null, data);
          });
        }
        map(packets, encodeOne, function(err, encodedPackets) {
          var totalLength = encodedPackets.reduce(function(acc, p) {
            var len;
            if (typeof p === 'string') {
              len = p.length;
            } else {
              len = p.byteLength;
            }
            return acc + len.toString().length + len + 2;
          }, 0);
          var resultArray = new Uint8Array(totalLength);
          var bufferIndex = 0;
          encodedPackets.forEach(function(p) {
            var isString = typeof p === 'string';
            var ab = p;
            if (isString) {
              var view = new Uint8Array(p.length);
              for (var i = 0; i < p.length; i++) {
                view[i] = p.charCodeAt(i);
              }
              ab = view.buffer;
            }
            if (isString) {
              resultArray[bufferIndex++] = 0;
            } else {
              resultArray[bufferIndex++] = 1;
            }
            var lenStr = ab.byteLength.toString();
            for (var i = 0; i < lenStr.length; i++) {
              resultArray[bufferIndex++] = parseInt(lenStr[i]);
            }
            resultArray[bufferIndex++] = 255;
            var view = new Uint8Array(ab);
            for (var i = 0; i < view.length; i++) {
              resultArray[bufferIndex++] = view[i];
            }
          });
          return callback(resultArray.buffer);
        });
      };
      exports.encodePayloadAsBlob = function(packets, callback) {
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, true, true, function(encoded) {
            var binaryIdentifier = new Uint8Array(1);
            binaryIdentifier[0] = 1;
            if (typeof encoded === 'string') {
              var view = new Uint8Array(encoded.length);
              for (var i = 0; i < encoded.length; i++) {
                view[i] = encoded.charCodeAt(i);
              }
              encoded = view.buffer;
              binaryIdentifier[0] = 0;
            }
            var len = (encoded instanceof ArrayBuffer) ? encoded.byteLength : encoded.size;
            var lenStr = len.toString();
            var lengthAry = new Uint8Array(lenStr.length + 1);
            for (var i = 0; i < lenStr.length; i++) {
              lengthAry[i] = parseInt(lenStr[i]);
            }
            lengthAry[lenStr.length] = 255;
            if (Blob) {
              var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
              doneCallback(null, blob);
            }
          });
        }
        map(packets, encodeOne, function(err, results) {
          return callback(new Blob(results));
        });
      };
      exports.decodePayloadAsBinary = function(data, binaryType, callback) {
        if (typeof binaryType === 'function') {
          callback = binaryType;
          binaryType = null;
        }
        var bufferTail = data;
        var buffers = [];
        var numberTooLong = false;
        while (bufferTail.byteLength > 0) {
          var tailArray = new Uint8Array(bufferTail);
          var isString = tailArray[0] === 0;
          var msgLength = '';
          for (var i = 1; ; i++) {
            if (tailArray[i] == 255)
              break;
            if (msgLength.length > 310) {
              numberTooLong = true;
              break;
            }
            msgLength += tailArray[i];
          }
          if (numberTooLong)
            return callback(err, 0, 1);
          bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
          msgLength = parseInt(msgLength);
          var msg = sliceBuffer(bufferTail, 0, msgLength);
          if (isString) {
            try {
              msg = String.fromCharCode.apply(null, new Uint8Array(msg));
            } catch (e) {
              var typed = new Uint8Array(msg);
              msg = '';
              for (var i = 0; i < typed.length; i++) {
                msg += String.fromCharCode(typed[i]);
              }
            }
          }
          buffers.push(msg);
          bufferTail = sliceBuffer(bufferTail, msgLength);
        }
        var total = buffers.length;
        buffers.forEach(function(buffer, i) {
          callback(exports.decodePacket(buffer, binaryType, true), i, total);
        });
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    module.exports = Object.keys || function keys(obj) {
      var arr = [];
      var has = Object.prototype.hasOwnProperty;
      for (var i in obj) {
        if (has.call(obj, i)) {
          arr.push(i);
        }
      }
      return arr;
    };
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var isArray = __webpack_require__(15);
      module.exports = hasBinary;
      function hasBinary(data) {
        function _hasBinary(obj) {
          if (!obj)
            return false;
          if ((global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer) || (global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
            return true;
          }
          if (isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
              if (_hasBinary(obj[i])) {
                return true;
              }
            }
          } else if (obj && 'object' == typeof obj) {
            if (obj.toJSON && 'function' == typeof obj.toJSON) {
              obj = obj.toJSON();
            }
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
                return true;
              }
            }
          }
          return false;
        }
        return _hasBinary(data);
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    module.exports = function(arraybuffer, start, end) {
      var bytes = arraybuffer.byteLength;
      start = start || 0;
      end = end || bytes;
      if (arraybuffer.slice) {
        return arraybuffer.slice(start, end);
      }
      if (start < 0) {
        start += bytes;
      }
      if (end < 0) {
        end += bytes;
      }
      if (end > bytes) {
        end = bytes;
      }
      if (start >= bytes || start >= end || bytes === 0) {
        return new ArrayBuffer(0);
      }
      var abv = new Uint8Array(arraybuffer);
      var result = new Uint8Array(end - start);
      for (var i = start,
          ii = 0; i < end; i++, ii++) {
        result[ii] = abv[i];
      }
      return result.buffer;
    };
  }, function(module, exports) {
    module.exports = after;
    function after(count, callback, err_cb) {
      var bail = false;
      err_cb = err_cb || noop;
      proxy.count = count;
      return (count === 0) ? callback() : proxy;
      function proxy(err, result) {
        if (proxy.count <= 0) {
          throw new Error('after called too many times');
        }
        --proxy.count;
        if (err) {
          bail = true;
          callback(err);
          callback = err_cb;
        } else if (proxy.count === 0 && !bail) {
          callback(null, result);
        }
      }
    }
    function noop() {}
  }, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    (function(module, global) {
      ;
      (function(root) {
        var freeExports = typeof exports == 'object' && exports;
        var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
        var freeGlobal = typeof global == 'object' && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
          root = freeGlobal;
        }
        var stringFromCharCode = String.fromCharCode;
        function ucs2decode(string) {
          var output = [];
          var counter = 0;
          var length = string.length;
          var value;
          var extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          var length = array.length;
          var index = -1;
          var value;
          var output = '';
          while (++index < length) {
            value = array[index];
            if (value > 0xFFFF) {
              value -= 0x10000;
              output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
              value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
          }
          return output;
        }
        function createByte(codePoint, shift) {
          return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
        }
        function encodeCodePoint(codePoint) {
          if ((codePoint & 0xFFFFFF80) == 0) {
            return stringFromCharCode(codePoint);
          }
          var symbol = '';
          if ((codePoint & 0xFFFFF800) == 0) {
            symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
          } else if ((codePoint & 0xFFFF0000) == 0) {
            symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
            symbol += createByte(codePoint, 6);
          } else if ((codePoint & 0xFFE00000) == 0) {
            symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
            symbol += createByte(codePoint, 12);
            symbol += createByte(codePoint, 6);
          }
          symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
          return symbol;
        }
        function wtf8encode(string) {
          var codePoints = ucs2decode(string);
          var length = codePoints.length;
          var index = -1;
          var codePoint;
          var byteString = '';
          while (++index < length) {
            codePoint = codePoints[index];
            byteString += encodeCodePoint(codePoint);
          }
          return byteString;
        }
        function readContinuationByte() {
          if (byteIndex >= byteCount) {
            throw Error('Invalid byte index');
          }
          var continuationByte = byteArray[byteIndex] & 0xFF;
          byteIndex++;
          if ((continuationByte & 0xC0) == 0x80) {
            return continuationByte & 0x3F;
          }
          throw Error('Invalid continuation byte');
        }
        function decodeSymbol() {
          var byte1;
          var byte2;
          var byte3;
          var byte4;
          var codePoint;
          if (byteIndex > byteCount) {
            throw Error('Invalid byte index');
          }
          if (byteIndex == byteCount) {
            return false;
          }
          byte1 = byteArray[byteIndex] & 0xFF;
          byteIndex++;
          if ((byte1 & 0x80) == 0) {
            return byte1;
          }
          if ((byte1 & 0xE0) == 0xC0) {
            var byte2 = readContinuationByte();
            codePoint = ((byte1 & 0x1F) << 6) | byte2;
            if (codePoint >= 0x80) {
              return codePoint;
            } else {
              throw Error('Invalid continuation byte');
            }
          }
          if ((byte1 & 0xF0) == 0xE0) {
            byte2 = readContinuationByte();
            byte3 = readContinuationByte();
            codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
            if (codePoint >= 0x0800) {
              return codePoint;
            } else {
              throw Error('Invalid continuation byte');
            }
          }
          if ((byte1 & 0xF8) == 0xF0) {
            byte2 = readContinuationByte();
            byte3 = readContinuationByte();
            byte4 = readContinuationByte();
            codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) | (byte3 << 0x06) | byte4;
            if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
              return codePoint;
            }
          }
          throw Error('Invalid WTF-8 detected');
        }
        var byteArray;
        var byteCount;
        var byteIndex;
        function wtf8decode(byteString) {
          byteArray = ucs2decode(byteString);
          byteCount = byteArray.length;
          byteIndex = 0;
          var codePoints = [];
          var tmp;
          while ((tmp = decodeSymbol()) !== false) {
            codePoints.push(tmp);
          }
          return ucs2encode(codePoints);
        }
        var wtf8 = {
          'version': '1.0.0',
          'encode': wtf8encode,
          'decode': wtf8decode
        };
        if (true) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return wtf8;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (freeExports && !freeExports.nodeType) {
          if (freeModule) {
            freeModule.exports = wtf8;
          } else {
            var object = {};
            var hasOwnProperty = object.hasOwnProperty;
            for (var key in wtf8) {
              hasOwnProperty.call(wtf8, key) && (freeExports[key] = wtf8[key]);
            }
          }
        } else {
          root.wtf8 = wtf8;
        }
      }(this));
    }.call(exports, __webpack_require__(12)(module), (function() {
      return this;
    }())));
  }, function(module, exports) {
    (function() {
      "use strict";
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup = new Uint8Array(256);
      for (var i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
      }
      exports.encode = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer),
            i,
            len = bytes.length,
            base64 = "";
        for (i = 0; i < len; i += 3) {
          base64 += chars[bytes[i] >> 2];
          base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
          base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
          base64 += chars[bytes[i + 2] & 63];
        }
        if ((len % 3) === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }
        return base64;
      };
      exports.decode = function(base64) {
        var bufferLength = base64.length * 0.75,
            len = base64.length,
            i,
            p = 0,
            encoded1,
            encoded2,
            encoded3,
            encoded4;
        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }
        var arraybuffer = new ArrayBuffer(bufferLength),
            bytes = new Uint8Array(arraybuffer);
        for (i = 0; i < len; i += 4) {
          encoded1 = lookup[base64.charCodeAt(i)];
          encoded2 = lookup[base64.charCodeAt(i + 1)];
          encoded3 = lookup[base64.charCodeAt(i + 2)];
          encoded4 = lookup[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }
        return arraybuffer;
      };
    })();
  }, function(module, exports) {
    (function(global) {
      var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;
      var blobSupported = (function() {
        try {
          var a = new Blob(['hi']);
          return a.size === 2;
        } catch (e) {
          return false;
        }
      })();
      var blobSupportsArrayBufferView = blobSupported && (function() {
        try {
          var b = new Blob([new Uint8Array([1, 2])]);
          return b.size === 2;
        } catch (e) {
          return false;
        }
      })();
      var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
      function mapArrayBufferViews(ary) {
        for (var i = 0; i < ary.length; i++) {
          var chunk = ary[i];
          if (chunk.buffer instanceof ArrayBuffer) {
            var buf = chunk.buffer;
            if (chunk.byteLength !== buf.byteLength) {
              var copy = new Uint8Array(chunk.byteLength);
              copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
              buf = copy.buffer;
            }
            ary[i] = buf;
          }
        }
      }
      function BlobBuilderConstructor(ary, options) {
        options = options || {};
        var bb = new BlobBuilder();
        mapArrayBufferViews(ary);
        for (var i = 0; i < ary.length; i++) {
          bb.append(ary[i]);
        }
        return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
      }
      ;
      function BlobConstructor(ary, options) {
        mapArrayBufferViews(ary);
        return new Blob(ary, options || {});
      }
      ;
      module.exports = (function() {
        if (blobSupported) {
          return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
        } else if (blobBuilderSupported) {
          return BlobBuilderConstructor;
        } else {
          return undefined;
        }
      })();
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    if (true) {
      module.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    ;
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks['$' + event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1),
          callbacks = this._callbacks['$' + event];
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0,
            len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }, function(module, exports) {
    exports.encode = function(obj) {
      var str = '';
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length)
            str += '&';
          str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
      }
      return str;
    };
    exports.decode = function(qs) {
      var qry = {};
      var pairs = qs.split('&');
      for (var i = 0,
          l = pairs.length; i < l; i++) {
        var pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };
  }, function(module, exports) {
    module.exports = function(a, b) {
      var fn = function() {};
      fn.prototype = b.prototype;
      a.prototype = new fn;
      a.prototype.constructor = a;
    };
  }, function(module, exports) {
    'use strict';
    var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
        length = 64,
        map = {},
        seed = 0,
        i = 0,
        prev;
    function encode(num) {
      var encoded = '';
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
      return encoded;
    }
    function decode(str) {
      var decoded = 0;
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
      }
      return decoded;
    }
    function yeast() {
      var now = encode(+new Date());
      if (now !== prev)
        return seed = 0, prev = now;
      return now + '.' + encode(seed++);
    }
    for (; i < length; i++)
      map[alphabet[i]] = i;
    yeast.encode = encode;
    yeast.decode = decode;
    module.exports = yeast;
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var Polling = __webpack_require__(25);
      var inherit = __webpack_require__(37);
      module.exports = JSONPPolling;
      var rNewline = /\n/g;
      var rEscapedNewline = /\\n/g;
      var callbacks;
      function empty() {}
      function JSONPPolling(opts) {
        Polling.call(this, opts);
        this.query = this.query || {};
        if (!callbacks) {
          if (!global.___eio)
            global.___eio = [];
          callbacks = global.___eio;
        }
        this.index = callbacks.length;
        var self = this;
        callbacks.push(function(msg) {
          self.onData(msg);
        });
        this.query.j = this.index;
        if (global.document && global.addEventListener) {
          global.addEventListener('beforeunload', function() {
            if (self.script)
              self.script.onerror = empty;
          }, false);
        }
      }
      inherit(JSONPPolling, Polling);
      JSONPPolling.prototype.supportsBinary = false;
      JSONPPolling.prototype.doClose = function() {
        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }
        if (this.form) {
          this.form.parentNode.removeChild(this.form);
          this.form = null;
          this.iframe = null;
        }
        Polling.prototype.doClose.call(this);
      };
      JSONPPolling.prototype.doPoll = function() {
        var self = this;
        var script = document.createElement('script');
        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }
        script.async = true;
        script.src = this.uri();
        script.onerror = function(e) {
          self.onError('jsonp poll error', e);
        };
        var insertAt = document.getElementsByTagName('script')[0];
        if (insertAt) {
          insertAt.parentNode.insertBefore(script, insertAt);
        } else {
          (document.head || document.body).appendChild(script);
        }
        this.script = script;
        var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);
        if (isUAgecko) {
          setTimeout(function() {
            var iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            document.body.removeChild(iframe);
          }, 100);
        }
      };
      JSONPPolling.prototype.doWrite = function(data, fn) {
        var self = this;
        if (!this.form) {
          var form = document.createElement('form');
          var area = document.createElement('textarea');
          var id = this.iframeId = 'eio_iframe_' + this.index;
          var iframe;
          form.className = 'socketio';
          form.style.position = 'absolute';
          form.style.top = '-1000px';
          form.style.left = '-1000px';
          form.target = id;
          form.method = 'POST';
          form.setAttribute('accept-charset', 'utf-8');
          area.name = 'd';
          form.appendChild(area);
          document.body.appendChild(form);
          this.form = form;
          this.area = area;
        }
        this.form.action = this.uri();
        function complete() {
          initIframe();
          fn();
        }
        function initIframe() {
          if (self.iframe) {
            try {
              self.form.removeChild(self.iframe);
            } catch (e) {
              self.onError('jsonp polling iframe removal error', e);
            }
          }
          try {
            var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
            iframe = document.createElement(html);
          } catch (e) {
            iframe = document.createElement('iframe');
            iframe.name = self.iframeId;
            iframe.src = 'javascript:0';
          }
          iframe.id = self.iframeId;
          self.form.appendChild(iframe);
          self.iframe = iframe;
        }
        initIframe();
        data = data.replace(rEscapedNewline, '\\\n');
        this.area.value = data.replace(rNewline, '\\n');
        try {
          this.form.submit();
        } catch (e) {}
        if (this.iframe.attachEvent) {
          this.iframe.onreadystatechange = function() {
            if (self.iframe.readyState === 'complete') {
              complete();
            }
          };
        } else {
          this.iframe.onload = complete;
        }
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var Transport = __webpack_require__(26);
      var parser = __webpack_require__(27);
      var parseqs = __webpack_require__(36);
      var inherit = __webpack_require__(37);
      var yeast = __webpack_require__(38);
      var debug = __webpack_require__(3)('engine.io-client:websocket');
      var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
      var NodeWebSocket;
      if (typeof window === 'undefined') {
        try {
          NodeWebSocket = __webpack_require__(41);
        } catch (e) {}
      }
      var WebSocket = BrowserWebSocket;
      if (!WebSocket && typeof window === 'undefined') {
        WebSocket = NodeWebSocket;
      }
      module.exports = WS;
      function WS(opts) {
        var forceBase64 = (opts && opts.forceBase64);
        if (forceBase64) {
          this.supportsBinary = false;
        }
        this.perMessageDeflate = opts.perMessageDeflate;
        this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
        if (!this.usingBrowserWebSocket) {
          WebSocket = NodeWebSocket;
        }
        Transport.call(this, opts);
      }
      inherit(WS, Transport);
      WS.prototype.name = 'websocket';
      WS.prototype.supportsBinary = true;
      WS.prototype.doOpen = function() {
        if (!this.check()) {
          return;
        }
        var uri = this.uri();
        var protocols = void(0);
        var opts = {
          agent: this.agent,
          perMessageDeflate: this.perMessageDeflate
        };
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        if (this.extraHeaders) {
          opts.headers = this.extraHeaders;
        }
        if (this.localAddress) {
          opts.localAddress = this.localAddress;
        }
        try {
          this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emit('error', err);
        }
        if (this.ws.binaryType === undefined) {
          this.supportsBinary = false;
        }
        if (this.ws.supports && this.ws.supports.binary) {
          this.supportsBinary = true;
          this.ws.binaryType = 'nodebuffer';
        } else {
          this.ws.binaryType = 'arraybuffer';
        }
        this.addEventListeners();
      };
      WS.prototype.addEventListeners = function() {
        var self = this;
        this.ws.onopen = function() {
          self.onOpen();
        };
        this.ws.onclose = function() {
          self.onClose();
        };
        this.ws.onmessage = function(ev) {
          self.onData(ev.data);
        };
        this.ws.onerror = function(e) {
          self.onError('websocket error', e);
        };
      };
      WS.prototype.write = function(packets) {
        var self = this;
        this.writable = false;
        var total = packets.length;
        for (var i = 0,
            l = total; i < l; i++) {
          (function(packet) {
            parser.encodePacket(packet, self.supportsBinary, function(data) {
              if (!self.usingBrowserWebSocket) {
                var opts = {};
                if (packet.options) {
                  opts.compress = packet.options.compress;
                }
                if (self.perMessageDeflate) {
                  var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
                  if (len < self.perMessageDeflate.threshold) {
                    opts.compress = false;
                  }
                }
              }
              try {
                if (self.usingBrowserWebSocket) {
                  self.ws.send(data);
                } else {
                  self.ws.send(data, opts);
                }
              } catch (e) {
                debug('websocket closed before onclose event');
              }
              --total || done();
            });
          })(packets[i]);
        }
        function done() {
          self.emit('flush');
          setTimeout(function() {
            self.writable = true;
            self.emit('drain');
          }, 0);
        }
      };
      WS.prototype.onClose = function() {
        Transport.prototype.onClose.call(this);
      };
      WS.prototype.doClose = function() {
        if (typeof this.ws !== 'undefined') {
          this.ws.close();
        }
      };
      WS.prototype.uri = function() {
        var query = this.query || {};
        var schema = this.secure ? 'wss' : 'ws';
        var port = '';
        if (this.port && (('wss' === schema && Number(this.port) !== 443) || ('ws' === schema && Number(this.port) !== 80))) {
          port = ':' + this.port;
        }
        if (this.timestampRequests) {
          query[this.timestampParam] = yeast();
        }
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        query = parseqs.encode(query);
        if (query.length) {
          query = '?' + query;
        }
        var ipv6 = this.hostname.indexOf(':') !== -1;
        return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
      };
      WS.prototype.check = function() {
        return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {}, function(module, exports) {
    var indexOf = [].indexOf;
    module.exports = function(arr, obj) {
      if (indexOf)
        return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) {
        if (arr[i] === obj)
          return i;
      }
      return -1;
    };
  }, function(module, exports) {
    (function(global) {
      var rvalidchars = /^[\],:{}\s]*$/;
      var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
      var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
      var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
      var rtrimLeft = /^\s+/;
      var rtrimRight = /\s+$/;
      module.exports = function parsejson(data) {
        if ('string' != typeof data || !data) {
          return null;
        }
        data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
        if (global.JSON && JSON.parse) {
          return JSON.parse(data);
        }
        if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
          return (new Function('return ' + data))();
        }
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var parser = __webpack_require__(7);
    var Emitter = __webpack_require__(35);
    var toArray = __webpack_require__(45);
    var on = __webpack_require__(46);
    var bind = __webpack_require__(47);
    var debug = __webpack_require__(3)('socket.io-client:socket');
    var hasBin = __webpack_require__(29);
    module.exports = exports = Socket;
    var events = {
      connect: 1,
      connect_error: 1,
      connect_timeout: 1,
      connecting: 1,
      disconnect: 1,
      error: 1,
      reconnect: 1,
      reconnect_attempt: 1,
      reconnect_failed: 1,
      reconnect_error: 1,
      reconnecting: 1,
      ping: 1,
      pong: 1
    };
    var emit = Emitter.prototype.emit;
    function Socket(io, nsp, opts) {
      this.io = io;
      this.nsp = nsp;
      this.json = this;
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.connected = false;
      this.disconnected = true;
      if (opts && opts.query) {
        this.query = opts.query;
      }
      if (this.io.autoConnect)
        this.open();
    }
    Emitter(Socket.prototype);
    Socket.prototype.subEvents = function() {
      if (this.subs)
        return;
      var io = this.io;
      this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
    };
    Socket.prototype.open = Socket.prototype.connect = function() {
      if (this.connected)
        return this;
      this.subEvents();
      this.io.open();
      if ('open' === this.io.readyState)
        this.onopen();
      this.emit('connecting');
      return this;
    };
    Socket.prototype.send = function() {
      var args = toArray(arguments);
      args.unshift('message');
      this.emit.apply(this, args);
      return this;
    };
    Socket.prototype.emit = function(ev) {
      if (events.hasOwnProperty(ev)) {
        emit.apply(this, arguments);
        return this;
      }
      var args = toArray(arguments);
      var parserType = parser.EVENT;
      if (hasBin(args)) {
        parserType = parser.BINARY_EVENT;
      }
      var packet = {
        type: parserType,
        data: args
      };
      packet.options = {};
      packet.options.compress = !this.flags || false !== this.flags.compress;
      if ('function' === typeof args[args.length - 1]) {
        debug('emitting packet with ack id %d', this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }
      if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      delete this.flags;
      return this;
    };
    Socket.prototype.packet = function(packet) {
      packet.nsp = this.nsp;
      this.io.packet(packet);
    };
    Socket.prototype.onopen = function() {
      debug('transport is open - connecting');
      if ('/' !== this.nsp) {
        if (this.query) {
          this.packet({
            type: parser.CONNECT,
            query: this.query
          });
        } else {
          this.packet({type: parser.CONNECT});
        }
      }
    };
    Socket.prototype.onclose = function(reason) {
      debug('close (%s)', reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emit('disconnect', reason);
    };
    Socket.prototype.onpacket = function(packet) {
      if (packet.nsp !== this.nsp)
        return;
      switch (packet.type) {
        case parser.CONNECT:
          this.onconnect();
          break;
        case parser.EVENT:
          this.onevent(packet);
          break;
        case parser.BINARY_EVENT:
          this.onevent(packet);
          break;
        case parser.ACK:
          this.onack(packet);
          break;
        case parser.BINARY_ACK:
          this.onack(packet);
          break;
        case parser.DISCONNECT:
          this.ondisconnect();
          break;
        case parser.ERROR:
          this.emit('error', packet.data);
          break;
      }
    };
    Socket.prototype.onevent = function(packet) {
      var args = packet.data || [];
      debug('emitting event %j', args);
      if (null != packet.id) {
        debug('attaching ack callback to event');
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        emit.apply(this, args);
      } else {
        this.receiveBuffer.push(args);
      }
    };
    Socket.prototype.ack = function(id) {
      var self = this;
      var sent = false;
      return function() {
        if (sent)
          return;
        sent = true;
        var args = toArray(arguments);
        debug('sending ack %j', args);
        var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
        self.packet({
          type: type,
          id: id,
          data: args
        });
      };
    };
    Socket.prototype.onack = function(packet) {
      var ack = this.acks[packet.id];
      if ('function' === typeof ack) {
        debug('calling ack %s with %j', packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug('bad ack %s', packet.id);
      }
    };
    Socket.prototype.onconnect = function() {
      this.connected = true;
      this.disconnected = false;
      this.emit('connect');
      this.emitBuffered();
    };
    Socket.prototype.emitBuffered = function() {
      var i;
      for (i = 0; i < this.receiveBuffer.length; i++) {
        emit.apply(this, this.receiveBuffer[i]);
      }
      this.receiveBuffer = [];
      for (i = 0; i < this.sendBuffer.length; i++) {
        this.packet(this.sendBuffer[i]);
      }
      this.sendBuffer = [];
    };
    Socket.prototype.ondisconnect = function() {
      debug('server disconnect (%s)', this.nsp);
      this.destroy();
      this.onclose('io server disconnect');
    };
    Socket.prototype.destroy = function() {
      if (this.subs) {
        for (var i = 0; i < this.subs.length; i++) {
          this.subs[i].destroy();
        }
        this.subs = null;
      }
      this.io.destroy(this);
    };
    Socket.prototype.close = Socket.prototype.disconnect = function() {
      if (this.connected) {
        debug('performing disconnect (%s)', this.nsp);
        this.packet({type: parser.DISCONNECT});
      }
      this.destroy();
      if (this.connected) {
        this.onclose('io client disconnect');
      }
      return this;
    };
    Socket.prototype.compress = function(compress) {
      this.flags = this.flags || {};
      this.flags.compress = compress;
      return this;
    };
  }, function(module, exports) {
    module.exports = toArray;
    function toArray(list, index) {
      var array = [];
      index = index || 0;
      for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i];
      }
      return array;
    }
  }, function(module, exports) {
    "use strict";
    module.exports = on;
    function on(obj, ev, fn) {
      obj.on(ev, fn);
      return {destroy: function destroy() {
          obj.removeListener(ev, fn);
        }};
    }
  }, function(module, exports) {
    var slice = [].slice;
    module.exports = function(obj, fn) {
      if ('string' == typeof fn)
        fn = obj[fn];
      if ('function' != typeof fn)
        throw new Error('bind() requires a function');
      var args = slice.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.concat(slice.call(arguments)));
      };
    };
  }, function(module, exports) {
    module.exports = Backoff;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 10000;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }]);
});
;

})();
(function() {
var define = $__System.amdDefine;
define("20", ["1f"], function(main) {
  return main;
});

})();
$__System.register('21', ['3', '7', '13', '15', '17', '20', 'a', 'b', '1d', '1e'], function (_export) {
	var SentMessage, _classCallCheck, Sender, ConnectionEvent, Requestor, io, _createClass, ReceivedMessage, Receiver, MasterWebRTC;

	return {
		setters: [function (_2) {
			SentMessage = _2.SentMessage;
		}, function (_) {
			_classCallCheck = _['default'];
		}, function (_3) {
			Sender = _3.Sender;
		}, function (_4) {
			ConnectionEvent = _4.ConnectionEvent;
		}, function (_5) {
			Requestor = _5.Requestor;
		}, function (_6) {
			io = _6['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_b) {
			ReceivedMessage = _b.ReceivedMessage;
		}, function (_d) {
			Receiver = _d.Receiver;
		}, function (_e) {}],
		execute: function () {
			/*jshint esnext: true */

			//import 'muaz-khan/RTCMultiConnection/dist/RTCMultiConnection.js';
			// adjusted: this.onDataChannelMessage line 2426
			'use strict';

			MasterWebRTC = (function () {
				function MasterWebRTC() {
					_classCallCheck(this, MasterWebRTC);

					// connection
					window.io = io;
					this.connection = window.sst && window.sst.isDebug && window.WebRTC && window.WebRTC.connection ? window.WebRTC.connection : new RTCMultiConnection();
					//https://github.com/muaz-khan/RTCMultiConnection/issues/639
					//this.connection.socketURL = window.sst && window.sst.isDebug ? `http://${window.location.hostname}:9001/` : 'http://default-environment.digvjm9b3i.us-west-2.elasticbeanstalk.com:9001/'; // cd into repo: npm install --production / node server.js
					//this.connection.socketURL = window.sst && window.sst.isDebug ? `http://${window.location.hostname}:9001/` : 'https://webrtcweb.com:9001/'; // cd into repo: npm install --production / node server.js
					// server was updated and lib/RTCMultiConnection.js so needs update to work locally again
					//https://github.com/muaz-khan/RTCMultiConnection-Server
					//this.connection.socketURL = 'https://webrtcweb.com:9002/';
					this.connection.socketURL = 'https://rtcmulticonnection.herokuapp.com:443/'; // cd into repo: npm install --production / node server.js
					//https://gist.github.com/yetithefoot/7592580
					// test at> https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/
					this.connection.iceServers = [{
						urls: ['stun:stun01.sipphone.com', 'stun:stun.l.google.com:19302?transport=udp', 'turn:turn.anyfirewall.com:443?transport=tcp' /*,
                                                                                                                                     'stun:stun.schlund.de',
                                                                                                                                     'stun:stun.l.google.com:19302',
                                                                                                                                     'stun:stun1.l.google.com:19302',
                                                                                                                                     'stun:stun2.l.google.com:19302',
                                                                                                                                     'stun:stunserver.org',
                                                                                                                                     'stun:stun.ekiga.net',
                                                                                                                                     'stun:stun.fwdnet.net',
                                                                                                                                     'stun:stun.ideasip.com',
                                                                                                                                     'stun:stun.iptel.org',
                                                                                                                                     'stun:stun.rixtelecom.se',
                                                                                                                                     'stun:stun.softjoys.com',
                                                                                                                                     'stun:stun.voiparound.com',
                                                                                                                                     'stun:stun.voipbuster.com',
                                                                                                                                     'stun:stun.voipstunt.com',
                                                                                                                                     'stun:stun.voxgratia.org',
                                                                                                                                     'stun:stun.xten.com'*/
						]
					}, {
						// stun:numb.viagenie.ca [weedshaker@gmail.com:peerwebsite]
						urls: 'stun:numb.viagenie.ca',
						credential: 'peerwebsite',
						username: 'weedshaker@gmail.com'
					}];
					this.connection.sdpConstraints.mandatory = {
						OfferToReceiveAudio: false,
						OfferToReceiveVideo: false
					};
					this.connection.session = {
						data: true,
						audio: false,
						video: false,
						screen: false
					};
					// Helper
					this.SentMessage = new SentMessage();
					this.ReceivedMessage = new ReceivedMessage();
					// Classes
					this.Sender = new Sender(this.connection, this.SentMessage);
					this.ConnectionEvent = new ConnectionEvent(this.connection, this.Sender, this.SentMessage);
					this.Requestor = new Requestor(this.Sender, this.SentMessage);
					this.Receiver = new Receiver(this.connection, this.Requestor, this.ReceivedMessage);

					// hot-reloader clear all
					if (window.sst && window.sst.isDebug) {
						window.WebRTC = this;
					}
				}

				/**
     * (api hook)
     * 
     * @memberof MasterWebRTC
     */

				_createClass(MasterWebRTC, [{
					key: 'setIgnoreOption',
					value: function setIgnoreOption() {
						this.Sender.setIgnoreOption();
						this.Receiver.setIgnoreOption();
					}

					/**
      * (api hook)
      * 
      * @memberof MasterWebRTC
      */
				}, {
					key: 'unsetIgnoreOption',
					value: function unsetIgnoreOption() {
						this.Sender.unsetIgnoreOption();
						this.Receiver.unsetIgnoreOption();
					}
				}]);

				return MasterWebRTC;
			})();

			_export('MasterWebRTC', MasterWebRTC);
		}
	};
});
$__System.register('22', ['5', '6', '7', '21'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterWebRTC, WebRTC;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterWebRTC = _4.MasterWebRTC;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			WebRTC = (function (_MasterWebRTC) {
				_inherits(WebRTC, _MasterWebRTC);

				function WebRTC() {
					_classCallCheck(this, WebRTC);

					_get(Object.getPrototypeOf(WebRTC.prototype), 'constructor', this).call(this);

					// hooks
					this.api = {
						/**
       * called from dom
       * 
       * @param {string} roomid 
       * @param {string} [message=''] 
       * @param {string} [elID=''] 
       * @memberof MasterConnectionEvent
       */
						openOrJoinEvent: this.ConnectionEvent.openOrJoinEvent.bind(this.ConnectionEvent), // roomid, message = '', elID = ''
						peerCounterElements: this.ConnectionEvent.peerCounterElements,
						isSender: this.ConnectionEvent.isSender,
						/**
       * message, elID (used for Diff_match_patch), remoteUserId (@user), requestID (used at sendRequest)
       * 
       * @param {string} message 
       * @param {string} [elID=this.SentMessage.elID] 
       * @param {string} [remoteUserId=this.SentMessage.remoteUserId] 
       * @param {string} [requestID=''] 
       * @param {boolean} [timeout=this.timeout] 
       * @param {Map([['diffed', [0, true]], ['compressed', [1, 'auto']]])} options
       * @memberof MasterSender
       */
						sendEvent: this.Sender.sendEvent.bind(this.Sender), // message, elID = 'sst_all', remoteUserId = 'sst_toAll', requestID = '', options = new Map([['diffed', [0, true]], ['compressed', [1, 'auto']]])
						/**
       * event handler .add (.remove takes [func, scope])
       * 
       * @param {Function} func 
       * @param {string} [scope = this]
       * @param {string} [args = [message = '', elID = '']]
       * @memberof Helper
       */
						onNewParticipant: this.ConnectionEvent.onNewParticipant, // func, scope = this, args = [] ==> has to return [message = '', elID = '']
						/**
       * event handler .add (.remove takes [func, scope])
       * 
       * @param {Function} func 
       * @param {string} [scope = this]
       * @param {string} [args = [message = '', elID = '']]
       * @memberof Helper
       */
						onReceive: this.Receiver.onReceive, // func, scope = this, args = []
						/**
       * 
       * @memberof MasterWebRTC
       */
						setIgnoreOption: this.setIgnoreOption.bind(this),
						/**
       * 
       * @memberof MasterWebRTC
       */
						unsetIgnoreOption: this.unsetIgnoreOption.bind(this),
						/**
       * Map
       * 
       * @param {Map([['diffed', [0, true]], ['compressed', [1, 'auto']]])} options
       * @memberof OptionSender
       */
						options: this.Sender.OptionSender.options
					};
				}

				return WebRTC;
			})(MasterWebRTC);

			_export('WebRTC', WebRTC);
		}
	};
});
(function() {
var define = $__System.amdDefine;
(function(f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define("23", [], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.dom2hscript = f();
  }
})(function() {
  var define,
      module,
      exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }
        var l = n[o] = {exports: {}};
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  })({
    1: [function(require, module, exports) {
      var parser = require('./parser');
      var parseStyle = function(el) {
        var style = el.style;
        var output = {};
        for (var i = 0; i < style.length; ++i) {
          var item = style.item(i);
          output[item] = style[item];
        }
        return output;
      };
      var parseDOM = function(el) {
        if (!el.tagName && el.nodeType === Node.TEXT_NODE) {
          return JSON.stringify(el.textContent);
        }
        if (!el.attributes) {
          return;
        }
        var attributes = {};
        for (var i = 0; i < el.attributes.length; i++) {
          var attr = el.attributes[i];
          if (attr.name && typeof attr.value !== "undefined") {
            if (attr.name == "style") {
              attributes.style = parseStyle(el);
            } else {
              attributes[attr.name] = attr.value;
            }
          }
        }
        var output = "h('" + el.tagName;
        if (attributes.id) {
          output = output + '#' + attributes.id;
          delete attributes.id;
        }
        if (attributes.class) {
          output = output + '.' + attributes.class.replace(/ /g, ".");
          delete attributes.class;
        }
        output += "',";
        output += JSON.stringify(attributes);
        var children = [];
        output += ',[';
        for (var i = 0; i < el.childNodes.length; i++) {
          output += parseDOM(el.childNodes[i]) + ",";
        }
        output += "])";
        return output;
      };
      var parseHTML = function(html) {
        return parseDOM(parser(html));
      };
      exports.parseDOM = parseDOM;
      exports.parseHTML = parseHTML;
      module.exports = exports;
    }, {"./parser": 2}],
    2: [function(require, module, exports) {
      var parser;
      if (!window.DOMParser) {
        throw new Error("DOMParser required");
      }
      (function(DOMParser) {
        "use strict";
        var proto = DOMParser.prototype,
            nativeParse = proto.parseFromString;
        ;
        try {
          if ((new DOMParser()).parseFromString("", "text/html")) {
            return;
          }
        } catch (ex) {}
        proto.parseFromString = function(markup, type) {
          if (/^\s*text\/html\s*(?:;|$)/i.test(type)) {
            var doc = document.implementation.createHTMLDocument("");
            ;
            if (markup.toLowerCase().indexOf('<!doctype') > -1) {
              doc.documentElement.innerHTML = markup;
            } else {
              doc.body.innerHTML = markup;
            }
            return doc;
          } else {
            return nativeParse.apply(this, arguments);
          }
        };
      }(DOMParser));
      parser = new DOMParser();
      module.exports = function(html, strictChecking) {
        var result = parser.parseFromString(html, 'text/html');
        var el;
        if (html.substring(0, 10).match(/\<body.+/ig)) {
          el = result.getElementsByTagName('body')[0];
        } else {
          el = result.getElementsByTagName('body')[0].firstChild;
        }
        var errors = el.getElementsByTagName('parsererror');
        if (errors && errors.length > 0) {
          if (strictChecking === true) {
            throw new Error(errors[0].textContent);
          }
          for (var i = 0; i < errors.length; i++) {
            errors[i].parentElement.removeChild(errors[i]);
          }
        }
        return el;
      };
    }, {}]
  }, {}, [1])(1);
});

})();
(function() {
var define = $__System.amdDefine;
!function(e) {
  if ("object" == typeof exports && "undefined" != typeof module)
    module.exports = e();
  else if ("function" == typeof define && define.amd)
    define("24", [], e);
  else {
    var f;
    "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.virtualDom = e();
  }
}(function() {
  var define,
      module,
      exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }
        var l = n[o] = {exports: {}};
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  })({
    1: [function(require, module, exports) {
      var createElement = require("./vdom/create-element.js");
      module.exports = createElement;
    }, {"./vdom/create-element.js": 15}],
    2: [function(require, module, exports) {
      var diff = require("./vtree/diff.js");
      module.exports = diff;
    }, {"./vtree/diff.js": 35}],
    3: [function(require, module, exports) {
      var h = require("./virtual-hyperscript/index.js");
      module.exports = h;
    }, {"./virtual-hyperscript/index.js": 22}],
    4: [function(require, module, exports) {
      var diff = require("./diff.js");
      var patch = require("./patch.js");
      var h = require("./h.js");
      var create = require("./create-element.js");
      var VNode = require('./vnode/vnode.js');
      var VText = require('./vnode/vtext.js');
      module.exports = {
        diff: diff,
        patch: patch,
        h: h,
        create: create,
        VNode: VNode,
        VText: VText
      };
    }, {
      "./create-element.js": 1,
      "./diff.js": 2,
      "./h.js": 3,
      "./patch.js": 13,
      "./vnode/vnode.js": 31,
      "./vnode/vtext.js": 33
    }],
    5: [function(require, module, exports) {
      module.exports = (function split(undef) {
        var nativeSplit = String.prototype.split,
            compliantExecNpcg = /()??/.exec("")[1] === undef,
            self;
        self = function(str, separator, limit) {
          if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
            return nativeSplit.call(str, separator, limit);
          }
          var output = [],
              flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + (separator.sticky ? "y" : ""),
              lastLastIndex = 0,
              separator = new RegExp(separator.source, flags + "g"),
              separator2,
              match,
              lastIndex,
              lastLength;
          str += "";
          if (!compliantExecNpcg) {
            separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
          }
          limit = limit === undef ? -1 >>> 0 : limit >>> 0;
          while (match = separator.exec(str)) {
            lastIndex = match.index + match[0].length;
            if (lastIndex > lastLastIndex) {
              output.push(str.slice(lastLastIndex, match.index));
              if (!compliantExecNpcg && match.length > 1) {
                match[0].replace(separator2, function() {
                  for (var i = 1; i < arguments.length - 2; i++) {
                    if (arguments[i] === undef) {
                      match[i] = undef;
                    }
                  }
                });
              }
              if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
              }
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= limit) {
                break;
              }
            }
            if (separator.lastIndex === match.index) {
              separator.lastIndex++;
            }
          }
          if (lastLastIndex === str.length) {
            if (lastLength || !separator.test("")) {
              output.push("");
            }
          } else {
            output.push(str.slice(lastLastIndex));
          }
          return output.length > limit ? output.slice(0, limit) : output;
        };
        return self;
      })();
    }, {}],
    6: [function(require, module, exports) {}, {}],
    7: [function(require, module, exports) {
      'use strict';
      var OneVersionConstraint = require('individual/one-version');
      var MY_VERSION = '7';
      OneVersionConstraint('ev-store', MY_VERSION);
      var hashKey = '__EV_STORE_KEY@' + MY_VERSION;
      module.exports = EvStore;
      function EvStore(elem) {
        var hash = elem[hashKey];
        if (!hash) {
          hash = elem[hashKey] = {};
        }
        return hash;
      }
    }, {"individual/one-version": 9}],
    8: [function(require, module, exports) {
      (function(global) {
        'use strict';
        var root = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
        module.exports = Individual;
        function Individual(key, value) {
          if (key in root) {
            return root[key];
          }
          root[key] = value;
          return value;
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    9: [function(require, module, exports) {
      'use strict';
      var Individual = require('./index.js');
      module.exports = OneVersion;
      function OneVersion(moduleName, version, defaultValue) {
        var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
        var enforceKey = key + '_ENFORCE_SINGLETON';
        var versionValue = Individual(enforceKey, version);
        if (versionValue !== version) {
          throw new Error('Can only have one copy of ' + moduleName + '.\n' + 'You already have version ' + versionValue + ' installed.\n' + 'This means you cannot install version ' + version);
        }
        return Individual(key, defaultValue);
      }
    }, {"./index.js": 8}],
    10: [function(require, module, exports) {
      (function(global) {
        var topLevel = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};
        var minDoc = require('min-document');
        if (typeof document !== 'undefined') {
          module.exports = document;
        } else {
          var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];
          if (!doccy) {
            doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
          }
          module.exports = doccy;
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {"min-document": 6}],
    11: [function(require, module, exports) {
      "use strict";
      module.exports = function isObject(x) {
        return typeof x === "object" && x !== null;
      };
    }, {}],
    12: [function(require, module, exports) {
      var nativeIsArray = Array.isArray;
      var toString = Object.prototype.toString;
      module.exports = nativeIsArray || isArray;
      function isArray(obj) {
        return toString.call(obj) === "[object Array]";
      }
    }, {}],
    13: [function(require, module, exports) {
      var patch = require("./vdom/patch.js");
      module.exports = patch;
    }, {"./vdom/patch.js": 18}],
    14: [function(require, module, exports) {
      var isObject = require("is-object");
      var isHook = require("../vnode/is-vhook.js");
      module.exports = applyProperties;
      function applyProperties(node, props, previous) {
        for (var propName in props) {
          var propValue = props[propName];
          if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
          } else if (isHook(propValue)) {
            removeProperty(node, propName, propValue, previous);
            if (propValue.hook) {
              propValue.hook(node, propName, previous ? previous[propName] : undefined);
            }
          } else {
            if (isObject(propValue)) {
              patchObject(node, props, previous, propName, propValue);
            } else {
              propName === 'className' ? node[propName] = propValue : node.setAttribute(propName, propValue);
            }
          }
        }
      }
      function removeProperty(node, propName, propValue, previous) {
        if (previous) {
          var previousValue = previous[propName];
          if (!isHook(previousValue)) {
            if (propName === "attributes") {
              for (var attrName in previousValue) {
                node.removeAttribute(attrName);
              }
            } else if (propName === "style") {
              for (var i in previousValue) {
                node.style[i] = "";
              }
            } else if (typeof previousValue === "string") {
              node[propName] = "";
            } else {
              node[propName] = null;
            }
          } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue);
          }
        }
      }
      function patchObject(node, props, previous, propName, propValue) {
        var previousValue = previous ? previous[propName] : undefined;
        if (propName === "attributes") {
          for (var attrName in propValue) {
            var attrValue = propValue[attrName];
            if (attrValue === undefined) {
              node.removeAttribute(attrName);
            } else {
              node.setAttribute(attrName, attrValue);
            }
          }
          return;
        }
        if (previousValue && isObject(previousValue) && getPrototype(previousValue) !== getPrototype(propValue)) {
          node[propName] = propValue;
          return;
        }
        if (!isObject(node[propName])) {
          node[propName] = {};
        }
        var replacer = propName === "style" ? "" : undefined;
        for (var k in propValue) {
          var value = propValue[k];
          node[propName][k] = (value === undefined) ? replacer : value;
        }
      }
      function getPrototype(value) {
        if (Object.getPrototypeOf) {
          return Object.getPrototypeOf(value);
        } else if (value.__proto__) {
          return value.__proto__;
        } else if (value.constructor) {
          return value.constructor.prototype;
        }
      }
    }, {
      "../vnode/is-vhook.js": 26,
      "is-object": 11
    }],
    15: [function(require, module, exports) {
      var document = require("global/document");
      var applyProperties = require("./apply-properties");
      var isVNode = require("../vnode/is-vnode.js");
      var isVText = require("../vnode/is-vtext.js");
      var isWidget = require("../vnode/is-widget.js");
      var handleThunk = require("../vnode/handle-thunk.js");
      module.exports = createElement;
      function createElement(vnode, opts) {
        var doc = opts ? opts.document || document : document;
        var warn = opts ? opts.warn : null;
        vnode = handleThunk(vnode).a;
        if (isWidget(vnode)) {
          return vnode.init();
        } else if (isVText(vnode)) {
          return doc.createTextNode(vnode.text);
        } else if (!isVNode(vnode)) {
          if (warn) {
            warn("Item is not a valid virtual dom node", vnode);
          }
          return null;
        }
        var node = (vnode.namespace === null) ? doc.createElement(vnode.tagName) : doc.createElementNS(vnode.namespace, vnode.tagName);
        var props = vnode.properties;
        applyProperties(node, props);
        var children = vnode.children;
        for (var i = 0; i < children.length; i++) {
          var childNode = createElement(children[i], opts);
          if (childNode) {
            node.appendChild(childNode);
          }
        }
        return node;
      }
    }, {
      "../vnode/handle-thunk.js": 24,
      "../vnode/is-vnode.js": 27,
      "../vnode/is-vtext.js": 28,
      "../vnode/is-widget.js": 29,
      "./apply-properties": 14,
      "global/document": 10
    }],
    16: [function(require, module, exports) {
      var noChild = {};
      module.exports = domIndex;
      function domIndex(rootNode, tree, indices, nodes) {
        if (!indices || indices.length === 0) {
          return {};
        } else {
          indices.sort(ascending);
          return recurse(rootNode, tree, indices, nodes, 0);
        }
      }
      function recurse(rootNode, tree, indices, nodes, rootIndex) {
        nodes = nodes || {};
        if (rootNode) {
          if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode;
          }
          var vChildren = tree.children;
          if (vChildren) {
            var childNodes = rootNode.childNodes;
            for (var i = 0; i < tree.children.length; i++) {
              rootIndex += 1;
              var vChild = vChildren[i] || noChild;
              var nextIndex = rootIndex + (vChild.count || 0);
              if (indexInRange(indices, rootIndex, nextIndex)) {
                recurse(childNodes[i], vChild, indices, nodes, rootIndex);
              }
              rootIndex = nextIndex;
            }
          }
        }
        return nodes;
      }
      function indexInRange(indices, left, right) {
        if (indices.length === 0) {
          return false;
        }
        var minIndex = 0;
        var maxIndex = indices.length - 1;
        var currentIndex;
        var currentItem;
        while (minIndex <= maxIndex) {
          currentIndex = ((maxIndex + minIndex) / 2) >> 0;
          currentItem = indices[currentIndex];
          if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right;
          } else if (currentItem < left) {
            minIndex = currentIndex + 1;
          } else if (currentItem > right) {
            maxIndex = currentIndex - 1;
          } else {
            return true;
          }
        }
        return false;
      }
      function ascending(a, b) {
        return a > b ? 1 : -1;
      }
    }, {}],
    17: [function(require, module, exports) {
      var applyProperties = require("./apply-properties");
      var isWidget = require("../vnode/is-widget.js");
      var VPatch = require("../vnode/vpatch.js");
      var updateWidget = require("./update-widget");
      module.exports = applyPatch;
      function applyPatch(vpatch, domNode, renderOptions) {
        var type = vpatch.type;
        var vNode = vpatch.vNode;
        var patch = vpatch.patch;
        switch (type) {
          case VPatch.REMOVE:
            return removeNode(domNode, vNode);
          case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions);
          case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions);
          case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions);
          case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions);
          case VPatch.ORDER:
            reorderChildren(domNode, patch);
            return domNode;
          case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties);
            return domNode;
          case VPatch.THUNK:
            return replaceRoot(domNode, renderOptions.patch(domNode, patch, renderOptions));
          default:
            return domNode;
        }
      }
      function removeNode(domNode, vNode) {
        var parentNode = domNode.parentNode;
        if (parentNode) {
          parentNode.removeChild(domNode);
        }
        destroyWidget(domNode, vNode);
        return null;
      }
      function insertNode(parentNode, vNode, renderOptions) {
        var newNode = renderOptions.render(vNode, renderOptions);
        if (parentNode) {
          parentNode.appendChild(newNode);
        }
        return parentNode;
      }
      function stringPatch(domNode, leftVNode, vText, renderOptions) {
        var newNode;
        if (domNode.nodeType === 3) {
          domNode.replaceData(0, domNode.length, vText.text);
          newNode = domNode;
        } else {
          var parentNode = domNode.parentNode;
          newNode = renderOptions.render(vText, renderOptions);
          if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode);
          }
        }
        return newNode;
      }
      function widgetPatch(domNode, leftVNode, widget, renderOptions) {
        var updating = updateWidget(leftVNode, widget);
        var newNode;
        if (updating) {
          newNode = widget.update(leftVNode, domNode) || domNode;
        } else {
          newNode = renderOptions.render(widget, renderOptions);
        }
        var parentNode = domNode.parentNode;
        if (parentNode && newNode !== domNode) {
          parentNode.replaceChild(newNode, domNode);
        }
        if (!updating) {
          destroyWidget(domNode, leftVNode);
        }
        return newNode;
      }
      function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
        var parentNode = domNode.parentNode;
        var newNode = renderOptions.render(vNode, renderOptions);
        if (parentNode && newNode !== domNode) {
          parentNode.replaceChild(newNode, domNode);
        }
        return newNode;
      }
      function destroyWidget(domNode, w) {
        if (typeof w.destroy === "function" && isWidget(w)) {
          w.destroy(domNode);
        }
      }
      function reorderChildren(domNode, moves) {
        var childNodes = domNode.childNodes;
        var keyMap = {};
        var node;
        var remove;
        var insert;
        for (var i = 0; i < moves.removes.length; i++) {
          remove = moves.removes[i];
          node = childNodes[remove.from];
          if (remove.key) {
            keyMap[remove.key] = node;
          }
          domNode.removeChild(node);
        }
        var length = childNodes.length;
        for (var j = 0; j < moves.inserts.length; j++) {
          insert = moves.inserts[j];
          node = keyMap[insert.key];
          domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to]);
        }
      }
      function replaceRoot(oldRoot, newRoot) {
        if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
          oldRoot.parentNode.replaceChild(newRoot, oldRoot);
        }
        return newRoot;
      }
    }, {
      "../vnode/is-widget.js": 29,
      "../vnode/vpatch.js": 32,
      "./apply-properties": 14,
      "./update-widget": 19
    }],
    18: [function(require, module, exports) {
      var document = require("global/document");
      var isArray = require("x-is-array");
      var render = require("./create-element");
      var domIndex = require("./dom-index");
      var patchOp = require("./patch-op");
      module.exports = patch;
      function patch(rootNode, patches, renderOptions) {
        renderOptions = renderOptions || {};
        renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch ? renderOptions.patch : patchRecursive;
        renderOptions.render = renderOptions.render || render;
        return renderOptions.patch(rootNode, patches, renderOptions);
      }
      function patchRecursive(rootNode, patches, renderOptions) {
        var indices = patchIndices(patches);
        if (indices.length === 0) {
          return rootNode;
        }
        var index = domIndex(rootNode, patches.a, indices);
        var ownerDocument = rootNode.ownerDocument;
        if (!renderOptions.document && ownerDocument !== document) {
          renderOptions.document = ownerDocument;
        }
        for (var i = 0; i < indices.length; i++) {
          var nodeIndex = indices[i];
          rootNode = applyPatch(rootNode, index[nodeIndex], patches[nodeIndex], renderOptions);
        }
        return rootNode;
      }
      function applyPatch(rootNode, domNode, patchList, renderOptions) {
        if (!domNode) {
          return rootNode;
        }
        var newNode;
        if (isArray(patchList)) {
          for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions);
            if (domNode === rootNode) {
              rootNode = newNode;
            }
          }
        } else {
          newNode = patchOp(patchList, domNode, renderOptions);
          if (domNode === rootNode) {
            rootNode = newNode;
          }
        }
        return rootNode;
      }
      function patchIndices(patches) {
        var indices = [];
        for (var key in patches) {
          if (key !== "a") {
            indices.push(Number(key));
          }
        }
        return indices;
      }
    }, {
      "./create-element": 15,
      "./dom-index": 16,
      "./patch-op": 17,
      "global/document": 10,
      "x-is-array": 12
    }],
    19: [function(require, module, exports) {
      var isWidget = require("../vnode/is-widget.js");
      module.exports = updateWidget;
      function updateWidget(a, b) {
        if (isWidget(a) && isWidget(b)) {
          if ("name" in a && "name" in b) {
            return a.id === b.id;
          } else {
            return a.init === b.init;
          }
        }
        return false;
      }
    }, {"../vnode/is-widget.js": 29}],
    20: [function(require, module, exports) {
      'use strict';
      var EvStore = require('ev-store');
      module.exports = EvHook;
      function EvHook(value) {
        if (!(this instanceof EvHook)) {
          return new EvHook(value);
        }
        this.value = value;
      }
      EvHook.prototype.hook = function(node, propertyName) {
        var es = EvStore(node);
        var propName = propertyName.substr(3);
        es[propName] = this.value;
      };
      EvHook.prototype.unhook = function(node, propertyName) {
        var es = EvStore(node);
        var propName = propertyName.substr(3);
        es[propName] = undefined;
      };
    }, {"ev-store": 7}],
    21: [function(require, module, exports) {
      'use strict';
      module.exports = SoftSetHook;
      function SoftSetHook(value) {
        if (!(this instanceof SoftSetHook)) {
          return new SoftSetHook(value);
        }
        this.value = value;
      }
      SoftSetHook.prototype.hook = function(node, propertyName) {
        if (node[propertyName] !== this.value) {
          node[propertyName] = this.value;
        }
      };
    }, {}],
    22: [function(require, module, exports) {
      'use strict';
      var isArray = require('x-is-array');
      var VNode = require('../vnode/vnode.js');
      var VText = require('../vnode/vtext.js');
      var isVNode = require('../vnode/is-vnode');
      var isVText = require('../vnode/is-vtext');
      var isWidget = require('../vnode/is-widget');
      var isHook = require('../vnode/is-vhook');
      var isVThunk = require('../vnode/is-thunk');
      var parseTag = require('./parse-tag.js');
      var softSetHook = require('./hooks/soft-set-hook.js');
      var evHook = require('./hooks/ev-hook.js');
      module.exports = h;
      function h(tagName, properties, children) {
        var childNodes = [];
        var tag,
            props,
            key,
            namespace;
        if (!children && isChildren(properties)) {
          children = properties;
          props = {};
        }
        props = props || properties || {};
        tag = parseTag(tagName, props);
        if (props.hasOwnProperty('key')) {
          key = props.key;
          props.key = undefined;
        }
        if (props.hasOwnProperty('namespace')) {
          namespace = props.namespace;
          props.namespace = undefined;
        }
        if (tag === 'INPUT' && !namespace && props.hasOwnProperty('value') && props.value !== undefined && !isHook(props.value)) {
          props.value = softSetHook(props.value);
        }
        transformProperties(props);
        if (children !== undefined && children !== null) {
          addChild(children, childNodes, tag, props);
        }
        return new VNode(tag, props, childNodes, key, namespace);
      }
      function addChild(c, childNodes, tag, props) {
        if (typeof c === 'string') {
          childNodes.push(new VText(c));
        } else if (typeof c === 'number') {
          childNodes.push(new VText(String(c)));
        } else if (isChild(c)) {
          childNodes.push(c);
        } else if (isArray(c)) {
          for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
          }
        } else if (c === null || c === undefined) {
          return;
        } else {
          throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
              tagName: tag,
              properties: props
            }
          });
        }
      }
      function transformProperties(props) {
        for (var propName in props) {
          if (props.hasOwnProperty(propName)) {
            var value = props[propName];
            if (isHook(value)) {
              continue;
            }
            if (propName.substr(0, 3) === 'ev-') {
              props[propName] = evHook(value);
            }
          }
        }
      }
      function isChild(x) {
        return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
      }
      function isChildren(x) {
        return typeof x === 'string' || isArray(x) || isChild(x);
      }
      function UnexpectedVirtualElement(data) {
        var err = new Error();
        err.type = 'virtual-hyperscript.unexpected.virtual-element';
        err.message = 'Unexpected virtual child passed to h().\n' + 'Expected a VNode / Vthunk / VWidget / string but:\n' + 'got:\n' + errorString(data.foreignObject) + '.\n' + 'The parent vnode is:\n' + errorString(data.parentVnode);
        '\n' + 'Suggested fix: change your `h(..., [ ... ])` callsite.';
        err.foreignObject = data.foreignObject;
        err.parentVnode = data.parentVnode;
        return err;
      }
      function errorString(obj) {
        try {
          return JSON.stringify(obj, null, '    ');
        } catch (e) {
          return String(obj);
        }
      }
    }, {
      "../vnode/is-thunk": 25,
      "../vnode/is-vhook": 26,
      "../vnode/is-vnode": 27,
      "../vnode/is-vtext": 28,
      "../vnode/is-widget": 29,
      "../vnode/vnode.js": 31,
      "../vnode/vtext.js": 33,
      "./hooks/ev-hook.js": 20,
      "./hooks/soft-set-hook.js": 21,
      "./parse-tag.js": 23,
      "x-is-array": 12
    }],
    23: [function(require, module, exports) {
      'use strict';
      var split = require('browser-split');
      var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
      var notClassId = /^\.|#/;
      module.exports = parseTag;
      function parseTag(tag, props) {
        if (!tag) {
          return 'DIV';
        }
        var noId = !(props.hasOwnProperty('id'));
        var tagParts = split(tag, classIdSplit);
        var tagName = null;
        if (notClassId.test(tagParts[1])) {
          tagName = 'DIV';
        }
        var classes,
            part,
            type,
            i;
        for (i = 0; i < tagParts.length; i++) {
          part = tagParts[i];
          if (!part) {
            continue;
          }
          type = part.charAt(0);
          if (!tagName) {
            tagName = part;
          } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
          } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
          }
        }
        if (classes) {
          if (props.className) {
            classes.push(props.className);
          }
          props.className = classes.join(' ');
        }
        return props.namespace ? tagName : tagName.toUpperCase();
      }
    }, {"browser-split": 5}],
    24: [function(require, module, exports) {
      var isVNode = require("./is-vnode");
      var isVText = require("./is-vtext");
      var isWidget = require("./is-widget");
      var isThunk = require("./is-thunk");
      module.exports = handleThunk;
      function handleThunk(a, b) {
        var renderedA = a;
        var renderedB = b;
        if (isThunk(b)) {
          renderedB = renderThunk(b, a);
        }
        if (isThunk(a)) {
          renderedA = renderThunk(a, null);
        }
        return {
          a: renderedA,
          b: renderedB
        };
      }
      function renderThunk(thunk, previous) {
        var renderedThunk = thunk.vnode;
        if (!renderedThunk) {
          renderedThunk = thunk.vnode = thunk.render(previous);
        }
        if (!(isVNode(renderedThunk) || isVText(renderedThunk) || isWidget(renderedThunk))) {
          throw new Error("thunk did not return a valid node");
        }
        return renderedThunk;
      }
    }, {
      "./is-thunk": 25,
      "./is-vnode": 27,
      "./is-vtext": 28,
      "./is-widget": 29
    }],
    25: [function(require, module, exports) {
      module.exports = isThunk;
      function isThunk(t) {
        return t && t.type === "Thunk";
      }
    }, {}],
    26: [function(require, module, exports) {
      module.exports = isHook;
      function isHook(hook) {
        return hook && (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") || typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"));
      }
    }, {}],
    27: [function(require, module, exports) {
      var version = require("./version");
      module.exports = isVirtualNode;
      function isVirtualNode(x) {
        return x && x.type === "VirtualNode" && x.version === version;
      }
    }, {"./version": 30}],
    28: [function(require, module, exports) {
      var version = require("./version");
      module.exports = isVirtualText;
      function isVirtualText(x) {
        return x && x.type === "VirtualText" && x.version === version;
      }
    }, {"./version": 30}],
    29: [function(require, module, exports) {
      module.exports = isWidget;
      function isWidget(w) {
        return w && w.type === "Widget";
      }
    }, {}],
    30: [function(require, module, exports) {
      module.exports = "2";
    }, {}],
    31: [function(require, module, exports) {
      var version = require("./version");
      var isVNode = require("./is-vnode");
      var isWidget = require("./is-widget");
      var isThunk = require("./is-thunk");
      var isVHook = require("./is-vhook");
      module.exports = VirtualNode;
      var noProperties = {};
      var noChildren = [];
      function VirtualNode(tagName, properties, children, key, namespace) {
        this.tagName = tagName;
        this.properties = properties || noProperties;
        this.children = children || noChildren;
        this.key = key != null ? String(key) : undefined;
        this.namespace = (typeof namespace === "string") ? namespace : null;
        var count = (children && children.length) || 0;
        var descendants = 0;
        var hasWidgets = false;
        var hasThunks = false;
        var descendantHooks = false;
        var hooks;
        for (var propName in properties) {
          if (properties.hasOwnProperty(propName)) {
            var property = properties[propName];
            if (isVHook(property) && property.unhook) {
              if (!hooks) {
                hooks = {};
              }
              hooks[propName] = property;
            }
          }
        }
        for (var i = 0; i < count; i++) {
          var child = children[i];
          if (isVNode(child)) {
            descendants += child.count || 0;
            if (!hasWidgets && child.hasWidgets) {
              hasWidgets = true;
            }
            if (!hasThunks && child.hasThunks) {
              hasThunks = true;
            }
            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
              descendantHooks = true;
            }
          } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
              hasWidgets = true;
            }
          } else if (!hasThunks && isThunk(child)) {
            hasThunks = true;
          }
        }
        this.count = count + descendants;
        this.hasWidgets = hasWidgets;
        this.hasThunks = hasThunks;
        this.hooks = hooks;
        this.descendantHooks = descendantHooks;
      }
      VirtualNode.prototype.version = version;
      VirtualNode.prototype.type = "VirtualNode";
    }, {
      "./is-thunk": 25,
      "./is-vhook": 26,
      "./is-vnode": 27,
      "./is-widget": 29,
      "./version": 30
    }],
    32: [function(require, module, exports) {
      var version = require("./version");
      VirtualPatch.NONE = 0;
      VirtualPatch.VTEXT = 1;
      VirtualPatch.VNODE = 2;
      VirtualPatch.WIDGET = 3;
      VirtualPatch.PROPS = 4;
      VirtualPatch.ORDER = 5;
      VirtualPatch.INSERT = 6;
      VirtualPatch.REMOVE = 7;
      VirtualPatch.THUNK = 8;
      module.exports = VirtualPatch;
      function VirtualPatch(type, vNode, patch) {
        this.type = Number(type);
        this.vNode = vNode;
        this.patch = patch;
      }
      VirtualPatch.prototype.version = version;
      VirtualPatch.prototype.type = "VirtualPatch";
    }, {"./version": 30}],
    33: [function(require, module, exports) {
      var version = require("./version");
      module.exports = VirtualText;
      function VirtualText(text) {
        this.text = String(text);
      }
      VirtualText.prototype.version = version;
      VirtualText.prototype.type = "VirtualText";
    }, {"./version": 30}],
    34: [function(require, module, exports) {
      var isObject = require("is-object");
      var isHook = require("../vnode/is-vhook");
      module.exports = diffProps;
      function diffProps(a, b) {
        var diff;
        for (var aKey in a) {
          if (!(aKey in b)) {
            diff = diff || {};
            diff[aKey] = undefined;
          }
          var aValue = a[aKey];
          var bValue = b[aKey];
          if (aValue === bValue) {
            continue;
          } else if (isObject(aValue) && isObject(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
              diff = diff || {};
              diff[aKey] = bValue;
            } else if (isHook(bValue)) {
              diff = diff || {};
              diff[aKey] = bValue;
            } else {
              var objectDiff = diffProps(aValue, bValue);
              if (objectDiff) {
                diff = diff || {};
                diff[aKey] = objectDiff;
              }
            }
          } else {
            diff = diff || {};
            diff[aKey] = bValue;
          }
        }
        for (var bKey in b) {
          if (!(bKey in a)) {
            diff = diff || {};
            diff[bKey] = b[bKey];
          }
        }
        return diff;
      }
      function getPrototype(value) {
        if (Object.getPrototypeOf) {
          return Object.getPrototypeOf(value);
        } else if (value.__proto__) {
          return value.__proto__;
        } else if (value.constructor) {
          return value.constructor.prototype;
        }
      }
    }, {
      "../vnode/is-vhook": 26,
      "is-object": 11
    }],
    35: [function(require, module, exports) {
      var isArray = require("x-is-array");
      var VPatch = require("../vnode/vpatch");
      var isVNode = require("../vnode/is-vnode");
      var isVText = require("../vnode/is-vtext");
      var isWidget = require("../vnode/is-widget");
      var isThunk = require("../vnode/is-thunk");
      var handleThunk = require("../vnode/handle-thunk");
      var diffProps = require("./diff-props");
      module.exports = diff;
      function diff(a, b) {
        var patch = {a: a};
        walk(a, b, patch, 0);
        return patch;
      }
      function walk(a, b, patch, index) {
        if (a === b) {
          return;
        }
        var apply = patch[index];
        var applyClear = false;
        if (isThunk(a) || isThunk(b)) {
          thunks(a, b, patch, index);
        } else if (b == null) {
          if (!isWidget(a)) {
            clearState(a, patch, index);
            apply = patch[index];
          }
          apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b));
        } else if (isVNode(b)) {
          if (isVNode(a)) {
            if (a.tagName === b.tagName && a.namespace === b.namespace && a.key === b.key) {
              var propsPatch = diffProps(a.properties, b.properties);
              if (propsPatch) {
                apply = appendPatch(apply, new VPatch(VPatch.PROPS, a, propsPatch));
              }
              apply = diffChildren(a, b, patch, apply, index);
            } else {
              apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
              applyClear = true;
            }
          } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
            applyClear = true;
          }
        } else if (isVText(b)) {
          if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
            applyClear = true;
          } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
          }
        } else if (isWidget(b)) {
          if (!isWidget(a)) {
            applyClear = true;
          }
          apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b));
        }
        if (apply) {
          patch[index] = apply;
        }
        if (applyClear) {
          clearState(a, patch, index);
        }
      }
      function diffChildren(a, b, patch, apply, index) {
        var aChildren = a.children;
        var orderedSet = reorder(aChildren, b.children);
        var bChildren = orderedSet.children;
        var aLen = aChildren.length;
        var bLen = bChildren.length;
        var len = aLen > bLen ? aLen : bLen;
        for (var i = 0; i < len; i++) {
          var leftNode = aChildren[i];
          var rightNode = bChildren[i];
          index += 1;
          if (!leftNode) {
            if (rightNode) {
              apply = appendPatch(apply, new VPatch(VPatch.INSERT, null, rightNode));
            }
          } else {
            walk(leftNode, rightNode, patch, index);
          }
          if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count;
          }
        }
        if (orderedSet.moves) {
          apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, orderedSet.moves));
        }
        return apply;
      }
      function clearState(vNode, patch, index) {
        unhook(vNode, patch, index);
        destroyWidgets(vNode, patch, index);
      }
      function destroyWidgets(vNode, patch, index) {
        if (isWidget(vNode)) {
          if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(patch[index], new VPatch(VPatch.REMOVE, vNode, null));
          }
        } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
          var children = vNode.children;
          var len = children.length;
          for (var i = 0; i < len; i++) {
            var child = children[i];
            index += 1;
            destroyWidgets(child, patch, index);
            if (isVNode(child) && child.count) {
              index += child.count;
            }
          }
        } else if (isThunk(vNode)) {
          thunks(vNode, null, patch, index);
        }
      }
      function thunks(a, b, patch, index) {
        var nodes = handleThunk(a, b);
        var thunkPatch = diff(nodes.a, nodes.b);
        if (hasPatches(thunkPatch)) {
          patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch);
        }
      }
      function hasPatches(patch) {
        for (var index in patch) {
          if (index !== "a") {
            return true;
          }
        }
        return false;
      }
      function unhook(vNode, patch, index) {
        if (isVNode(vNode)) {
          if (vNode.hooks) {
            patch[index] = appendPatch(patch[index], new VPatch(VPatch.PROPS, vNode, undefinedKeys(vNode.hooks)));
          }
          if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children;
            var len = children.length;
            for (var i = 0; i < len; i++) {
              var child = children[i];
              index += 1;
              unhook(child, patch, index);
              if (isVNode(child) && child.count) {
                index += child.count;
              }
            }
          }
        } else if (isThunk(vNode)) {
          thunks(vNode, null, patch, index);
        }
      }
      function undefinedKeys(obj) {
        var result = {};
        for (var key in obj) {
          result[key] = undefined;
        }
        return result;
      }
      function reorder(aChildren, bChildren) {
        var bChildIndex = keyIndex(bChildren);
        var bKeys = bChildIndex.keys;
        var bFree = bChildIndex.free;
        if (bFree.length === bChildren.length) {
          return {
            children: bChildren,
            moves: null
          };
        }
        var aChildIndex = keyIndex(aChildren);
        var aKeys = aChildIndex.keys;
        var aFree = aChildIndex.free;
        if (aFree.length === aChildren.length) {
          return {
            children: bChildren,
            moves: null
          };
        }
        var newChildren = [];
        var freeIndex = 0;
        var freeCount = bFree.length;
        var deletedItems = 0;
        for (var i = 0; i < aChildren.length; i++) {
          var aItem = aChildren[i];
          var itemIndex;
          if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
              itemIndex = bKeys[aItem.key];
              newChildren.push(bChildren[itemIndex]);
            } else {
              itemIndex = i - deletedItems++;
              newChildren.push(null);
            }
          } else {
            if (freeIndex < freeCount) {
              itemIndex = bFree[freeIndex++];
              newChildren.push(bChildren[itemIndex]);
            } else {
              itemIndex = i - deletedItems++;
              newChildren.push(null);
            }
          }
        }
        var lastFreeIndex = freeIndex >= bFree.length ? bChildren.length : bFree[freeIndex];
        for (var j = 0; j < bChildren.length; j++) {
          var newItem = bChildren[j];
          if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
              newChildren.push(newItem);
            }
          } else if (j >= lastFreeIndex) {
            newChildren.push(newItem);
          }
        }
        var simulate = newChildren.slice();
        var simulateIndex = 0;
        var removes = [];
        var inserts = [];
        var simulateItem;
        for (var k = 0; k < bChildren.length; ) {
          var wantedItem = bChildren[k];
          simulateItem = simulate[simulateIndex];
          while (simulateItem === null && simulate.length) {
            removes.push(remove(simulate, simulateIndex, null));
            simulateItem = simulate[simulateIndex];
          }
          if (!simulateItem || simulateItem.key !== wantedItem.key) {
            if (wantedItem.key) {
              if (simulateItem && simulateItem.key) {
                if (bKeys[simulateItem.key] !== k + 1) {
                  removes.push(remove(simulate, simulateIndex, simulateItem.key));
                  simulateItem = simulate[simulateIndex];
                  if (!simulateItem || simulateItem.key !== wantedItem.key) {
                    inserts.push({
                      key: wantedItem.key,
                      to: k
                    });
                  } else {
                    simulateIndex++;
                  }
                } else {
                  inserts.push({
                    key: wantedItem.key,
                    to: k
                  });
                }
              } else {
                inserts.push({
                  key: wantedItem.key,
                  to: k
                });
              }
              k++;
            } else if (simulateItem && simulateItem.key) {
              removes.push(remove(simulate, simulateIndex, simulateItem.key));
            }
          } else {
            simulateIndex++;
            k++;
          }
        }
        while (simulateIndex < simulate.length) {
          simulateItem = simulate[simulateIndex];
          removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key));
        }
        if (removes.length === deletedItems && !inserts.length) {
          return {
            children: newChildren,
            moves: null
          };
        }
        return {
          children: newChildren,
          moves: {
            removes: removes,
            inserts: inserts
          }
        };
      }
      function remove(arr, index, key) {
        arr.splice(index, 1);
        return {
          from: index,
          key: key
        };
      }
      function keyIndex(children) {
        var keys = {};
        var free = [];
        var length = children.length;
        for (var i = 0; i < length; i++) {
          var child = children[i];
          if (child.key) {
            keys[child.key] = i;
          } else {
            free.push(i);
          }
        }
        return {
          keys: keys,
          free: free
        };
      }
      function appendPatch(apply, patch) {
        if (apply) {
          if (isArray(apply)) {
            apply.push(patch);
          } else {
            apply = [apply, patch];
          }
          return apply;
        } else {
          return patch;
        }
      }
    }, {
      "../vnode/handle-thunk": 24,
      "../vnode/is-thunk": 25,
      "../vnode/is-vnode": 27,
      "../vnode/is-vtext": 28,
      "../vnode/is-widget": 29,
      "../vnode/vpatch": 32,
      "./diff-props": 34,
      "x-is-array": 12
    }]
  }, {}, [4])(4);
});

})();
$__System.register('25', ['7', '23', '24', 'a'], function (_export) {
	var _classCallCheck, dom2hscript, diff, patch, h, _createClass, MasterDom;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			dom2hscript = _2['default'];
		}, function (_3) {
			diff = _3.diff;
			patch = _3.patch;
			h = _3.h;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterDom = (function () {
				function MasterDom() {
					_classCallCheck(this, MasterDom);
				}

				_createClass(MasterDom, [{
					key: 'setData',
					value: function setData(container, oldContent, newContent) {
						if (oldContent && newContent) {
							// no use for webworkers =>
							// dom2hscript requires DomParser, which is not available inside webworkers
							// virtual-dom needs to access DOM directly to patch
							var newTree = eval(dom2hscript.parseHTML('<div>' + newContent + '</div>'));
							var oldTree = eval(dom2hscript.parseHTML('<div>' + oldContent + '</div>'));
							var patches = diff(oldTree, newTree);
							return patch(container[0], patches);
						} else {
							return container.html(newContent);
						}
					}
				}]);

				return MasterDom;
			})();

			_export('MasterDom', MasterDom);
		}
	};
});
$__System.register('26', ['5', '6', '7', '25'], function (_export) {
  var _get, _inherits, _classCallCheck, MasterDom, Dom;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      MasterDom = _4.MasterDom;
    }],
    execute: function () {
      /*jshint esnext: true */

      'use strict';

      Dom = (function (_MasterDom) {
        _inherits(Dom, _MasterDom);

        function Dom() {
          _classCallCheck(this, Dom);

          _get(Object.getPrototypeOf(Dom.prototype), 'constructor', this).apply(this, arguments);
        }

        return Dom;
      })(MasterDom);

      _export('Dom', Dom);
    }
  };
});
$__System.register('27', ['7', '10', '26', '28', 'a'], function (_export) {
	var _classCallCheck, _Map, Dom, $, _createClass, MasterHTML;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_4) {
			Dom = _4.Dom;
		}, function (_3) {
			$ = _3['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterHTML = (function () {
				function MasterHTML(WebTorrent) {
					_classCallCheck(this, MasterHTML);

					this.Dom = new Dom();
					this.WebTorrent = WebTorrent;
					// when properly solved, this should be removed, see TODO below
					this.someTorrentContainsVideo = false;
				}

				_createClass(MasterHTML, [{
					key: 'removeElements',
					value: function removeElements() {
						this.idNames.forEach(function (e) {
							$('#' + e).remove();
						});
					}
				}, {
					key: 'getData',
					value: function getData(container) {
						return container.html();
					}
				}, {
					key: 'setData',
					value: function setData(container, dataPack) {
						var _this = this;

						var domDiffing = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

						this.lastData = [container, dataPack];
						// don't dom diff if it is not already webrtc diffed, send empty string to set full html without dom diffing
						var oldMessage = domDiffing ? dataPack.result && dataPack.result.includes('receiveDiff:true') ? this.getData(container) : '' : '';
						this.WebTorrent.api.addByText(dataPack.message, [
						// trigger the following, when the worker returns with dataPack.message -> this.Dom.setData(container, oldMessage, dataPack.message);
						new _Map([['function', this.Dom.setData], ['scope', this], ['attributes', [container, oldMessage]]]), new _Map([['function', this.WebTorrent.api.removeDeletedNodes], ['scope', this.WebTorrent], ['attributes', [this.WebTorrent.api.container]]])], // needs to get this as attribute, eventhough default val, otherwise it gets overwritten by returned txt
						undefined, undefined, undefined, function (torrent) {
							return _this.reTriggerSetData(torrent);
						});
					}
				}, {
					key: 'reTriggerSetData',
					value: function reTriggerSetData(torrent) {
						var _this2 = this;

						// re-trigger to set certain attributes like style on images after they were appended
						// TODO: Solve it properly by reading those attributes out at RegexWorker and set when torrent gets appended
						// TODO: this process breaks webtorrent video streaming, so only use it for none videos
						// WEBTORRENT pictures will be unformated when there is a video with this hack!!! Term: unformated, unresponsive webtorrent images
						if (torrent.sst_containsVideo) this.someTorrentContainsVideo = true;
						if (!this.someTorrentContainsVideo) {
							clearTimeout(this.reTriggerTimeOutID);
							this.reTriggerTimeOutID = setTimeout(function () {
								if (_this2.lastData) _this2.setData.apply(_this2, _this2.lastData);
							}, 1000);
						}
					}
				}, {
					key: 'attachButtonEvent',
					value: function attachButtonEvent(button, sendCont, getDataFunc, event, send) {
						var _this3 = this;

						button.on('click', function () {
							event($('#' + _this3.idNames[0]).val() || $('#' + _this3.idNames[0]).attr('placeholder'), getDataFunc(sendCont), _this3.idNames[2], send);
						});
					}
				}]);

				return MasterHTML;
			})();

			_export('MasterHTML', MasterHTML);
		}
	};
});
$__System.register('29', ['7', '10', 'a', '2a'], function (_export) {
  var _classCallCheck, _Map, _createClass, _Array$from, Player;

  return {
    setters: [function (_) {
      _classCallCheck = _['default'];
    }, function (_2) {
      _Map = _2['default'];
    }, function (_a) {
      _createClass = _a['default'];
    }, function (_a2) {
      _Array$from = _a2['default'];
    }],
    execute: function () {
      // @ts-check

      /**
       * Creates a global Player managing the audio and video tags
       * Use for debugging: http://localhost:3000/index_debug.html#ipfs:QmT8dAKuCVQ7TTHV5ezNFE272cs15PyigJGV663GHeen6t
       * NOTE: JSPM Transpiler does not allow web components, so we are left with a simple class
       *
       * @export
       * @attribute {namespace} namespace
       * @type {CustomElementConstructor}
       */
      'use strict';

      Player = (function () {
        function Player() {
          var id = arguments.length <= 0 || arguments[0] === undefined ? 'player' : arguments[0];

          _classCallCheck(this, Player);

          this.id = id;
          this.saveTollerance = 10; // sec., used to decide from when a tracks currentTime would be saved
          this.prevResetTollerance = 3; // sec., used to decide from when a track would be reset when going to prev track
          this.seekTime = 10; // sec., used for seek steps
          this.keyDownTollerance = 300; // ms, used to decide from holding down a key to start seeking
          this.waitToPlayMs = 5000; // ms, in random mode waiting for play before skipping to next (every pause/play action will trigger multiple of native events which will reset isLoading nextRandom and postpone the nextRandom to trigger)
          // NOTE: EventListener named eg. 'waiting' retrigger the this.isLoading( faster than the waitToPlayMs = 10000 , for this keep it lower
          // NOTE: tried pause/play quick command to skip to next but did not work on mobile except of starting all songs: this.waitSkipAtPausePlayMs = 2000 // ms, in between pushing pause <-> play to skip to next random song

          // internal use
          this.randomQueue = [];
          this._loadedmetadataControls = [];
          this.onErrorExtendedToSourceIds = [];
          this.respectRandom = true;
          this.waitToPlayTimeout = null;
          this.isLoadingMemory = new _Map();
        }

        _createClass(Player, [{
          key: 'connect',
          value: function connect(isSender, parent) {
            var _this = this;

            this.isSender = isSender;
            this.parent = parent;
            // wait for the first media to load metadata bevor the player options initialize
            document.body.addEventListener('loadedmetadata', function (event) {
              return _this.init(event);
            }, { once: true, capture: true });
            document.body.addEventListener('loadedmetadata', function (event) {
              return _this.refreshedInit(event);
            }, true);
          }
        }, {
          key: 'init',
          value: function init(event) {
            if (this.validateEvent(event) && (!this.currentControlIndex || this.mode === 'random')) this.currentControl = event.target;
            var header = null;
            if (header = document.querySelector('body > header')) header.classList.add('down');
            this.html = document.querySelector('#' + this.id);
            this.htmlPlaceholder = document.querySelector('#' + this.id + '-placeholder');
            if (!this.html) return console.warn('SST: Player could not be started due to lack of html el hook #' + this.id);
            this.addControlsBehavior(this.renderHTML(this.renderCSS()));
            this.addEventListeners();
            if (this.parent) this.parent.classList.add('hasPlayer');
            this.setMode(document.body.innerText.search(/loop.{0,1}ma[s]{0,1}chine/i) !== -1 && 'loop-machine'); // initial set last mode
          }
        }, {
          key: 'refreshedInit',
          value: function refreshedInit(event) {
            var _this2 = this;

            if (this.validateEvent(event)) this._loadedmetadataControls.push(event.target);
            this.setVolume(); // initial set last volume
            this.allControls.forEach(function (control) {
              return _this2.onError(control);
            }); // extended error handling
          }

          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio
        }, {
          key: 'addEventListeners',
          value: function addEventListeners() {
            var _this3 = this;

            // is media playing or not
            document.body.addEventListener('canplay', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(false, event.target);
            }, true);
            document.body.addEventListener('canplaythrough', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(false, event.target);
            }, true);
            document.body.addEventListener('complete', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(false, event.target);
            }, true);
            document.body.addEventListener('durationchange', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(true, event.target);
            }, true);
            document.body.addEventListener('emptied', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(true, event.target);
            }, true);
            // TODO: Iphone ended event sometimes does not get triggered, work around with isLoading()->set time out skip to next
            // loop all audio + video
            document.body.addEventListener('ended', function (event) {
              if (_this3.validateEvent(event)) {
                _this3.isLoading(false, event.target);
                // set control to 0, since this would not work natively for ios
                _this3.setCurrentTime(event.target, 0);
                if (_this3.mode === 'repeat-one' || _this3.mode === 'loop-machine') {
                  _this3.play(event.target);
                } else {
                  _this3.next();
                }
              }
            }, true);
            document.body.addEventListener('loadeddata', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(false, event.target);
            }, true);
            document.body.addEventListener('loadedmetadata', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(true, event.target);
            }, true);
            document.body.addEventListener('pause', function (event) {
              if (_this3.validateEvent(event)) _this3.pause(event.target, true);
            }, true);
            document.body.addEventListener('play', function (event) {
              if (_this3.validateEvent(event)) _this3.play(event.target, true);
            }, true);
            document.body.addEventListener('play', function (event) {
              _this3.sessionPlayed = true;
            }, { capture: true, once: true });
            document.body.addEventListener('playing', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(false, event.target);
            }, true);
            document.body.addEventListener('ratechange', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(true, event.target);
            }, true);
            document.body.addEventListener('seeked', function (event) {
              if (_this3.validateEvent(event)) {
                _this3.isLoading(false, event.target);
                _this3.respectRandom = true;
                _this3.saveCurrentTime(event.target);
              }
            }, true);
            document.body.addEventListener('seeking', function (event) {
              if (_this3.validateEvent(event)) {
                _this3.isLoading(true, event.target);
                _this3.respectRandom = false;
              }
            }, true);
            document.body.addEventListener('stalled', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(true, event.target, undefined, false);
            }, true);
            document.body.addEventListener('suspend', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(true, event.target, undefined, false);
            }, true);
            // is triggered repeatingly during playback
            document.body.addEventListener('timeupdate', function (event) {
              if (_this3.validateEvent(event)) {
                _this3.isLoading(false, event.target);
                // make sure ipfsLoading is removed when it is playing
                if (event.target === _this3.currentControl) {
                  event.target.classList.remove('ipfsLoading');
                  var source = null;
                  if (source = event.target.querySelector('source')) source.classList.remove('ipfsLoading');
                }
                _this3.saveCurrentTime(event.target);
                _this3.setDocumentTitle();
                // after error there was the case that the button wouldn't switch to play
                _this3.playBtn.classList.add('is-playing');
              }
            }, true);
            // keep all at same volume
            document.body.addEventListener('volumechange', function (event) {
              if (_this3.validateEvent(event)) _this3.setVolume(event.target.volume);
            }, true);
            document.body.addEventListener('waiting', function (event) {
              if (_this3.validateEvent(event)) _this3.isLoading(true, event.target, undefined, false);
            }, true);
            // keyboard
            if (!this.isSender) {
              document.body.addEventListener('keydown', function (event) {
                if (event.keyCode === 32 || event.keyCode === 37 || event.keyCode === 39 || event.keyCode === 38 || event.keyCode === 40 || event.keyCode === 112) {
                  // open player with "F1"
                  if (event.keyCode === 112) {
                    event.preventDefault();
                    _this3.openPlayer(undefined, true);
                    // volume change
                  } else if (event.keyCode === 38 || event.keyCode === 40) {
                      _this3.setVolume((Number(localStorage.getItem('lastVolume') || 1) + (event.keyCode === 38 ? 0.1 : -0.1)).toFixed(4));
                      // pause, play
                    } else if (event.keyCode === 32) {
                        // spacebar
                        if (_this3.currentControl.paused) {
                          _this3.play();
                        } else {
                          _this3.pauseAll();
                        }
                        // prev, next
                      } else if (event.keyCode === 37) {
                          // left
                          if (!isNaN(_this3.prevTimestamp) && _this3.prevTimestamp + _this3.keyDownTollerance < Date.now()) {
                            _this3.seekPrev();
                          }
                          if (!_this3.prevTimestamp) _this3.prevTimestamp = Date.now();
                          // right
                        } else if (event.keyCode === 39) {
                            if (!isNaN(_this3.nextTimestamp) && _this3.nextTimestamp + _this3.keyDownTollerance < Date.now()) {
                              _this3.seekNext();
                            }
                            if (!_this3.nextTimestamp) _this3.nextTimestamp = Date.now();
                          }
                }
              }, true);
              document.body.addEventListener('keyup', function (event) {
                // prev, next
                if (event.keyCode === 37 || event.keyCode === 39) {
                  event.preventDefault();
                  // left
                  if (event.keyCode === 37) {
                    if (_this3.prevTimestamp + _this3.keyDownTollerance >= Date.now()) _this3.prev();
                    _this3.prevTimestamp = undefined;
                    // right
                  } else if (event.keyCode === 39) {
                      if (_this3.nextTimestamp + _this3.keyDownTollerance >= Date.now()) _this3.next();
                      _this3.nextTimestamp = undefined;
                    }
                }
              }, true);
            }
          }
        }, {
          key: 'renderCSS',
          value: function renderCSS() {
            return '\n      <style>\n        #' + this.id + ' {\n          display: block !important;\n        }\n        #' + this.id + ' section.controls {\n          background-color: darkslategrey;\n          display: none;\n          grid-template-areas: "title title title title clo"\n                                "prev seekprev play seeknext next"\n                                "repeat sleep sleep sleep sleep";\n          grid-template-rows: 1fr 4fr 1fr;\n          grid-template-columns: repeat(5, 1fr);\n          height: 100%;\n          left: 0;\n          margin: auto;\n          opacity: 0.95;\n          padding: 5px;\n          position: fixed;\n          top: 0;\n          width: 100%;\n          z-index: 9999;\n        }\n        @media only screen and (max-width: 400px) {\n          #' + this.id + ' section.controls {\n            grid-template-areas: "title title title clo"\n                                 "play play play play"\n                                 "prev seekprev seeknext next"\n                                 "repeat sleep sleep sleep";\n            grid-template-rows: 1fr 2fr 2fr 1fr;\n            grid-template-columns: repeat(4, 1fr);\n          }\n        }\n        #' + this.id + ' section.controls.open {\n          display: grid;\n        }\n        #' + this.id + ' section.controls > i {\n          cursor: pointer;\n          font-size: min(15vh, 15vw);\n          height: 100%;\n          user-select: none;\n          width: 100%;\n        }\n        #' + this.id + ' section.controls > i > div {\n          align-items: center;\n          display: flex;\n          height: 100%;\n          justify-content: center;\n          width: 100%;\n        }\n        #' + this.id + ' section.controls > i:hover, #' + this.id + ' section.controls > i:hover > div {\n          color: #c5bbbb;\n        }\n        #' + this.id + ' section.controls > div {\n          font-size: min(5vh, 5vw);\n        }\n        #' + this.id + ' section.controls > i, #' + this.id + ' section.controls div {\n          color: white;\n          font-style: normal;\n        }\n        #' + this.id + ' section.controls > i, #' + this.id + ' section.controls > div {\n          align-items: center;\n          display: flex;\n          justify-content: center;\n        }\n        #' + this.id + ' section.controls > .title {\n          cursor: pointer;\n          grid-area: title;\n          justify-content: start;\n          overflow: hidden;\n        }\n        #' + this.id + ' section.controls > .title > span {\n          white-space: nowrap;\n        }\n        #' + this.id + ' section.controls > .title > span.marquee {\n          animation: marquee 10s linear infinite;\n          animation-delay: 2s;\n        }\n        #' + this.id + ' section.controls > .clo {\n          grid-area: clo;\n        }\n        #' + this.id + ' section.controls > .prev {\n          grid-area: prev;\n        }\n        #' + this.id + ' section.controls > .seekprev {\n          grid-area: seekprev;\n        }\n        #' + this.id + ' section.controls > .play {\n          font-weight: bolder;\n          grid-area: play;\n        }\n        #' + this.id + ' section.controls > .play > div.pause {\n          display: none;\n        }\n        #' + this.id + ' section.controls > .play.is-playing > div.pause {\n          display: flex;\n        }\n        #' + this.id + ' section.controls > .play.is-playing > div.play {\n          display: none;\n        }\n        #' + this.id + ' section.controls > .seeknext {\n          grid-area: seeknext;\n        }\n        #' + this.id + ' section.controls > .next {\n          grid-area: next;\n        }\n        #' + this.id + ' section.controls > .repeat {\n          grid-area: repeat;\n        }\n        #' + this.id + ' section.controls > .repeat > div.repeat-one, #' + this.id + ' section.controls > .repeat > div.random, #' + this.id + ' section.controls > .repeat > div.loop-machine {\n          display: none;\n        }\n        #' + this.id + ' section.controls > .repeat.repeat-one > div.repeat-one, #' + this.id + ' section.controls > .repeat.random > div.random, #' + this.id + ' section.controls > .repeat.loop-machine > div.loop-machine {\n          display: flex;\n        }\n        #' + this.id + ' section.controls > .repeat.repeat-one > div.repeat-all, #' + this.id + ' section.controls > .repeat.repeat-one > div.random, #' + this.id + ' section.controls > .repeat.repeat-one > div.loop-machine,\n        #' + this.id + ' section.controls > .repeat.random > div.repeat-all,  #' + this.id + ' section.controls > .repeat.random > div.repeat-one,  #' + this.id + ' section.controls > .repeat.random > div.loop-machine,\n        #' + this.id + ' section.controls > .repeat.loop-machine > div.repeat-all,  #' + this.id + ' section.controls > .repeat.loop-machine > div.repeat-one,  #' + this.id + ' section.controls > .repeat.loop-machine > div.random {\n          display: none;\n        }\n        #' + this.id + ' section.controls > .sleep {\n          align-content: center;\n          display: flex;\n          flex-wrap: wrap;\n          grid-area: sleep;\n        }\n        #' + this.id + ' section.controls > .sleep > span {\n          margin-right: 15px;\n        }\n        #' + this.id + ' section.controls > .sleep > input, #' + this.id + ' section.controls > .sleep > span > select {\n          border: 0;\n          color: black;\n          text-align: center;\n        }\n        #' + this.id + ' section.controls > .sleep > span > select {\n          background: transparent;\n          color: white;\n        }\n        #' + this.id + ' section.controls > .sleep > span > select > option {\n          color: black;\n        }\n        #' + this.id + ' section.controls > .sleep > input.active {\n          border: 3px solid;\n          animation: active 3s linear infinite;\n        }\n        #' + this.id + '.loop-machine > section.controls > .prev, #' + this.id + '.loop-machine > section.controls > .seekprev,\n        #' + this.id + '.loop-machine > section.controls > .next, #' + this.id + '.loop-machine > section.controls > .seeknext {\n          display: none;\n        }\n        #' + this.id + ' section.controls > .play > div.loading {\n          animation: loading 1s linear infinite;\n          background-image: none;\n          border-color: gray;\n          border-radius: 50%;\n          border-right-color: transparent !important;\n          border: min(4vh, 4vw) solid white;\n          box-shadow: 0 0 min(10vh, 10vw) min(1vh, 1vw) lightgray;\n          display: none;\n          height: min(15vh, 15vw);\n          width: min(15vh, 15vw);\n        }\n        #' + this.id + '.loading > section.controls > .play > div.loading {\n          display: inline-block;\n        }\n        #' + this.id + '.loading > section.controls > .play > div.play, #' + this.id + '.loading > section.controls > .play > div.pause {\n          display: none;\n        }\n        #' + this.id + ' > section.controls > .play > div.pause > .glyphicon-stop {\n          display: none;\n        }\n        /*\n        #' + this.id + '.random > section.controls > .play > div.pause > .glyphicon-stop {\n          display: block;\n        }\n        #' + this.id + '.random > section.controls > .play > div.pause > .glyphicon-pause {\n          display: none;\n        }\n        */\n\n        @keyframes active {\n          from {border-color: rgb(255, 0, 0, 0);}\n          50% {border-color: rgb(255, 0, 0, 1);}\n          to {border-color: rgb(255, 0, 0, 0);}\n        }\n        @keyframes marquee {\n          from {transform: translateX(51%);}\n          to {transform: translateX(-101%);}\n        }\n        @keyframes loading{\n          from {transform: rotate(0deg); opacity: 0.2;}\n          50% {transform: rotate(180deg); opacity: 1.0;}\n          to {transform: rotate(360deg); opacity: 0.2;}\n        }\n      </style>\n    ';
          }
        }, {
          key: 'renderHTML',
          value: function renderHTML() {
            var css = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

            var section = document.createElement('section');
            section.setAttribute('id', this.id);
            section.innerHTML = '\n      ' + css + '\n      <a href="#" class="player">&#9836;&nbsp;<span class="tiny">Player</span></a>\n      <section class="controls">\n        <div class="title"><span>...</span></div><i class="clo"><span class="glyphicon glyphicon-remove"></span></i>\n        <i class="prev"><span class="glyphicon glyphicon-step-backward"></i><i class="seekprev"><span class="glyphicon glyphicon-backward"></span></span></i>\n          <i class="play"><div class="play"><span class="glyphicon glyphicon-play"></span></div><div class="pause"><span class="glyphicon glyphicon-pause"></span><span class="glyphicon glyphicon-stop"></span></div><div class="loading"></div></i>\n        <i class="seeknext"><span class="glyphicon glyphicon-forward"></span></i><i class="next"><span class="glyphicon glyphicon-step-forward"></i>\n        <i class="repeat">\n          <div class="repeat-all"><span class="glyphicon glyphicon-refresh"></span></div><div class="repeat-one"><span class="glyphicon glyphicon-repeat"></span></div><div class="random"><span class="glyphicon glyphicon-random"></span></div><div class="loop-machine"><span class="glyphicon glyphicon-equalizer"></span></div>\n        </i><div class="sleep"><span><select name="sleepMode">\n          <option value="Sleep">Pause</option>\n          <option value="Wake">Play</option>\n        </select> in (min.):</span><input type="number" placeholder="0"></div>\n      </section>\n    ';
            this.html.replaceWith(section);
            this.html = section;
            this.htmlPlaceholder.innerHTML = '<span class="player">&#9836;&nbsp;<span class="tiny">Player</span></span>';
            return section;
          }
        }, {
          key: 'addControlsBehavior',
          value: function addControlsBehavior(section) {
            var _this4 = this;

            // title
            this.titleText = section.querySelector('.title span');
            section.querySelector('.title').addEventListener('click', function (event) {
              return _this4.scrollToEl();
            });
            // open/close player
            this.playerControls = section.querySelector('.controls');
            section.querySelector('.player').addEventListener('click', function (event) {
              event.preventDefault();
              _this4.openPlayer();
            });
            section.querySelector('.clo').addEventListener('click', function (event) {
              return _this4.playerControls.classList.remove('open');
            });
            // play
            this.playBtn = section.querySelector('.play');
            this.playBtn.querySelector('.play').addEventListener('click', function (event) {
              return _this4.play();
            });
            this.playBtn.querySelector('.pause').addEventListener('click', function (event) {
              return _this4.pause();
            });
            this.playBtn.querySelector('.loading').addEventListener('click', function (event) {
              if (!_this4.loadingClickTimeout) _this4.loadingClickTimeout = setTimeout(function () {
                _this4.isLoading(false, _this4.currentControl, true);
                _this4.loadingClickTimeout = null;
              }, 200);
            });
            this.playBtn.querySelector('.loading').addEventListener('dblclick', function (event) {
              clearTimeout(_this4.loadingClickTimeout);
              _this4.loadingClickTimeout = null;
              var source = null;
              if ((source = _this4.currentControl.querySelector('source')) && typeof source.onerror === 'function') {
                // if it is not already ipfs.cat then trigger it
                if (!_this4.hasError(_this4.currentControl)) source.onerror();
              }
            });
            // prev, next
            section.querySelector('.prev').addEventListener('click', function (event) {
              return _this4.prev();
            });
            section.querySelector('.next').addEventListener('click', function (event) {
              return _this4.next();
            });
            // seek prev, next
            section.querySelector('.seekprev').addEventListener('click', function (event) {
              return _this4.seekPrev();
            });
            section.querySelector('.seeknext').addEventListener('click', function (event) {
              return _this4.seekNext();
            });
            // repeat
            this.repeatBtn = section.querySelector('.repeat');
            this.repeatBtn.querySelector('.repeat-all').addEventListener('click', function (event) {
              return _this4.setMode('repeat-one');
            });
            this.repeatBtn.querySelector('.repeat-one').addEventListener('click', function (event) {
              return _this4.setMode('random');
            });
            this.repeatBtn.querySelector('.random').addEventListener('click', function (event) {
              return _this4.setMode('loop-machine');
            });
            this.repeatBtn.querySelector('.loop-machine').addEventListener('click', function (event) {
              return _this4.setMode('repeat-all');
            });
            // sleep timer
            section.querySelector('.sleep input').addEventListener('change', function (event) {
              if (event.target && !isNaN(Number(event.target.value))) _this4.setTimer(event.target, event.target.value, section.querySelector('.sleep [name=sleepMode]').value === 'Sleep' ? 'pauseAll' : 'play');
            });
          }
        }, {
          key: 'validateEvent',
          value: function validateEvent(event) {
            return event.target && event.target.controls;
          }
        }, {
          key: 'setVolume',
          value: function setVolume() {
            var volume = arguments.length <= 0 || arguments[0] === undefined ? Number(localStorage.getItem('lastVolume') || 1) : arguments[0];

            volume = volume > 1 ? 1 : volume < 0 ? 0 : volume;
            this.allControls.forEach(function (control) {
              return control.volume = volume;
            });
            localStorage.setItem('lastVolume', volume);
          }
        }, {
          key: 'scrollToEl',
          value: function scrollToEl() {
            var el = arguments.length <= 0 || arguments[0] === undefined ? this.currentControl : arguments[0];

            var rect = el.getBoundingClientRect();
            // check if the element is outside the viewport, otherwise don't scroll
            if (rect && (rect.top < 0 || rect.left < 0 || rect.bottom > (window.innerHeight || document.documentElement.clientHeight) || rect.right > (window.innerWidth || document.documentElement.clientWidth))) {
              setTimeout(function () {
                el.focus();
                el.scrollIntoView({ block: 'start', inline: 'nearest', behavior: 'smooth' });
              }, 500);
            }
          }
        }, {
          key: 'saveCurrentTime',
          value: function saveCurrentTime(control) {
            // don't save a tollerance of 10sec
            var currentTime = control.currentTime && control.currentTime > this.saveTollerance && control.currentTime < control.duration - this.saveTollerance ? control.currentTime : 0;
            if (currentTime) {
              localStorage.setItem('currentTime_' + control.id, currentTime);
            } else if (localStorage.getItem('currentTime_' + control.id) !== null) {
              localStorage.removeItem('currentTime_' + control.id);
            }
          }
        }, {
          key: 'loadCurrentTime',
          value: function loadCurrentTime(control) {
            var removeItem = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

            var currentTime = Number(localStorage.getItem('currentTime_' + control.id)) || 0;
            if (currentTime && currentTime !== control.currentTime && !(this.respectRandom && this.mode === 'random')) {
              this.setCurrentTime(control, currentTime, true);
              if (removeItem) localStorage.removeItem('currentTime_' + control.id); // only to be set once, then can be deleted
            }
          }
        }, {
          key: 'setCurrentTime',
          value: function setCurrentTime(control) {
            var time = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
            var ignoreSeeking = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

            if (isNaN(time)) time = 0;
            if (ignoreSeeking || !control.seeking) control.currentTime = time;
          }
        }, {
          key: 'getControlTitle',
          value: function getControlTitle() {
            var control = arguments.length <= 0 || arguments[0] === undefined ? this.currentControl : arguments[0];

            var text = '...';
            if (!control) return text;
            var figcaption = control.parentElement && control.parentElement.querySelector('figcaption') && control.parentElement.querySelector('figcaption').textContent || '';
            return figcaption ? figcaption : control.getAttribute('data-filename') ? control.getAttribute('data-filename') : control.getAttribute('download') ? control.getAttribute('download') : text;
          }
        }, {
          key: 'setTitleText',
          value: function setTitleText(titleText, control) {
            if (titleText === undefined) titleText = this.titleText;

            titleText.textContent = this.getControlTitle(control);
            if (titleText.offsetWidth > titleText.parentElement.offsetWidth) {
              titleText.classList.add('marquee');
            } else {
              titleText.classList.remove('marquee');
            }
          }
        }, {
          key: 'setDocumentTitle',
          value: function setDocumentTitle() {
            var _this5 = this;

            this.documentTitle = document.title;
            var length = -1;
            /*
            const progressIcons = ['', '', '', '']
            let progressIconCounter = -1
            const progress = () => progressIcons[(progressIconCounter = progressIconCounter + 1 < progressIcons.length ? progressIconCounter + 1 : 0)]
            */
            this.setDocumentTitle = function () {
              var reset = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

              if (reset) {
                length = -1;
                return document.title = _this5.documentTitle;
              }
              var title = _this5.getControlTitle() + ' | ';
              length = length + 1 >= title.length ? 0 : length + 1;
              //document.title = `${progress()} ${title.substr(length)} | ${title.substr(0, length)}`
              document.title = title.substr(length) + title.substr(0, length);
            };
          }
        }, {
          key: 'openPlayer',
          value: function openPlayer() {
            var playerControls = arguments.length <= 0 || arguments[0] === undefined ? this.playerControls : arguments[0];
            var toggle = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

            if (!this.sessionPlayed) this.play();
            var command = toggle ? 'toggle' : 'add';
            playerControls.classList[command]('open');
            var header = null;
            if (playerControls.classList.contains('open') && (header = document.querySelector('body > header'))) header.classList.add('down');
            this.setTitleText();
          }
        }, {
          key: 'isPlayerOpen',
          value: function isPlayerOpen() {
            var playerControls = arguments.length <= 0 || arguments[0] === undefined ? this.playerControls : arguments[0];

            return playerControls.classList.contains('open');
          }
        }, {
          key: 'play',
          value: function play() {
            var control = arguments.length <= 0 || arguments[0] === undefined ? this.currentControl : arguments[0];
            var eventTriggered = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
            var respectLoopMachine = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

            this.isLoading(true, control, !eventTriggered);
            if (!eventTriggered) {
              if (respectLoopMachine && this.mode === 'loop-machine') return this.playAll();
              if (control.paused) return control.play(); // this wil trigger the event, which in turn will trigger this function
            }
            if (this.mode === 'random' && !this.randomQueue.includes(control)) this.randomQueue.push(control);
            this.currentControl = control;
            this.playBtn.classList.add('is-playing');
            this.setTitleText(undefined, control);
            this.setDocumentTitle();
            if (this.mode !== 'loop-machine') this.pauseAll(control);
            this.loadCurrentTime(control); // do this because ios does not swollow currentTime set at loadedmetadata
          }
        }, {
          key: 'playAll',
          value: function playAll() {
            var _this6 = this;

            var except = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

            this.allPlayableControls.forEach(function (control) {
              if (control !== except && control.paused) _this6.play(control, undefined, false);
            });
          }
        }, {
          key: 'pause',
          value: function pause() {
            var control = arguments.length <= 0 || arguments[0] === undefined ? this.currentControl : arguments[0];
            var eventTriggered = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
            var respectLoopMachine = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

            if (!eventTriggered) {
              if (respectLoopMachine && this.mode === 'loop-machine') return this.pauseAll();
              if (!control.paused) return control.pause(); // this wil trigger the event, which in turn will trigger this function
            }
            if (this.currentControl === control) this.playBtn.classList.remove('is-playing');
            this.isLoading(false, control, !eventTriggered); // important: isLoading must be after is-playing, otherwise timeout gets triggered
            this.setDocumentTitle(true); // reset document.title to original title
          }
        }, {
          key: 'pauseAll',
          value: function pauseAll() {
            var _this7 = this;

            var except = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

            this.allControls.forEach(function (control) {
              if (control !== except) _this7.pause(control, undefined, false);
            });
          }
        }, {
          key: 'prev',
          value: function prev() {
            var resetTrack = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
            var respectRandom = arguments.length <= 1 || arguments[1] === undefined ? this.respectRandom : arguments[1];

            var controls = this.allPlayableControls;
            if (resetTrack && this.currentControl.currentTime > this.prevResetTollerance) {
              this.play();
              return this.setCurrentTime(this.currentControl, undefined, true);
            } else if (respectRandom && this.mode === 'random') return this.prevRandom();
            var index = this.currentControlIndex;
            var control = controls[index - 1 < 0 ? controls.length - 1 : index - 1];
            if (control) {
              this.play(control);
              return control;
            }
            return null;
          }
        }, {
          key: 'next',
          value: function next(onlyReady) {
            var respectRandom = arguments.length <= 1 || arguments[1] === undefined ? this.respectRandom : arguments[1];

            if (respectRandom && this.mode === 'random') return this.nextRandom(onlyReady);
            var controls = onlyReady ? this.allReadyControls : this.allPlayableControls;
            var index = controls.indexOf(this.currentControl) !== -1 ? controls.indexOf(this.currentControl) : this.currentControlIndex;
            var control = controls[index + 1 >= controls.length ? 0 : index + 1];
            if (control) {
              this.play(control);
              return control;
            }
            return null;
          }
        }, {
          key: 'prevRandom',
          value: function prevRandom() {
            var control = this.randomQueue.splice(-1)[0];
            if (control) {
              this.play(control);
              return control;
            }
            return this.prev(false, false);
          }
        }, {
          key: 'nextRandom',
          value: function nextRandom(onlyReady) {
            var _this8 = this;

            var allReadyControls = [];
            var controls = [];
            if (onlyReady === false) {
              controls = this.allPlayableControls;
            } else {
              allReadyControls = this.allReadyControls;
              controls = !!allReadyControls.length ? allReadyControls : this.allPlayableControls;
            }
            if (this.randomQueue.length >= controls.length) this.randomQueue.splice(0, Math.ceil(this.randomQueue.length / 2)); // clear ranedom queue to release songs to be played random
            controls = controls.filter(function (control) {
              return !_this8.randomQueue.includes(control);
            });
            var control = controls[Math.floor(Math.random() * controls.length)];
            if (control) {
              this.play(control);
              return control;
            }
            return this.next(onlyReady, false);
          }
        }, {
          key: 'seekPrev',
          value: function seekPrev() {
            var control = this.currentControl;
            if (control.currentTime > this.seekTime) {
              this.setCurrentTime(control, control.currentTime - this.seekTime);
            } else if (control = this.prev(false)) {
              this.setCurrentTime(control, control.duration - this.seekTime);
            }
          }
        }, {
          key: 'seekNext',
          value: function seekNext() {
            var control = this.currentControl;
            if (control.currentTime + this.seekTime < control.duration) {
              this.setCurrentTime(control, control.currentTime + this.seekTime);
            } else if (control = this.next()) {
              this.setCurrentTime(control, this.seekTime);
            }
          }
        }, {
          key: 'setMode',
          value: function setMode(mode) {
            if (mode) this.mode = mode;
            this.repeatBtn.className = 'repeat'; // reset to initial
            this.repeatBtn.classList.add(this.mode);
            this.html.className = this.mode;
          }

          // only force with user interaction eg. play / pause
        }, {
          key: 'isLoading',
          value: function isLoading(loading, control) {
            var _this9 = this;

            var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
            var doClearTimeout = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

            if (!force && control !== this.currentControl) return false;
            // classes for the player interface
            if (this.mode !== 'loop-machine' && loading) {
              this.html.classList.add('loading');
            } else {
              this.html.classList.remove('loading');
            }
            // skip to next if song fails to play
            if (doClearTimeout) {
              clearTimeout(this.waitToPlayTimeout);
              this.waitToPlayTimeout = null;
            }
            if (this.mode === 'random' && this.playBtn.classList.contains('is-playing')) {
              if (this.waitToPlayTimeout !== null) return; // return in case there is still a timeout running
              this.waitToPlayTimeout = setTimeout(function () {
                _this9.waitToPlayTimeout = null;
                // keep this inside the timer, otherwise it can trigger a fast loop
                if (_this9.hasError(control) || !!control.duration && control.currentTime >= control.duration - 10) {
                  if (!!control.duration && control.currentTime >= control.duration - 10 && (_this9.mode === 'repeat-one' || _this9.mode === 'loop-machine')) {
                    return _this9.play();
                  } else {
                    return _this9.next();
                  }
                }
                var key = _this9.allControls.indexOf(control);
                var step = key === -1 ? 1 : _this9.isLoadingMemory.get(key) || 1;
                _this9.isLoadingMemory.set(key, step + 1);
                switch (step) {
                  case 1:
                    if (control.currentTime > _this9.seekTime) {
                      _this9.seekPrev();
                    } else {
                      _this9.seekNext();
                    }
                    break;
                  case 2:
                    _this9.nextRandom();
                    var source = null;
                    if ((source = control.querySelector('source')) && typeof source.onerror === 'function' && !_this9.hasError(control)) source.onerror();
                    break;
                  default:
                    _this9.nextRandom();
                    break;
                }
              }, this.waitToPlayMs);
            }
          }

          // value is expected in minutes
        }, {
          key: 'setTimer',
          value: function setTimer(input, value) {
            var _this10 = this;

            var command = arguments.length <= 2 || arguments[2] === undefined ? 'pauseAll' : arguments[2];

            input.value = value = Math.floor(value);
            clearTimeout(this.timer);
            if (!value || value <= 0) {
              input.classList.remove('active');
              input.value = 0;
              this[command]();
            } else {
              input.classList.add('active');
              this.timer = setTimeout(function () {
                return _this10.setTimer(input, value - 1, command);
              }, 60000);
            }
            input.blur();
          }
        }, {
          key: 'onError',
          value: function onError(control) {
            var _this11 = this;

            // once reset the html element
            if (control && control.id && !this.onErrorExtendedToSourceIds.includes(control.id)) {
              (function () {
                var source = null;
                if ((source = control.querySelector('source')) && typeof source.onerror === 'function') {
                  control.addEventListener('error', function (event) {
                    control.sst_hasError = true;
                    _this11.isLoading(true, control);
                    // if it is not already ipfs.cat then trigger it
                    if (!_this11.hasError(control)) source.onerror();
                  }, { once: true });
                  source.addEventListener('error', function (event) {
                    control.sst_hasError = true;
                    _this11.isLoading(true, control);
                  }, { once: true });
                }
                _this11.onErrorExtendedToSourceIds.push(control.id);
              })();
            }
          }
        }, {
          key: 'hasError',
          value: function hasError(control) {
            return control.classList.contains('ipfsLoading') || control.sst_hasError;
          }
        }, {
          key: 'filterByReadyState',
          value: function filterByReadyState(controls) {
            var state = arguments.length <= 1 || arguments[1] === undefined ? 9 : arguments[1];

            return controls.filter(function (control) {
              switch (state) {
                case 9:
                  return !!control.duration && control.readyState >= 4;
                case 8:
                  return !!control.duration && control.readyState >= 3;
                case 7:
                  return !!control.duration && control.readyState >= 2;
                case 6:
                  return !!control.duration && control.readyState >= 1;
                case 5:
                  return !!control.duration;
                case 0:
                  return true;
                default:
                  return control.readyState >= state;
              }
            });
          }
        }, {
          key: 'allControls',
          get: function get() {
            return _Array$from(document.querySelectorAll('[controls]'));
          }
        }, {
          key: 'allPlayableControls',
          get: function get() {
            var _this12 = this;

            // exclude any loading controls and error controls
            return this.allControls.filter(function (control) {
              return !_this12.hasError(control);
            });
          }
        }, {
          key: 'allReadyControls',
          get: function get() {
            var _this13 = this;

            var allControls = this.loadedmetadataControls;
            var state = 9; // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState + state 5 which means it has control.duration
            var controls = this.filterByReadyState(allControls, state); // 9
            while (state > 0 && (!controls.length || controls.every(function (control) {
              return _this13.randomQueue.includes(control);
            }))) {
              state--;
              controls = this.filterByReadyState(allControls, state); // (9 init 3 lines above), 8, 7, 6, 5, 4, 3, 2, 1, 0
            }
            return controls;
          }
        }, {
          key: 'loadedmetadataControls',
          get: function get() {
            var _this14 = this;

            return this._loadedmetadataControls.filter(function (control) {
              return _this14.allPlayableControls.includes(control);
            });
          }
        }, {
          key: 'currentControlIndex',
          set: function set(index) {
            localStorage.setItem('lastPlayed_' + location.hash, index === -1 ? 0 : index);
          },
          get: function get() {
            return Number(localStorage.getItem('lastPlayed_' + location.hash)) || 0;
          }
        }, {
          key: 'currentControl',
          set: function set(control) {
            this.currentControlIndex = this.allControls.indexOf(control);
          },
          get: function get() {
            return this.allControls[this.currentControlIndex] || document.createElement('audio');
          }
        }, {
          key: 'mode',
          set: function set(mode) {
            localStorage.setItem('mode_' + location.hash, mode);
          },
          get: function get() {
            return localStorage.getItem('mode_' + location.hash) || 'random';
          }
        }]);

        return Player;
      })();

      _export('default', Player);
    }
  };
});
$__System.register('2b', ['5', '6', '7', '27', '29', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterHTML, Player, _createClass, HTML;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterHTML = _4.MasterHTML;
		}, function (_5) {
			Player = _5['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			HTML = (function (_MasterHTML) {
				_inherits(HTML, _MasterHTML);

				function HTML(WebTorrentReceiver, WebTorrentSeeder, Editor, WebRTC, IPFS, EncryptDecrypt, parent) {
					_classCallCheck(this, HTML);

					_get(Object.getPrototypeOf(HTML.prototype), 'constructor', this).call(this, WebTorrentReceiver);

					this.WebTorrentSeeder = WebTorrentSeeder;
					this.Editor = Editor;
					this.WebRTC = WebRTC;
					this.IPFS = IPFS;
					this.EncryptDecrypt = EncryptDecrypt;
					this.parent = parent; // ref to App.js

					this.Player = new Player();
				}

				_createClass(HTML, [{
					key: 'createElements',
					value: function createElements(name) {
						var attach = arguments.length <= 1 || arguments[1] === undefined ? '#body' : arguments[1];

						var _this = this;

						var connection = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
						var isSender = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

						attach = $(attach).length > 0 ? attach : 'body';
						switch (name) {
							case 'open-or-join-room':
								this.idNames = ['txt-roomid', 'open-or-join-room', 'sender', 'receiver'];
								var header = $('<header class="down isTop">\n\t\t\t\t\t<div id="info" class="flex">\n\t\t\t\t\t\t<div class="offline">YOU ARE OFFLINE!!!</div>\n\t\t\t\t\t\t<iframe class="gh-button" src="https://ghbtns.com/github-btn.html?user=Weedshaker&amp;repo=PeerWebSite&amp;type=star&amp;count=true&amp;size=large" scrolling="0" width="160px" height="30px" frameborder="0"></iframe>\n\t\t\t\t\t\t<a href="https://github.com/Weedshaker/PeerWebSite" class="tiny" style="color:white">v. beta 0.8.23<span id="sw-version"></span>; Visit Github for more Infos!</a>\n\t\t\t\t\t\t<a href="' + location.href.replace(location.hash, '') + '" class="recycle">&#9851;&nbsp;<span class="tiny">New Site</span></a>\n\t\t\t\t\t</div>\n\t\t\t\t</header>');
								// add edit
								header.find('#info').append('<a href="#" class="edit">&#9997;&nbsp;<span class="tiny">' + (!isSender ? 'Edit!' : 'Abort Editing!') + '</span></a>');
								header.find('.edit').click(function (event) {
									event.preventDefault();
									if (!isSender) {
										_this.setHash(location.hash.substr(1));
										_this.saveData(undefined, _this.parent.receiveCont[0].innerHTML);
										if (_this.parent.checkHashType(location.hash) === 'ipfs' || _this.confirmData(undefined, _this.parent.receiveCont[0].innerHTML)) {
											location.reload();
										} else {
											_this.removeHashFromChannels(location.hash.substr(1));
											header.find('.edit').remove();
										}
									} else {
										_this.removeHashFromChannels(location.hash.substr(1));
										location.reload();
									}
								});
								// add download
								if (!isSender) {
									header.find('#info').append('<a href="#" class="download-all">&#9735;&nbsp;<span class="tiny">Download</span></a>');
									header.one('click', '.download-all', function (event) {
										event.preventDefault();
										var startCounterAt = _this.parent.checkHashType(location.hash) === 'magnet' ? -1 : 0; // IPFS always counts one even its webtorrent
										var counter = startCounterAt;
										var failedCount = startCounterAt;
										var total = startCounterAt;
										var done = false;
										var callback = function callback(success) {
											var count = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

											if (!success) failedCount++;
											if (count) counter++;
											done = counter >= total;
											header.find('.download-all > .tiny').html((done ? '' : '<span class="filesLoading"></span>') + '<span class="donwload-files-counter">' + counter + ' of ' + total + ' file' + (total === 1 ? '' : 's') + ' fetched of which <span style="color: ' + (failedCount === 0 ? 'green' : 'red') + '">' + failedCount + ' failed to download</span>.</span>');
											if (done) $('.download-all').addClass('done');
										};
										if (confirm('This feature does not yet support any progress by file size. WebTorrent + IPFS files will be downloaded as soon as available. Please, be patient... Do you want to continue?')) {
											total += _this.WebTorrent.getAllTorrentFiles(callback);
											total += _this.IPFS.getAllIPFSFiles(callback);
											callback(true, false);
										} else {
											$('.download-all').remove();
										}
										header.find('.download-all').click(function (event) {
											event.preventDefault();
											if (done) {
												$('.download-all').remove();
											} else if (confirm('Cancel downloads?')) {
												location.reload();
											}
										});
									});
								}
								// add player htmlelements
								header.find('#info').append('<section id="player"></section><section id="player-placeholder"></section>');
								this.containers = [header];
								this.stickyHeader(header);
								// specific only for receiver
								var headerReceiver = $('<div class="headerReceiver"><span class="qr"></span></div>');
								if (!isSender) this.addQrCode(headerReceiver, undefined, 'receiverLoading');
								// controls
								var controls = $('<div id="controls"></div>');
								this.createIpfsControls(controls);
								var counterWebTorrent = this.createWebtorrentControls(controls, isSender, headerReceiver);
								var webrtcButton = this.createWebrtcControls(controls, connection, isSender, headerReceiver);
								this.containers.push(controls);
								// main containers
								this.loadingAnimation = '<span class="blobLoading ' + (this.parent.checkHashType(location.hash) === 'magnet' ? 'torrentLoading' : this.parent.checkHashType(location.hash) === 'ipfs' ? 'ipfsLoading' : '') + '"></span><span class="blobLoadingText">Please, be patient. Decentralized content can take a while to load...</span>';
								var ipfsRegex = /^\=\"http.*?gateway\.ipfs\.io.*?\#js.*?\"$/;
								var notIpfs = this.parent.checkHashType(location.hash) !== 'ipfs' || !ipfsRegex.test(localStorage.getItem(location.hash)); /* ipfs javascript does not get triggered else */
								var sender = $('<div id="' + this.idNames[2] + '">' + (isSender && notIpfs ? localStorage.getItem(location.hash) || '' : '') + '</div>');
								this.containers.push(sender);
								var receiver = $('<div id="' + this.idNames[3] + '">' + (isSender ? 'WEBRTC response...' : notIpfs ? localStorage.getItem(location.hash) || this.loadingAnimation : this.loadingAnimation) + '</div>');
								this.containers.push(receiver);
								// hot-reloader
								/*
        // TODO: hot-reloader does not work anymore, better to fix when discarding jspm
        if(window.sst && window.sst.isDebug){
        	input.val($(`#${this.idNames[0]}`).val());
        	button.disabled = connection.sessionid == $(`#${this.idNames[0]}`).val();
        	if($.summernote){
        		$(`#${this.idNames[2]}`).summernote('destroy');
        	}
        	this.removeElements();
        }
        */
								this.containers.forEach(function (e) {
									$(attach).append(e);
								});

								$('#info').append(headerReceiver);

								this.Player.connect(isSender, header.get(0));

								return [sender, receiver, webrtcButton, counterWebTorrent];
						}
						return false;
					}
				}, {
					key: 'createWebrtcControls',
					value: function createWebrtcControls(controls, connection, isSender, headerReceiver) {
						var _this2 = this;

						// webrtc
						var input = $('<input id="' + this.idNames[0] + '" class="mui-panel" placeholder="' + (this.parent.checkHashType() === 'webrtc' ? location.hash.substr(1) : connection.token()) + '">');
						controls.append(input);
						// clipboard
						var clipboard = $('<input dir="rtl" type="text" class="mui-panel" id="clipboardInput">').hide();
						clipboard.keypress(function (e) {
							e.preventDefault();
							e.target.blur();
						});
						controls.append(clipboard);
						var button = $('<button id="' + this.idNames[1] + '" class="mui-btn mui-btn--webRTC"><span class="btnText">WebRTC (temporary):<br>Activate Live Session & Copy Link</span><span class="qr"></span></button>');
						var counterWebRTC = $('<span class="counter counterWebRTC">[0 connected]</span>');
						if (isSender) {
							$(button).find('.btnText').append(counterWebRTC);
						} else {
							headerReceiver.append(counterWebRTC);
						}
						this.WebRTC.api.peerCounterElements.push(counterWebRTC[0]);
						input.keypress(function (e) {
							if (e.keyCode == 13) {
								e.preventDefault();
								e.target.blur();
								button.click();
							}
						});
						controls.append(button);
						if (isSender) button.click(function (event) {
							// fix and define roomid aka link aka hash
							$('#txt-roomid').val($('#txt-roomid').val().replace(/\s/g, '') || $('#txt-roomid').attr('placeholder'));
							// switch input field with clipboard field
							input.hide();
							clipboard.show();
							// default behavior
							_this2.setHash($('#txt-roomid').val());
							_this2.saveData();
							_this2.addQrCode($(button));
							_this2.setTitle();
							// update the clipboard
							clipboard.val(location.href);
							_this2.copyToClipBoard('clipboardInput');
							_this2.informOnce('buttonWebRTC');
						});
						return button;
					}
				}, {
					key: 'createIpfsControls',
					value: function createIpfsControls(controls) {
						var _this3 = this;

						// ipfs
						var input = $('<input tabindex="-1" id="inputIPFS" class="mui-panel" placeholder="CID...">');
						input.keypress(function (e) {
							e.preventDefault();
							e.target.blur();
						});
						controls.append(input);
						var button = $('<button id="buttonIPFS" class="mui-btn mui-btn--primary"><span class="btnText">IPFS (rather permanent):<br>Take Snapshot & Copy Link</span><span class="qr"></span><span class="glyphicon glyphicon-floppy-open"></span></button>');
						controls.append(button);
						button.click(function (event) {
							_this3.addQrCode($(button), 'onlyLoading', 'ipfsLoading');
							_this3.EncryptDecrypt.encrypt(_this3.Editor.getData(undefined, true)).then(function (result) {
								var text = result.text;
								var encrypted = result.encrypted;

								_this3.IPFS.add('peerWebSite.txt', text).then(function (file) {
									// default behavior
									_this3.setHash('ipfs:' + file.cid);
									_this3.saveData();
									_this3.addQrCode($(button), undefined, 'ipfsLoading', encrypted);
									_this3.setTitle();
									// update the clipboard
									input.val(location.href);
									_this3.copyToClipBoard('inputIPFS');
								})['catch'](function (error) {
									return input.val('IPFS failed: ' + error);
								});
							})['catch'](function (error) {
								return input.val('Encrypt failed: ' + error);
							});
						});
						return button;
					}
				}, {
					key: 'createWebtorrentControls',
					value: function createWebtorrentControls(controls, isSender, headerReceiver) {
						var _this4 = this;

						// webtorrent
						var inputWebTorrent = $('<input tabindex="-1" id="inputWebTorrent" class="mui-panel" placeholder="MagnetURI...">');
						inputWebTorrent.keypress(function (e) {
							e.preventDefault();
							e.target.blur();
						});
						controls.append(inputWebTorrent);
						var buttonWebTorrent = $('<button id="buttonWebTorrent" class="mui-btn mui-btn--accent"><span class="btnText">WebTorrent (transitory):<br>Take Snapshot & Copy Link</span><span class="qr"></span><span class="glyphicon glyphicon-floppy-open"></span></button>');
						var counterWebTorrent = $('<span class="counter counterWebTorrent">[0 peers]</span>');
						if (isSender) {
							$(buttonWebTorrent).find('.btnText').append(counterWebTorrent);
						} else {
							headerReceiver.append(counterWebTorrent);
						}
						controls.append(buttonWebTorrent);
						var webTorrentCounterID = null;
						var torrentCreatedData = [];
						buttonWebTorrent.click(function (event) {
							_this4.addQrCode($(buttonWebTorrent), 'onlyLoading', 'torrentLoading');
							_this4.EncryptDecrypt.encrypt(_this4.Editor.getData(undefined, true)).then(function (result) {
								var text = result.text;
								var encrypted = result.encrypted;

								// must always be same file name 'peerWebSite' otherwise webtorrent gives us a new magicURI
								if (!torrentCreatedData.includes(text)) _this4.WebTorrentSeeder.api.seed(new File([text], 'peerWebSite.txt', { type: 'plain/text', endings: 'native' }), undefined, undefined, undefined, undefined, function (torrent) {
									// clear interval
									clearInterval(webTorrentCounterID);
									webTorrentCounterID = setInterval(function () {
										counterWebTorrent[0].textContent = '[' + torrent.numPeers + ' peer' + (torrent.numPeers === 1 ? '' : 's') + ']';
									}, 1000);
									// avoid creating the torrent twice
									torrentCreatedData.push(text);
									// default behavior
									_this4.setHash(torrent.magnetURI);
									_this4.saveData();
									_this4.addQrCode($(buttonWebTorrent), undefined, 'torrentLoading', encrypted);
									_this4.setTitle();
									// update the clipboard
									inputWebTorrent.val(location.href);
									_this4.copyToClipBoard('inputWebTorrent');
									torrent.on('error', function (error) {
										return inputWebTorrent.val('WebTorrent failed: ' + error);
									});
									_this4.informOnce('buttonWebTorrent');
								});
							})['catch'](function (error) {
								return input.val('Encrypt failed: ' + error);
							});
						});
						this.WebTorrentSeeder.client.on('error', function () {
							clearInterval(webTorrentCounterID);
							counterWebTorrent[0].textContent = '[ERROR! Please, reload.]';
						});
						return counterWebTorrent;
					}
				}, {
					key: 'setHash',
					value: function setHash(hash) {
						if (hash) {
							if (!(localStorage.getItem('channels') || '').includes('[#' + hash + ']')) localStorage.setItem('channels', '[#' + hash + ']' + (localStorage.getItem('channels') || ''));
							location.hash = hash;
							this.parent.checkHashType(); // sets attribute for hash type magnet, ipfs, webrtc
						}
					}
				}, {
					key: 'removeHashFromChannels',
					value: function removeHashFromChannels(hash) {
						if (hash && (localStorage.getItem('channels') || '').includes('[#' + hash + ']')) {
							localStorage.setItem('channels', (localStorage.getItem('channels') || '').replace('[#' + hash + ']', ''));
						}
					}
				}, {
					key: 'saveData',
					value: function saveData() {
						var key = arguments.length <= 0 || arguments[0] === undefined ? location.hash : arguments[0];
						var data = arguments.length <= 1 || arguments[1] === undefined ? this.Editor.getData() : arguments[1];
						var retry = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

						if (key && data && data.length >= 15 && !data.includes('blobLoadingText') && !this.EncryptDecrypt.isEncrypted(data)) {
							try {
								localStorage.setItem(key, data);
							} catch (error) {
								localStorage.clear();
								if (retry) this.saveData(key, data, false);
								console.warn('SST: LocalStorage ran ' + (!retry ? 'a second time ' : '') + 'into error and got cleared:' + error);
							}
						}
					}
				}, {
					key: 'confirmData',
					value: function confirmData() {
						var key = arguments.length <= 0 || arguments[0] === undefined ? location.hash : arguments[0];
						var data = arguments.length <= 1 || arguments[1] === undefined ? this.Editor.getData() : arguments[1];

						return localStorage.getItem(key) === data;
					}
				}, {
					key: 'copyToClipBoard',
					value: function copyToClipBoard(name) {
						var copyText = document.getElementById(name);
						/* Select the text field */
						copyText.select();
						copyText.setSelectionRange(0, 99999); /*For mobile devices*/

						/* Copy the text inside the text field */
						document.execCommand("copy");
					}
				}, {
					key: 'shareApi',
					value: function shareApi() {
						var url = arguments.length <= 0 || arguments[0] === undefined ? location.href : arguments[0];
						var text = arguments.length <= 1 || arguments[1] === undefined ? this.getFirstText() : arguments[1];

						if (text && navigator.share) {
							navigator.share({
								title: 'PeerWebSite',
								text: text,
								url: url
							}).then(function () {
								return console.log('Share was successful.');
							})['catch'](function (error) {
								return console.log('Sharing failed', error);
							});
						}
					}
				}, {
					key: 'setTitle',
					value: function setTitle() {
						var _this5 = this;

						var text = arguments.length <= 0 || arguments[0] === undefined ? this.getFirstText() : arguments[0];

						document.title = text && !text.includes('Please, be patient.') ? text : document.title;
						// TODO: find out why it sometimes keeps getting the information text, below a little hack to be removed once discovered
						if (text.includes('Please, be patient.')) setTimeout(function () {
							_this5.setTitle();
						}, 5000);
					}
				}, {
					key: 'getFirstText',
					value: function getFirstText() {
						var text = arguments.length <= 0 || arguments[0] === undefined ? this.Editor.getData() : arguments[0];

						var textNode = document.createElement('textarea');
						textNode.innerHTML = text;
						text = textNode.textContent.match(/>.*?([a-zA-Z\d]{1}[^>]*?)</);
						return text && text.length && text[1] ? text[1] : '';
					}
				}, {
					key: 'addQrCode',
					value: function addQrCode($el) {
						var text = arguments.length <= 1 || arguments[1] === undefined ? location.href : arguments[1];

						var _this6 = this;

						var loadingClass = arguments.length <= 2 || arguments[2] === undefined ? 'blobLoading' : arguments[2];
						var encrypted = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

						var $oldImg = $el.find('img');
						// only loading simply makes the loading icon appearing
						var src = 'https://api.qrserver.com/v1/create-qr-code/?data="' + this.encode(text) + '"';
						if (!$oldImg || !$oldImg.length || $oldImg.attr('src') !== src) {
							(function () {
								var img = document.createElement(text === 'onlyLoading' ? 'span' : 'img');
								var $span = $el.find('.qr');
								img.src = src;
								img.classList.add(loadingClass);
								img.addEventListener('load', function (event) {
									return img.classList.remove(loadingClass);
								});
								var errorCounter = 0;
								if (text !== 'onlyLoading') img.onerror = function (error) {
									if (errorCounter < 3) {
										img.src = img.src;
									} else {
										$span.html('');
									}
									errorCounter++;
								};
								$span.html(img);
								if (encrypted) $span.append('<span class="glyphicon glyphicon-lock"></span>');
								$el.addClass('hasQr');
								$span.off('click').click(function (event) {
									event.stopPropagation();
									if (text !== 'onlyLoading') _this6.addTinyUrl($el, text);
									if (!$span.hasClass('open')) _this6.shareApi();
									$span.toggleClass('open');
								});
							})();
						}
					}
				}, {
					key: 'addTinyUrl',
					value: function addTinyUrl($el) {
						var text = arguments.length <= 1 || arguments[1] === undefined ? location.href : arguments[1];

						var $oldLink = $el.find('a');
						var resource = 'https://tinyurl.com/api-create.php?url=' + this.encode(text);
						if (!$oldLink || !$oldLink.length || $oldLink.attr('resource') !== resource) {
							fetch(resource).then(function (res) {
								return res.text();
							}).then(function (tinyUrl) {
								var link = document.createElement('a');
								link.href = tinyUrl;
								link.setAttribute('resource', resource);
								link.textContent = tinyUrl;
								var $span = $el.find('.qr');
								$span.append(link);
							});
						}
					}
				}, {
					key: 'encode',
					value: function encode(text) {
						return encodeURIComponent(text.trim());
					}
				}, {
					key: 'informOnce',
					value: function informOnce() {
						var name = arguments.length <= 0 || arguments[0] === undefined ? 'warn' : arguments[0];
						var text = arguments.length <= 1 || arguments[1] === undefined ? 'Use a VPN or IPFS, if your network blocks WebRTC/WebTorrent connections! Especially 3g/4g networks tend to block ice servers.' : arguments[1];

						if (!localStorage.getItem(name)) {
							alert(text);
							localStorage.setItem(name, 'informed');
						}
					}
				}, {
					key: 'stickyHeader',
					value: function stickyHeader($header) {
						var listenToScroll = function listenToScroll() {
							var lastScroll = window.scrollY;
							setTimeout(function () {
								// is top
								if (window.scrollY <= $header.height() + 5) {
									$header.addClass('down');
									$header.addClass('isTop');
								} else {
									// if header sub window (eg. player) is open || direction scroll && min 30 pixel scrolled
									if (!!document.querySelector('header > div > section > section.open') || Math.abs(window.scrollY - lastScroll) > 30 && window.scrollY <= lastScroll) {
										$header.addClass('down');
									} else if (Math.abs(window.scrollY - lastScroll) > 30) {
										$header.removeClass('down');
									}
									$header.removeClass('isTop');
								}
								window.addEventListener('scroll', listenToScroll, { once: true });
							}, 200);
						};
						window.addEventListener('scroll', listenToScroll, { once: true });
					}
				}]);

				return HTML;
			})(MasterHTML);

			_export('HTML', HTML);
		}
	};
});
$__System.register('2c', ['5', '6', '7', '2e', '2d'], function (_export) {
	var _get, _inherits, _classCallCheck, _Object$assign, MasterWebTorrent, WebTorrentSeeder;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_e) {
			_Object$assign = _e['default'];
		}, function (_d) {
			MasterWebTorrent = _d.MasterWebTorrent;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			WebTorrentSeeder = (function (_MasterWebTorrent) {
				_inherits(WebTorrentSeeder, _MasterWebTorrent);

				function WebTorrentSeeder(container) {
					_classCallCheck(this, WebTorrentSeeder);

					_get(Object.getPrototypeOf(WebTorrentSeeder.prototype), 'constructor', this).call(this, container);
					// onerror node error handling global
					this.appended_onerror = 'window.sst_WebTorrentSeeder_blobsRefresh';
					window.sst_WebTorrentSeeder_blobsRefresh = this.blobsRefresh.bind(this);

					// hooks
					this.api = _Object$assign(this.api, {
						/**
       * seed (upload) (api hook)
       * 
       * @param {File | FileList} files 
       * @param {string} text 
       * @param {HtmlNode} node 
       * @param {Object} [seedOpts=this.seedOpts] 
       * @param {Object} appendToOpts 
       * @param {Function} [seedCallback=(torrent) => {return this.appendTo(text, appendToOpts, appendToCallback, torrent);}] 
       * @param {Function} appendToCallback 
       * @returns 
       * @memberof MasterWebTorrent
       */
						seed: this.seed.bind(this),
						/**
       * Check if torrents are still loading
       * 
       * @returns boolean
       * @memberof MasterWebTorrent
       */
						areTorrentsLoading: this.areTorrentsLoading.bind(this)
					});
				}

				return WebTorrentSeeder;
			})(MasterWebTorrent);

			_export('WebTorrentSeeder', WebTorrentSeeder);
		}
	};
});
$__System.register('d', ['7', '10', 'a'], function (_export) {
	var _classCallCheck, _Map, _createClass, MasterOption;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterOption = (function () {
				function MasterOption() {
					var returnMap = arguments.length <= 0 || arguments[0] === undefined ? new _Map() : arguments[0];

					_classCallCheck(this, MasterOption);

					// returnMap needs to set ['funcName', [func, scope]]
					this.returnMap = returnMap;
				}

				_createClass(MasterOption, [{
					key: 'init',
					value: function init() {
						for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
							data[_key] = arguments[_key];
						}

						this.returnApply('init', data);
					}
				}, {
					key: 'returnApply',
					value: function returnApply(name) {
						var result = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

						var funcScope = this.returnMap.get(name);
						if (funcScope) {
							funcScope[0].apply(funcScope[1], result);
							return true;
						}
						console.warn('SST: set returnMap at MasterOption to handle action: ' + name);
						return false;
					}
				}]);

				return MasterOption;
			})();

			_export('MasterOption', MasterOption);
		}
	};
});
$__System.register('2f', ['5', '6', '7', '18', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterWorker, _createClass, RegexWorker;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterWorker = _4.MasterWorker;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			RegexWorker = (function (_MasterWorker) {
				_inherits(RegexWorker, _MasterWorker);

				function RegexWorker() {
					_classCallCheck(this, RegexWorker);

					_get(Object.getPrototypeOf(RegexWorker.prototype), 'constructor', this).call(this, false);

					this.name = 'RegexWorker';
				}

				_createClass(RegexWorker, [{
					key: 'getMagnetURL',
					value: function getMagnetURL(data) {
						var txt = data[0],
						    attributes = data[1][0]; // [txt, [attributes, classes], workerID]
						// regex grabs id, [magnetURL and tagName] (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Parameters)
						// attributes = ['data-id', 'data-magnetURL', 'data-blobs', 'onerror']
						var re = new RegExp('<(\\w*?)\\s[^<>]*?' + attributes[0] + '="(\\d*?)"[^<>]*?' + attributes[1] + '="([^"]*?)"[^<>]*?' + attributes[2] + '="([^"]*?)"', 'gui');
						var match = null;
						var magnetURLs = [];
						while (match = re.exec(txt)) {
							var id = match[2]; // id
							var val = [match[3], [match[4].split(','), [/* localBlob */]], match[1]]; // magnetURL, blob's, TagName
							magnetURLs.push([id, val]);
						}
						return [[data, magnetURLs]]; // MasterOption.returnApply needs to receive it wrapped in an array
					}
				}, {
					key: 'replaceBlobURL',
					value: function replaceBlobURL(data) {
						// [[txt, [attributes, classes], workerID], [nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], inProgressTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], downloadedTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]]]
						var txt = data[0][0],
						    attributes = data[0][1][0],
						    downloadedTorrents = data[1][2];
						// with tag name grab innerHTML
						downloadedTorrents.forEach(function (e) {
							var id = e[0],
							    remoteBlobs = e[1][1][0],
							    localBlobs = e[1][1][1],
							    onerror = e[1][1][2];
							if (remoteBlobs.length <= localBlobs.length) {
								for (var i = 0; i < remoteBlobs.length; i++) {
									var _re = new RegExp('' + remoteBlobs[i].replace(/[-[\]{}()*+?.,\\/^$|#\s]/g, '\\$&'), 'g'); // escape special characters
									txt = txt.replace(_re, localBlobs[i]);
								}
							} else {
								console.warn('not enough localBlobs to replace all remoteBlobs:', data);
							}
							// replace onerror
							// attributes = ['data-id', 'data-magnetURL', 'data-blobs', 'onerror']
							var re = new RegExp(attributes[3] + '="[^"]*?' + id + '[^"]*?"', 'gui');
							// classes = ['webTorrent', 'blobLoading', 'torrentLoading']
							txt = txt.replace(re, attributes[3] + '="' + onerror + '"');
						});
						data[0][0] = txt;
						return [data]; // MasterOption.returnApply needs to receive it wrapped in an array
					}
				}, {
					key: 'addProgressBar',
					value: function addProgressBar(data) {
						// [[txt, [attributes, classes], workerID], [nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], inProgressTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], downloadedTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]]]
						var txt = data[0][0],
						    attributes = data[0][1][0],
						    classes = data[0][1][1],
						    inProgressTorrents = data[1][0].concat(data[1][1]); // nonExistingTorrents + inProgressTorrents;
						// also empty innerHTML
						inProgressTorrents.forEach(function (e) {
							var id = e[0],
							    val = e[1]; // [[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
							var re = new RegExp('(<' + val[2] + '\\s[^<>]*?class=")[^"]*?("[^<>]*?' + attributes[0] + '="' + id + '"[^<>]*?>).*?(</' + val[2] + '>)', 'gui');
							// classes = ['webTorrent', 'blobLoading', 'torrentLoading']
							txt = txt.replace(re, '$1' + classes[0] + ' ' + classes[2] + '$2$3');
						});
						data[0][0] = txt;
						return [data]; // MasterOption.returnApply needs to receive it wrapped in an array
					}
				}]);

				return RegexWorker;
			})(MasterWorker);

			_export('RegexWorker', RegexWorker);
		}
	};
});
$__System.register('30', ['5', '6', '7', '10', 'a', 'd', '2f'], function (_export) {
	var _get, _inherits, _classCallCheck, _Map, _createClass, MasterOption, RegexWorker, OptionRegex;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			_Map = _4['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {
			MasterOption = _d.MasterOption;
		}, function (_f) {
			RegexWorker = _f.RegexWorker;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			OptionRegex = (function (_MasterOption) {
				_inherits(OptionRegex, _MasterOption);

				function OptionRegex(WebTorrent, client, returnMap, addByTextReturn) {
					var _this = this;

					_classCallCheck(this, OptionRegex);

					_get(Object.getPrototypeOf(OptionRegex.prototype), 'constructor', this).call(this, returnMap);

					this.WebTorrent = WebTorrent;
					this.client = client;
					this.addByTextReturn = addByTextReturn;
					// workers
					this.RegexWorker = new RegexWorker();
					// this.RegexWorker.workers[0]
					this.RegexWorker.create(this.RegexWorker.getMagnetURL, function (result) {
						_this.returnApply('getMagnetURL', result);
					});
					// this.RegexWorker.workers[1]
					this.RegexWorker.create(this.RegexWorker.replaceBlobURL, function (result) {
						_this.returnApply('replaceBlobURL', result);
					});
					// this.RegexWorker.workers[2]
					this.RegexWorker.create(this.RegexWorker.addProgressBar, function (result) {
						_this.returnApply('addProgressBar', result);
					});
				}

				_createClass(OptionRegex, [{
					key: 'getMagnetURL',
					value: function getMagnetURL(txt, attributes) {
						if (txt === undefined) txt = '';
						var workerID = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

						this.RegexWorker.run([txt, attributes, workerID]);
						return true;
					}
				}, {
					key: 'mapFoundMagnetURL',
					value: function mapFoundMagnetURL(data) {
						var _this2 = this;

						// data = [[txt, [attributes, classes], workerID], [[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
						// check if torrent exists
						var magnetURLs = data[1],
						    nonExistingTorrents = [],
						    inProgressTorrents = [],
						    downloadedTorrents = [];
						// let in
						magnetURLs.forEach(function (e) {
							var torrent = _this2.client.get(e[1][0]);
							if (torrent) {
								_this2.WebTorrent.findAllLocalBlobs(torrent);
								if (torrent.sst_localBlobs.length > 0) {
									e[1][1][1] = torrent.sst_localBlobs;
									e[1][1][2] = torrent.sst_onerror;
									if (downloadedTorrents.indexOf(e) === -1) downloadedTorrents.push(e);
								} else {
									if (inProgressTorrents.indexOf(e) === -1) inProgressTorrents.push(e);
								}
							} else {
								if (nonExistingTorrents.indexOf(e) === -1) nonExistingTorrents.push(e);
							}
						});
						data[1] = [nonExistingTorrents, inProgressTorrents, downloadedTorrents]; // [nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], inProgressTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], downloadedTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]]
						this.returnApply('mapFoundMagnetURL', [data]);
					}
				}, {
					key: 'replaceBlobURL',
					value: function replaceBlobURL(data) {
						// downloadedTorrents replace remoteBlobs with localBlobs
						// data[1][2] = downloadedTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
						this.RegexWorker.run(data, this.RegexWorker.workers[1], this.RegexWorker.callbacks[1]);
						return true;
					}
				}, {
					key: 'addProgressBar',
					value: function addProgressBar(data) {
						// data[1][0] = nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
						// data[1][1] = inProgressTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
						this.RegexWorker.run(data, this.RegexWorker.workers[2], this.RegexWorker.callbacks[2]);
						return true;
					}
				}, {
					key: 'addTorrent',
					value: function addTorrent(data) {
						var workerID = data[0][2];
						// nonExistingTorrents
						// !!! IMPORTANT !!! gets executed at _resultAddByText -> this appendto function must be executed after the new text has been applied to dom and settled for 100ms otherwise nodes get mixed up -> see appendTo workaround bug
						var returnAndOptions = this.addByTextReturn.get(workerID); // [arrayReturnMap, [addOpts, appendToOpts, addCallback, appendToCallback]]
						if (returnAndOptions) returnAndOptions[0].push(new _Map([['function', function () {
							var _this3 = this;

							// data[1][0] = nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
							data[1][0].forEach(function (nonExistingTorrent) {
								var torrent = _this3.WebTorrent.add(nonExistingTorrent[1][0].replace(/amp;/g, ''), nonExistingTorrent[0], undefined, returnAndOptions[1][0], returnAndOptions[1][1], /* addCallback */typeof returnAndOptions[1][2] === 'function' ? function (torrent) {
									setTimeout(function () {
										returnAndOptions[1][2](torrent);
									}, 100);
								} : 100, returnAndOptions[1][3]);
								if (torrent) torrent.sst_remoteBlobs = nonExistingTorrent[1][1][0];
							});
						}], ['scope', this], ['attributes', []]]));
						this.returnApply('addTorrent', [data]);
					}
				}]);

				return OptionRegex;
			})(MasterOption);

			_export('OptionRegex', OptionRegex);
		}
	};
});
$__System.register('2d', ['7', '10', '30', '31', '32', '33', 'a', '2e'], function (_export) {
	var _classCallCheck, _Map, OptionRegex, Helper, _getIterator, _Promise, _createClass, _Object$assign, MasterWebTorrent;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_6) {
			OptionRegex = _6.OptionRegex;
		}, function (_5) {
			Helper = _5.Helper;
		}, function (_3) {
			_getIterator = _3['default'];
		}, function (_4) {
			_Promise = _4['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_e) {
			_Object$assign = _e['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			//import IndexeddbChunkStore from 'xuset/indexeddb-chunk-store/idbchunkstore.min.js'; // too slow
			//import parseTorrent from 'parse-torrent/index.js'; // doesn't work in karma

			'use strict';

			MasterWebTorrent = (function () {
				function MasterWebTorrent() {
					var _this = this;

					var container = arguments.length <= 0 || arguments[0] === undefined ? document.body : arguments[0];

					_classCallCheck(this, MasterWebTorrent);

					this.container = container;
					this.Helper = new Helper();
					this.client = {
						on: function on() {},
						get: function get() {},
						add: function add() {},
						seed: function seed() {},
						remove: function remove() {},
						sst_magnetURI: [],
						torrents: []
					}; // placeholder until client is loaded
					var createClient = function createClient() {
						if (window.WebTorrent && (_this.client = new WebTorrent())) {
							_this.client.sst_magnetURI = [];
							_this.client.on('error', function (err) {
								console.error('ERROR: ' + err.message);
							});
						} else {
							setTimeout(createClient, 1000);
						}
					};
					createClient();
					this.addByTextReturn = new _Map(); // takes function, scope and attributes [] to trigger on this._resultAddByText
					this.OptionRegex = new OptionRegex(this, this.client, undefined, this.addByTextReturn);
					this.OptionRegex.returnMap.set('init', [this.OptionRegex.getMagnetURL, this.OptionRegex]);
					this.OptionRegex.returnMap.set('getMagnetURL', [this.OptionRegex.mapFoundMagnetURL, this.OptionRegex]);
					this.OptionRegex.returnMap.set('mapFoundMagnetURL', [this.OptionRegex.replaceBlobURL, this.OptionRegex]);
					this.OptionRegex.returnMap.set('replaceBlobURL', [this.OptionRegex.addProgressBar, this.OptionRegex]);
					this.OptionRegex.returnMap.set('addProgressBar', [this.OptionRegex.addTorrent, this.OptionRegex]);
					this.OptionRegex.returnMap.set('addTorrent', [this._resultAddByText, this]);
					this.torrents = new _Map(); // is used to map between client.torrents [] and nodes. using sst_id when created to quickly access
					this.nodes = []; // nodes in the dom on which torrents got appendedTo
					this.addOpts = {
						/*
      announce: [String],        // Torrent trackers to use (added to list in .torrent or magnet uri)
      getAnnounceOpts: Function, // Custom callback to allow sending extra parameters to the tracker
      maxWebConns: Number,       // Max number of simultaneous connections per web seed [default=4]
      path: String,              // Folder to download files to (default=`/tmp/webtorrent/`)
      store: Function            // Custom chunk store (must follow [abstract-chunk-store](https://www.npmjs.com/package/abstract-chunk-store) API)
      */
						//store: IndexeddbChunkStore
						announce: ['udp://tracker.leechers-paradise.org:6969', 'udp://tracker.coppersurfer.tk:6969', 'udp://tracker.opentrackr.org:1337', 'udp://explodie.org:6969', 'udp://tracker.empire-js.us:1337', 'udp://zephir.monocul.us:6969/announce', 'udp://p4p.arenabg.com:1337/announce', 'udp://tracker.internetwarriors.net:1337/announce', 'udp://public.popcorn-tracker.org:6969/announce', 'udp://eddie4.nl:6969/announce', 'udp://open.stealth.si:80/announce', 'udp://tracker.ex.ua:80/announce', 'udp://tracker.filetracker.pl:8089/announce', 'udp://tracker.flashtorrents.org:6969/announce', 'udp://tracker.kicks-ass.net:80/announce', 'udp://tracker.kuroy.me:5944/announce', 'udp://tracker.piratepublic.com:1337/announce', 'udp://tracker.tiny-vps.com:6969/announce', 'udp://tracker.yoshi210.com:6969/announce', 'udp://185.5.97.139:8089/announce', 'udp://zer0day.ch:1337/announce', 'udp://thetracker.org:80/announce', 'udp://wambo.club:1337/announce', 'udp://tc.animereactor.ru:8082/announce', 'udp://tracker.bittor.pw:1337/announce', 'udp://tracker.vanitycore.co:6969/announce']
					};
					this.seedOpts = {
						/*
      name: String,            // name of the torrent (default = basename of `path`, or 1st file's name)
      comment: String,         // free-form textual comments of the author
      createdBy: String,       // name and version of program used to create torrent
      creationDate: Date       // creation time in UNIX epoch format (default = now)
      private: Boolean,        // is this a private .torrent? (default = false)
      pieceLength: Number      // force a custom piece length (number of bytes)
      announceList: [[String]] // custom trackers (array of arrays of strings) (see [bep12](http://www.bittorrent.org/beps/bep_0012.html))
      urlList: [String]        // web seed urls (see [bep19](http://www.bittorrent.org/beps/bep_0019.html))
      */
						comment: 'peerweb.site'
						//store: IndexeddbChunkStore
					};
					this.appendToOpts = {
						/*
      !!! IMPORTANT !!! when autoplay off it doesn't work in Firefox and Chrome
      autoplay: Boolean, // Autoplay video/audio files (default: false)
      muted: Mute video/audio files (default: false)
      controls: Boolean, // Show video/audio player controls (default: true)
      maxBlobLength: Number, // Files above this size will skip the "blob" strategy and fail (default: 200 * 1000 * 1000 bytes)
      */
						autoplay: false, // fixed at version 0.112.0 https://github.com/webtorrent/webtorrent/issues/1967
						muted: false,
						controls: true
					};
					// !!! Important !!! set the attributes in the same order as in the array below
					this.attributes = ['data-id', 'data-magnetURL', 'data-blobs', 'onerror', 'data-linktxt'];
					this.classes = ['webTorrent', 'blobLoading', 'torrentLoading'];
					this.timeoutCont = null; // used for onerror
					this.onerrorCont = [];

					// hooks
					this.api = {
						/**
       * remove - check whole body if node, to which the torrent got appended, is still existent => not delete entry in node and torrent and client.torrents
       * 
       * @param {HtmlNode} [container=this.container] 
       * @returns 
       * @memberof MasterWebTorrent
       */
						removeDeletedNodes: this.removeDeletedNodes.bind(this),
						/**
       * creates id's from files
       * 
       * @param {FileList} files 
       * @returns 
       * @memberof Helper
       */
						createFilesId: this.Helper.createFilesId.bind(this.Helper),
						/**
       * Map
       * 
       * @param {[[id: number, torrent: Object]]}
       * @memberof MasterWebTorrent
       */
						torrents: this.torrents,
						/**
       * HtmlNode
       * 
       * @param {HtmlNode}
       * @memberof MasterWebTorrent
       */
						container: this.container,
						getAllTorrents: this.getAllTorrents.bind(this),
						getAllTorrentFiles: this.getAllTorrentFiles.bind(this)
					};
				}

				// add (download)

				_createClass(MasterWebTorrent, [{
					key: 'add',
					value: function add(magnetURL, id, node, addOpts, appendToOpts, addCallback, appendToCallback) {
						if (addOpts === undefined) addOpts = _Object$assign({}, this.addOpts);

						var _this2 = this;

						if (addCallback === undefined) addCallback = function (torrent) {
							return _this2.appendTo(undefined, appendToOpts, appendToCallback, torrent);
						};
						return (function () {
							var _this3 = this;

							id = Number(id);
							if (!isNaN(addCallback)) {
								(function () {
									var timer = addCallback;
									addCallback = function (torrent) {
										setTimeout(function () {
											_this3.appendTo(undefined, appendToOpts, appendToCallback, torrent);
										}, timer);
									};
								})();
							}
							// don't add dublicated torrents (files) but simply use existing torrent
							var _iteratorNormalCompletion = true;
							var _didIteratorError = false;
							var _iteratorError = undefined;

							try {
								for (var _iterator = _getIterator(this.client.torrents), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
									var _torrent = _step.value;

									// in case of matching files.length check deeper for size and name
									if (id === _torrent.sst_id) {
										if (node) this.setNodes(_torrent, node, _torrent.sst_id);
										if (_torrent.done) addCallback(_torrent);
										return false;
									}
								}
								// -----------------------------------------------------------------------
								// none dublicated torrents
								// below gets executed before appendTo callback
							} catch (err) {
								_didIteratorError = true;
								_iteratorError = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion && _iterator['return']) {
										_iterator['return']();
									}
								} finally {
									if (_didIteratorError) {
										throw _iteratorError;
									}
								}
							}

							var torrent = this.client.add(magnetURL, addOpts, addCallback);
							this.client.sst_magnetURI.push(magnetURL);
							this.addParseTorrent(torrent);
							torrent.sst_id = id;
							this.torrents.set(torrent.sst_id, torrent);
							// sst_id to identify (if node gets deleted before torrent finished seeding)
							if (node) this.setNodes(torrent, node, torrent.sst_id);
							return torrent;
						}).apply(this, arguments);
					}

					/**
      * Searching text for torrents to add (api hook)
      * 
      * @param {string} txt 
      * @param {Map([['function', Function], ['scope', Object], ['attributes', []])} arrayReturnMap
      * @param {Object} addOpts 
      * @param {Object} appendToOpts 
      * @param {Function} addCallback 
      * @param {Function} appendToCallback 
      * @memberof MasterWebTorrent
      */
				}, {
					key: 'addByText',
					value: function addByText(txt, arrayReturnMap, addOpts, appendToOpts, addCallback, appendToCallback) {
						// arrayReturnMap requires Map with function, scope, attributes
						var workerID = this.Helper.getRandomString();
						// [addOpts, appendToOpts, addCallback, appendToCallback] are applied to OptionRegex->addTorrent->this.WebTorrent.add
						this.addByTextReturn.set(workerID, [arrayReturnMap, [addOpts, appendToOpts, addCallback, appendToCallback]]);
						this.OptionRegex.init(txt, [this.attributes, this.classes], workerID);
					}

					// don't call this directly, it will be called by OptionRegex timeline triggered when worker finishes
				}, {
					key: '_resultAddByText',
					value: function _resultAddByText(data) {
						var txt = data[0][0],
						    workerID = data[0][2] /*, magnetURLs = data[1]*/;
						// trigger the linked function for this workerID
						var arrayReturnMap = this.addByTextReturn.get(workerID)[0];
						if (arrayReturnMap) {
							arrayReturnMap.forEach(function (returnMap) {
								// trigger: this.Dom.setData(container, oldMessage, dataPack.message);
								returnMap.get('attributes').push(txt);
								returnMap.get('function').apply(returnMap.get('scope'), returnMap.get('attributes'));
							});
							this.addByTextReturn['delete'](workerID);
						}
						return txt;
					}

					/**
      * seed (upload) (api hook)
      * 
      * @param {File | FileList} files 
      * @param {string} text 
      * @param {HtmlNode} node 
      * @param {Object} [seedOpts=this.seedOpts] 
      * @param {Object} appendToOpts 
      * @param {Function} [seedCallback=(torrent) => {return this.appendTo(text, appendToOpts, appendToCallback, torrent);}] 
      * @param {Function} appendToCallback 
      * @returns 
      * @memberof MasterWebTorrent
      */
				}, {
					key: 'seed',
					value: function seed(files, text, node, seedOpts, appendToOpts, seedCallback, appendToCallback) {
						if (seedOpts === undefined) seedOpts = _Object$assign({}, this.seedOpts);

						var _this4 = this;

						if (seedCallback === undefined) seedCallback = function (torrent) {
							return _this4.appendTo(text, appendToOpts, appendToCallback, torrent);
						};
						return (function () {
							var _this5 = this;

							if (node) {
								node.classList.add(this.classes[0], this.classes[1]);
								node.contentEditable = false;
							}
							var id = this.Helper.createFilesId(files);
							// don't seed dublicated torrents (files) but simply use existing torrent
							var _iteratorNormalCompletion2 = true;
							var _didIteratorError2 = false;
							var _iteratorError2 = undefined;

							try {
								for (var _iterator2 = _getIterator(this.client.torrents), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
									var _torrent2 = _step2.value;

									// in case of matching files.length check deeper for size and name
									if (id === _torrent2.sst_id) {
										// sst_id to identify (if node gets deleted before torrent finished seeding)
										if (node) this.setNodes(_torrent2, node, _torrent2.sst_id);
										if (_torrent2.done) seedCallback(_torrent2);
										return false;
									}
								}
								// -----------------------------------------------------------------------
								// none dublicated torrents
								// below gets executed before appendTo callback
							} catch (err) {
								_didIteratorError2 = true;
								_iteratorError2 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion2 && _iterator2['return']) {
										_iterator2['return']();
									}
								} finally {
									if (_didIteratorError2) {
										throw _iteratorError2;
									}
								}
							}

							var torrent = this.client.seed(files, seedOpts, seedCallback);
							torrent.on('infoHash', function () {
								_this5.client.sst_magnetURI.push(torrent.magnetURI);
							});
							this.addParseTorrent(torrent);
							torrent.sst_id = id;
							this.torrents.set(torrent.sst_id, torrent);
							// sst_id to identify (if node gets deleted before torrent finished seeding)
							if (node) this.setNodes(torrent, node, torrent.sst_id);
							return torrent;
						}).apply(this, arguments);
					}
				}, {
					key: 'appendTo',
					value: function appendTo(text, appendToOpts, appendToCallback, torrent) {
						if (appendToOpts === undefined) appendToOpts = this.appendToOpts;
						if (appendToCallback === undefined) appendToCallback = function (torrent) {
							console.info('torrent: ' + torrent.name + ' appended!');
						};
						return (function () {
							var _this6 = this;

							if (torrent.sst_nodes && torrent.sst_nodes.length > 0) {
								// use content of previously set torrent.sst_nodes
								if (torrent.sst_nodeCont) {
									this.appended(torrent, appendToCallback, text);
								} else if (!torrent.sst_appending) {
									(function () {
										// stop other files to be appended during this process
										torrent.sst_appending = true;
										// grab first node and use it as append role model
										var node = torrent.sst_nodes[0];
										// only appendTo empty nodes
										node.innerHTML = '';
										torrent.files.forEach(function (file, i) {
											file.appendTo(node, appendToOpts, function (err, elem) {
												// callback for last file, when finishing
												var callback = i === torrent.files.length - 1 ? function (elem) {
													setTimeout(function () {
														torrent.sst_appending = false;
														// workaround bug which possibly appends to wrong node... nodes in the dom can get mixed up during this process, make sure and if needed reset
														if (Number(torrent.sst_id) === Number(node.getAttribute(_this6.attributes[0]))) {
															(function () {
																// this only gets triggered on WebTorrentReceiver
																if (_this6.ProgressBar) _this6.ProgressBar.removeAll(torrent);
																torrent.sst_containsVideo = node.innerHTML.indexOf('video') !== -1;
																// Event Listeners
																// save files
																var download = function download(event) {
																	torrent.files.forEach(function (file) {
																		file.getBlobURL(function (err, url) {
																			if (err) return console.warn(err);
																			_this6.Helper.saveBlobUrl(url, file.name);
																		});
																	});
																};
																node.sst_download = download;
																if (torrent.sst_containsVideo) {
																	(function () {
																		// save files
																		var downloadTimerID = null;
																		node.addEventListener('mousedown', function (event) {
																			return downloadTimerID = setTimeout(function () {
																				if (event.which === 1) download();
																			}, 1000);
																		});
																		node.addEventListener('mouseup', function () {
																			return clearTimeout(downloadTimerID);
																		});
																		// unmute
																		var unMute = function unMute(event) {
																			node.removeEventListener('click', unMute);
																			node.childNodes.forEach(function (child) {
																				return child.muted = false;
																			});
																			event.preventDefault();
																		};
																		node.addEventListener('click', unMute);
																	})();
																} else {
																	// save files
																	node.addEventListener('dblclick', download);
																}
																// set node content to torrent
																torrent.sst_nodeCont = node.innerHTML;
																_this6.appended(torrent, appendToCallback, text);
															})();
														} else {
															// reset nodes and start over
															node.removeChild(elem);
															torrent.sst_nodes = [];
															_this6.appendTo(text, appendToOpts, appendToCallback, torrent);
														}
													}, 50); // waitForBlob
												} : function () {};
												// when not supported for appendTo eg. zip add download link
												if (!elem) {
													if (file.done) {
														_this6.appendToUnsupportedFileAsLink(text, torrent, file, node, callback);
													} else {
														torrent.on('done', function () {
															_this6.appendToUnsupportedFileAsLink(text, torrent, file, node, callback);
														});
													}
													//clear error
													err = undefined;
												} else {
													callback(elem);
												}
												if (err) {
													node.remove();
													_this6.removeDeletedNodes();
												}
												return err ? console.warn(err) : true;
											});
										});
									})();
								}
							} else {
								console.info('no nodes found in dom for:');
								console.info(torrent);
							}
						}).apply(this, arguments);
					}
				}, {
					key: 'appendToUnsupportedFileAsLink',
					value: function appendToUnsupportedFileAsLink(text, torrent, file, node, callback) {
						var _this7 = this;

						file.getBlobURL(function (err, url) {
							if (err) return console.warn(err);
							var name = file.name;
							text = text ? text : node.getAttribute(_this7.attributes[4]);
							if (text) {
								name = torrent.files.length > 1 ? text + '_' + torrent.files.indexOf(file) : text;
							}
							var a = document.createElement('a');
							a.target = '_blank';
							a.download = name;
							a.href = url;
							a.textContent = name;
							if (node.lastChild && node.lastChild.tagName === 'A') {
								a.textContent = ', ' + name;
							}
							node.appendChild(a);
							callback(a);
						});
					}
				}, {
					key: 'appended',
					value: function appended(torrent) {
						var _this8 = this;

						var appendToCallback = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
						var text = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

						var invalidNodes = []; // saving can invalidate nodes, grap those and pass it to removeInvalidNodes
						torrent.sst_nodes.forEach(function (node) {
							if (node && typeof node.getAttribute === 'function') {
								// set same content to all nodes
								if (node.innerHTML !== torrent.sst_nodeCont) node.innerHTML = torrent.sst_nodeCont;
								// set magnetURI
								if (!node.getAttribute(_this8.attributes[1])) node.setAttribute(_this8.attributes[1], torrent.magnetURI);
								// set linktxt
								if (text && !node.getAttribute(_this8.attributes[4])) node.setAttribute(_this8.attributes[4], text);
								// loading finished remove classes
								if (node.classList.contains(_this8.classes[1])) node.classList.remove(_this8.classes[1]);
								if (node.classList.contains(_this8.classes[2])) node.classList.remove(_this8.classes[2]);
								// set error handling
								node.childNodes.forEach(function (child) {
									// error handling if blobs have to be renewed => this.blobsRefresh (set globally at WebTorrentSeeder / WebTorrentReceiver)
									child.setAttribute(_this8.attributes[3], _this8.appended_onerror + '(' + torrent.sst_id + ');');
								});
								torrent.sst_onerror = _this8.appended_onerror + '(' + torrent.sst_id + ');'; // needs to be set on Regex replaceBlobURL
							} else {
									invalidNodes.push(node);
								}
						});
						this.findAllLocalBlobs(torrent);
						this.removeInvalidNodes(invalidNodes, torrent.sst_id);
						if (appendToCallback) appendToCallback(torrent);
					}

					// blobs refresh called by onerror attribute
				}, {
					key: 'blobsRefresh',
					value: function blobsRefresh() {
						var _this9 = this;

						var torrentId = arguments.length <= 0 || arguments[0] === undefined ? this.onerrorCont : arguments[0];

						// bundle all errors and do all at once
						if (Array.isArray(torrentId)) {
							torrentId.forEach(function (id) {
								var torrent = _this9.torrents.get(id);
								if (torrent) {
									torrent.files.forEach(function (file, i) {
										file.getBlobURL(function (err, url) {
											if (err) return console.warn(err);
											if (url !== torrent.sst_localBlobs[i]) {
												torrent.sst_nodeCont = torrent.sst_nodeCont.replace(torrent.sst_localBlobs[i], url);
												URL.revokeObjectURL(torrent.sst_localBlobs[i]);
												torrent.sst_localBlobs[i] = url;
											}
											// last file
											if (i === torrent.files.length - 1) {
												_this9.findAllNodes(torrent);
												_this9.appended(torrent);
											}
										});
									});
								}
							});
							this.onerrorCont = [];
						} else {
							if (this.onerrorCont.indexOf(torrentId) === -1) {
								this.onerrorCont.push(torrentId);
								/**
         * !!! Not needed, because loading class wouldn't be kept on next webrtc text received !!!
        // add blobLoading
        let torrent = this.torrents.get(torrentId);
        if(torrent){
        	// this only gets triggered on WebTorrentReceiver
        	if (this.findAllNodes) this.findAllNodes(torrent);
        	torrent.sst_nodes.forEach((node) => {
        		node.classList.add(this.classes[1]);
        	});
        }
        */

								/** 
         * videoObject.currentTime NOT POSSIBLE!!! RETURNS NULL AFTER ERROR!!!
         * https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_video_currenttime
        // get video currentTime to be set after fix blob, only triggered when appended receives it from this onerror and treats each nodes each children video
        */
							}
							clearTimeout(this.timeoutCont);
							this.timeoutCont = setTimeout(function () {
								_this9.blobsRefresh();
							}, 1000);
						}
					}

					// nodes
				}, {
					key: 'setNodes',
					value: function setNodes(torrent, node, id) {
						if (node) {
							// find node (node within the dom)
							if (!torrent.sst_nodes) torrent.sst_nodes = [];
							if (torrent.sst_nodes.indexOf(node) === -1) {
								torrent.sst_nodes.push(node);
								// find torrent in this.torrents by id
								if (!node.getAttribute(this.attributes[0])) node.setAttribute(this.attributes[0], id);
								if (this.nodes.indexOf(node) === -1) this.nodes.push(node);
								return true;
							}
						}
						return false;
					}
				}, {
					key: 'findAllNodes',
					value: function findAllNodes(torrent) {
						var _this10 = this;

						// find all nodes (node within the dom)
						var nodes = this.container.querySelectorAll('[' + this.attributes[0] + '="' + torrent.sst_id + '"]');
						nodes.forEach(function (node) {
							_this10.setNodes(torrent, node, torrent.sst_id);
						});
						return nodes;
					}
				}, {
					key: 'findAllLocalBlobs',
					value: function findAllLocalBlobs(torrent) {
						var _this11 = this;

						torrent.sst_localBlobs = torrent.sst_localBlobs || [];
						torrent.sst_nodes.forEach(function (node) {
							node.childNodes.forEach(function (child) {
								var blob = child.getAttribute('src') ? child.getAttribute('src') : child.getAttribute('href');
								if (blob && !torrent.sst_localBlobs.includes(blob)) torrent.sst_localBlobs.push(blob);
							});
						});
						// generate blobs if there are no nodes with src/href referencing blobs found
						if (!torrent.sst_localBlobs.length) {
							torrent.files.forEach(function (file, i) {
								file.getBlobURL(function (err, url) {
									if (err) return console.warn(err);
									if (!torrent.sst_localBlobs.includes(url)) torrent.sst_localBlobs.push(url);
									if (i === torrent.files.length - 1) _this11.updateLocalBlobsOnNodes(torrent);
								});
							});
						} else {
							this.updateLocalBlobsOnNodes(torrent);
						}
					}
				}, {
					key: 'updateLocalBlobsOnNodes',
					value: function updateLocalBlobsOnNodes(torrent) {
						var _this12 = this;

						torrent.sst_nodes.forEach(function (node) {
							// set data-blobs
							node.setAttribute(_this12.attributes[2], torrent.sst_localBlobs.join(','));
						});
					}

					/**
      * remove - check whole body if node, to which the torrent got appended, is still existent => not delete entry in node and torrent and client.torrents (api hook)
      * 
      * @param {HtmlNode} [container=this.container] 
      * @returns 
      * @memberof MasterWebTorrent
      */
				}, {
					key: 'removeDeletedNodes',
					value: function removeDeletedNodes() {
						var _this13 = this;

						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						var removedNodes = [];
						this.nodes.forEach(function (node) {
							if (!container.contains(node)) {
								if (_this13.remove(node)) {
									removedNodes.push(node);
								}
							}
						});
						if (removedNodes.length > 0) {
							this.nodes = this.nodes.filter(function (e) {
								return removedNodes.indexOf(e) === -1;
							});
						}
						return removedNodes;
					}
				}, {
					key: 'removeInvalidNodes',
					value: function removeInvalidNodes(nodes, id) {
						var _this14 = this;

						var removedNodes = [];
						nodes.forEach(function (node) {
							if (_this14.remove(node, undefined, id)) {
								removedNodes.push(node);
							}
						});
						if (removedNodes.length > 0) {
							this.nodes = this.nodes.filter(function (e) {
								return removedNodes.indexOf(e) === -1;
							});
						}
						return removedNodes;
					}
				}, {
					key: 'remove',
					value: function remove() {
						var node = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
						var callback = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
						var id = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

						id = id ? id : Number(node.getAttribute(this.attributes[0]));
						var torrent = this.torrents.get(id);
						if (torrent) {
							var index = torrent.sst_nodes.indexOf(node);
							if (index !== -1) torrent.sst_nodes.splice(index, 1);
							// if no ui element holds the torrent (has to find all nodes, since the node may change when edited in code mode just before the node)
							if (torrent.sst_nodes.length === 0 && this.findAllNodes(torrent).length === 0) {
								// this only gets triggered on WebTorrentReceiver
								if (this.ProgressBar) {
									this.ProgressBar.removeAll(torrent);
								}
								if (torrent.sst_localBlobs) {
									torrent.sst_localBlobs.forEach(function (blob) {
										URL.revokeObjectURL(blob);
									});
								}
								var magnetURI_index = this.client.sst_magnetURI.indexOf(torrent.magnetURI);
								if (magnetURI_index !== -1) this.client.sst_magnetURI.splice(magnetURI_index, 1);
								if (callback) {
									// Alias for client.remove(torrent)
									torrent.destroy(callback);
								} else {
									this.client.remove(torrent);
								}
								this.torrents['delete'](id);
								return true;
							}
							return torrent;
						}
						return false;
					}

					// loading
				}, {
					key: 'areTorrentsLoading',
					value: function areTorrentsLoading() {
						return this.client.torrents.some(function (torrent) {
							return !torrent.done || torrent.sst_appending;
						});
					}

					// saving
				}, {
					key: 'addParseTorrent',
					value: function addParseTorrent(torrent) {}
					/*if(parseTorrent){
     	Object.defineProperty(torrent, 'sst_parsedTorrent', {
     		get: function () { return parseTorrent(this.torrentFile); }
     	});
     }*/

					// name come as encodeURI / magnetURI comes as encodeURIComponent + .replace(/%20/g, '+')

				}, {
					key: 'getBlobByFileName',
					value: function getBlobByFileName(name) {
						var _this15 = this;

						var origName = name;
						name = decodeURI(name);
						return new _Promise(function (resolve) {
							var getBlob = function getBlob(file) {
								file.getBlob(function (err, blob) {
									if (err) {
										console.warn(err);
										return resolve(null);
									}
									resolve(blob);
								});
							};
							// got magnetURI !!!if you change this, change equal at JavaScript/js/ServiceWorker/ServiceWorker.js.addMessageChannelEventListener!!!
							if (name.includes('magnet:') || name.includes('magnet/') || name.includes('?xt=urn:')) {
								if (name.includes('magnet')) {
									name = name.replace(/.*magnet[:\/]/, 'magnet:');
								} else {
									name = name.replace(/.*\?xt=urn:/, 'magnet:?xt=urn:');
								}
								var torrent = _this15.add(name, undefined, undefined, undefined, undefined, function (torrent) {
									if (torrent.files && torrent.files[0]) {
										// !!!waiting for on.done, only works with torrents which have a single file!!! multiple files don't get mentioned in magnetURI
										getBlob(torrent.files[0]);
									} else {
										// not found
										resolve(null);
										console.warn('this torrent is invalid:', name);
									}
								});
								torrent.on('error', function () {
									// not found
									resolve(null);
									console.warn('this torrent is invalid:', name);
								});
							} else if (!_this15.client.torrents.some(function (torrent) {
								// search for torrents by name
								var file = undefined;
								if (torrent.done && (file = torrent.files.find(function (file) {
									// file.name is plain without encoding
									return name.includes(file.name);
								}))) {
									// found file with same name
									getBlob(file);
									return true;
								} else if (torrent.magnetURI && torrent.magnetURI.includes(encodeURIComponent(name).replace(/%20/g, '+'))) {
									// magnetURI references the name
									// !!!waiting for on.done, only works with torrents which have a single file!!! multiple files don't get mentioned in magnetURI
									torrent.on('done', function () {
										getBlob(torrent.files[0]);
									});
									return true;
								}
								return false;
							})) {
								// no torrent found but check if it will be loaded but just hasn't been initiated
								if (_this15.client.sst_magnetURI.some(function (magnetURI) {
									// how magnetURI gets built: https://github.com/webtorrent/magnet-uri/blob/master/index.js encodeURIComponent + .replace(/%20/g, '+')
									return magnetURI.includes(encodeURIComponent(name).replace(/%20/g, '+'));
								})) {
									// try later
									setTimeout(function () {
										_this15.getBlobByFileName(origName).then(function (blob) {
											return resolve(blob);
										});
									}, 1000);
								} else {
									// not found
									resolve(null);
								}
							}
						});
					}
				}, {
					key: 'getAllTorrents',
					value: function getAllTorrents() {
						this.Helper.saveText(this.client.torrents.map(function (torrent) {
							return torrent.magnetURI;
						}).join("\n\n---\n\n"), 'peerWebSiteTorrents_' + this.Helper.getRandomString() + '.txt');
					}
				}, {
					key: 'getAllTorrentFiles',
					value: function getAllTorrentFiles() {
						var _this16 = this;

						var callback = arguments.length <= 0 || arguments[0] === undefined ? function (success) {} : arguments[0];

						var length = this.client.torrents.length;
						this.client.torrents.forEach(function (torrent) {
							torrent.files.forEach(function (file) {
								file.getBlobURL(function (err, url) {
									callback(!err);
									if (err) return console.warn(err);
									_this16.Helper.saveBlobUrl(url, file.name === 'peerWebSite.txt' ? 'peerWebSite_' + torrent.infoHash + '.txt' : file.name);
								});
							});
						});
						return length;
					}
				}]);

				return MasterWebTorrent;
			})();

			_export('MasterWebTorrent', MasterWebTorrent);
		}
	};
});
$__System.registerDynamic("1c", ["2a"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Array$from = $__require("2a")["default"];
  exports["default"] = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
      return arr2;
    } else {
      return _Array$from(arr);
    }
  };
  exports.__esModule = true;
});
$__System.registerDynamic('34', ['35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('35'),
      hide = $__require('36'),
      redefineAll = $__require('37'),
      ctx = $__require('38'),
      strictNew = $__require('39'),
      defined = $__require('3a'),
      forOf = $__require('3b'),
      $iterDefine = $__require('3c'),
      step = $__require('3d'),
      ID = $__require('3e')('id'),
      $has = $__require('3f'),
      isObject = $__require('40'),
      setSpecies = $__require('41'),
      DESCRIPTORS = $__require('42'),
      isExtensible = Object.isExtensible || isObject,
      SIZE = DESCRIPTORS ? '_s' : 'size',
      id = 0;
  var fastKey = function (it, create) {
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it)) return 'F';
      if (!create) return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function (that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F') return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };
  module.exports = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function (key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r) entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS) $.setDesc(C.prototype, 'size', { get: function () {
          return defined(this[SIZE]);
        } });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        if (index !== 'F') that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function (iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function () {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r) entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys') return step(0, entry.k);
        if (kind == 'values') return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      setSpecies(NAME);
    }
  };
});
$__System.registerDynamic('43', ['35', '44', '45', '46', '36', '37', '3b', '39', '40', '47', '42'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('35'),
      global = $__require('44'),
      $export = $__require('45'),
      fails = $__require('46'),
      hide = $__require('36'),
      redefineAll = $__require('37'),
      forOf = $__require('3b'),
      strictNew = $__require('39'),
      isObject = $__require('40'),
      setToStringTag = $__require('47'),
      DESCRIPTORS = $__require('42');
  module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      C = wrapper(function (target, iterable) {
        strictNew(target, C, NAME);
        target._c = new Base();
        if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
      });
      $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','), function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      if ('size' in proto) $.setDesc(C.prototype, 'size', { get: function () {
          return this._c.size;
        } });
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };
});
$__System.registerDynamic('48', ['34', '43'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var strong = $__require('34');
  $__require('43')('Map', function (get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
});
$__System.registerDynamic('49', ['3b', '4a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var forOf = $__require('3b'),
      classof = $__require('4a');
  module.exports = function (NAME) {
    return function toJSON() {
      if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
});
$__System.registerDynamic('4b', ['45', '49'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('45');
  $export($export.P, 'Map', { toJSON: $__require('49')('Map') });
});
$__System.registerDynamic('4c', ['4d', '4e', '4f', '48', '4b', '50'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('4d');
  $__require('4e');
  $__require('4f');
  $__require('48');
  $__require('4b');
  module.exports = $__require('50').Map;
});
$__System.registerDynamic("10", ["4c"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("4c"), __esModule: true };
});
$__System.register('51', ['7', '10', '32', 'a', '1c'], function (_export) {
	var _classCallCheck, _Map, _getIterator, _createClass, _toConsumableArray, ProgressBar;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_3) {
			_Map = _3['default'];
		}, function (_2) {
			_getIterator = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			_toConsumableArray = _c['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			ProgressBar = (function () {
				function ProgressBar(torrents, addTorrent, removeTorrentNode) {
					var interval = arguments.length <= 3 || arguments[3] === undefined ? 1000 : arguments[3];
					var animationClass = arguments.length <= 4 || arguments[4] === undefined ? 'torrentLoading' : arguments[4];

					_classCallCheck(this, ProgressBar);

					this.torrents = torrents;
					this.addTorrent = addTorrent;
					this.removeTorrentNode = removeTorrentNode;
					this.interval = interval;

					this.resetInterval = this.interval * 5;
					this.intervalCont = undefined;
					this.tags = ['span'];
					this.classes = ['torrentInfo', animationClass, 'torrentProgress', 'torrentControls'];
				}

				_createClass(ProgressBar, [{
					key: 'start',
					value: function start() {
						var _this = this;

						if (!this.intervalCont) this.intervalCont = setInterval(function () {
							_this.update();
						}, this.interval);
					}
				}, {
					key: 'end',
					value: function end() {
						this.intervalCont = clearInterval(this.intervalCont);
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
							for (var _iterator = _getIterator(this.torrents.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var torrent = _step.value;

								this.removeAll(torrent);
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					}
				}, {
					key: 'update',
					value: function update() {
						var _this2 = this;

						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;

						try {
							var _loop = function () {
								var torrent = _step2.value;

								if (torrent.sst_nodes && !torrent.sst_containsVideo) {
									// don't add progressBar to videos, they stream anyways
									if (torrent.done) {
										_this2.removeAll(torrent);
									} else {
										(function () {
											var progress = (100 * torrent.progress).toFixed(1);
											if (!torrent.sst_progressNodes) torrent.sst_progressNodes = new _Map();
											torrent.sst_nodes.forEach(function (node) {
												var parentNode = torrent.sst_progressNodes.get(node),
												    animationNode = undefined,
												    infoNode = undefined,
												    controlsNode = undefined;
												if (!parentNode || !node.contains(parentNode)) {
													parentNode = document.createElement('span');
													parentNode.classList.add(_this2.classes[0]);
													node.appendChild(parentNode);
													torrent.sst_progressNodes.set(node, parentNode);
													// child nodes of parentNode
													animationNode = document.createElement('span');
													animationNode.classList.add(_this2.classes[1]);
													parentNode.appendChild(animationNode);
													infoNode = document.createElement('span');
													infoNode.classList.add(_this2.classes[2]);
													parentNode.appendChild(infoNode);
													controlsNode = document.createElement('a');
													controlsNode.classList.add(_this2.classes[3]);
													controlsNode.innerText = 'Reset';
													controlsNode.onclick = function () {
														var magnetURI = torrent.magnetURI;
														var sst_id = torrent.sst_id;
														var nodes = [];
														torrent.sst_nodes.forEach(function (node) {
															nodes.push(node);
															_this2.removeTorrentNode(node, function () {
																setTimeout(function () {
																	nodes.forEach(function (node) {
																		_this2.addTorrent(magnetURI, sst_id, node);
																	});
																}, _this2.resetInterval);
															});
														});
													};
													parentNode.appendChild(controlsNode);
												} else {
													infoNode = parentNode.getElementsByClassName(_this2.classes[2])[0];
												}
												infoNode.innerHTML = '&nbsp;' + progress + '%&nbsp;';
											});
										})();
									}
								}
							};

							for (var _iterator2 = _getIterator(this.torrents.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								_loop();
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2['return']) {
									_iterator2['return']();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
					}

					// removes the parentNode when MasterWebTorrent.appended
				}, {
					key: 'remove',
					value: function remove(torrent, node) {
						if (torrent.sst_progressNodes) {
							var parentNode = torrent.sst_progressNodes.get(node);
							if (parentNode && node.contains(parentNode)) {
								node.removeChild(parentNode);
								torrent.sst_progressNodes['delete'](node);
								if (!torrent.sst_progressNodes.size) delete torrent.sst_progressNodes;
							} else {
								// remove by class just in case virtual-dom mixed something up
								[].concat(_toConsumableArray(node.getElementsByClassName(this.classes[0]))).forEach(function (parentNode) {
									node.removeChild(parentNode);
								});
							}
						}
					}
				}, {
					key: 'removeAll',
					value: function removeAll(torrent) {
						var _this3 = this;

						if (torrent.sst_progressNodes) {
							torrent.sst_nodes.forEach(function (node) {
								_this3.remove(torrent, node);
							});
						}
					}
				}]);

				return ProgressBar;
			})();

			_export('ProgressBar', ProgressBar);
		}
	};
});
$__System.register('52', ['5', '6', '7', '51', 'a', '2e', '2d'], function (_export) {
	var _get, _inherits, _classCallCheck, ProgressBar, _createClass, _Object$assign, MasterWebTorrent, WebTorrentReceiver;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			ProgressBar = _4.ProgressBar;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_e) {
			_Object$assign = _e['default'];
		}, function (_d) {
			MasterWebTorrent = _d.MasterWebTorrent;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			WebTorrentReceiver = (function (_MasterWebTorrent) {
				_inherits(WebTorrentReceiver, _MasterWebTorrent);

				function WebTorrentReceiver(container) {
					_classCallCheck(this, WebTorrentReceiver);

					_get(Object.getPrototypeOf(WebTorrentReceiver.prototype), 'constructor', this).call(this, container);

					this.ProgressBar = new ProgressBar(this.torrents, this.add.bind(this), this.remove.bind(this));
					// onerror node error handling global
					this.appended_onerror = 'window.sst_WebTorrentReceiver_blobsRefresh';
					window.sst_WebTorrentReceiver_blobsRefresh = this.blobsRefresh.bind(this);

					// hooks
					this.api = _Object$assign(this.api, {
						/**
       * Searching text for torrents to add
       * 
       * @param {string} txt 
       * @param {Map([['function', Function], ['scope', Object], ['attributes', []])} arrayReturnMap
       * @param {Object} addOpts 
       * @param {Object} appendToOpts 
       * @param {Function} addCallback 
       * @param {Function} appendToCallback 
       * @memberof MasterWebTorrent
       */
						addByText: this.addByText.bind(this)
					});
				}

				// called only on new torrent INIT (once only)
				// 1) add find node which trigger this torrent to be added

				_createClass(WebTorrentReceiver, [{
					key: 'appendTo',
					value: function appendTo(text, appendToOpts, appendToCallback, torrent) {
						this.findAllNodes(torrent);
						_get(Object.getPrototypeOf(WebTorrentReceiver.prototype), 'appendTo', this).call(this, text, appendToOpts, appendToCallback, torrent);
					}

					// 2) after delay file.appendTo make sure to once more search for more nodes
				}, {
					key: 'appended',
					value: function appended(torrent, appendToCallback) {
						this.findAllNodes(torrent);
						_get(Object.getPrototypeOf(WebTorrentReceiver.prototype), 'appended', this).call(this, torrent, appendToCallback);
						if (!this.areTorrentsLoading()) this.ProgressBar.end();
					}

					// loading (progressbar) hooks
				}, {
					key: 'add',
					value: function add(magnetURL, id, node, addOpts, appendToOpts, addCallback, appendToCallback) {
						var torrent = _get(Object.getPrototypeOf(WebTorrentReceiver.prototype), 'add', this).call(this, magnetURL, id, node, addOpts, appendToOpts, addCallback, appendToCallback);
						this.findAllNodes(torrent); // to have nodes where the progressbar can attach to
						this.ProgressBar.start();
						return torrent;
					}
				}]);

				return WebTorrentReceiver;
			})(MasterWebTorrent);

			_export('WebTorrentReceiver', WebTorrentReceiver);
		}
	};
});
$__System.registerDynamic('53', ['35', '54', '55', '46'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('35'),
      toObject = $__require('54'),
      IObject = $__require('55');
  module.exports = $__require('46')(function () {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
    return T;
  } : Object.assign;
});
$__System.registerDynamic('56', ['45', '53'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('45');
  $export($export.S + $export.F, 'Object', { assign: $__require('53') });
});
$__System.registerDynamic('57', ['56', '50'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('56');
  module.exports = $__require('50').Object.assign;
});
$__System.registerDynamic("2e", ["57"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("57"), __esModule: true };
});
$__System.register('58', ['7', '31', '33', 'a', '2e'], function (_export) {
    var _classCallCheck, Helper, _Promise, _createClass, _Object$assign, IPFS;

    return {
        setters: [function (_) {
            _classCallCheck = _['default'];
        }, function (_3) {
            Helper = _3.Helper;
        }, function (_2) {
            _Promise = _2['default'];
        }, function (_a) {
            _createClass = _a['default'];
        }, function (_e) {
            _Object$assign = _e['default'];
        }],
        execute: function () {

            // Debug: http://localhost:3000/index_debug.html#ipfs:QmT8dAKuCVQ7TTHV5ezNFE272cs15PyigJGV663GHeen6t
            'use strict';

            IPFS = (function () {
                function IPFS(isSender) {
                    _classCallCheck(this, IPFS);

                    this.isSender = isSender;
                    this.Helper = new Helper();

                    // should be 'ipfs://' but browsers do not yet support that url scheme, once this gateway would get blocked or overloaded the files have to be fixed through the service worker
                    this.baseUrl = 'https://gateway.ipfs.io/ipfs/'; // must have "onFetchError" error handling, when used at add
                    // https://blog.ipfs.io/2020-07-20-js-ipfs-0-48/
                    this.node = new _Promise(function (resolve) {
                        var createIpfs = function createIpfs() {
                            if (window.Ipfs) {
                                resolve(window.Ipfs.create());
                            } else {
                                setTimeout(createIpfs, 1000);
                            }
                        };
                        createIpfs();
                    });
                    this.isIdle = new _Promise(function (resolve) {
                        return document.readyState !== 'complete' ? window.addEventListener('load', function (event) {
                            return setTimeout(function () {
                                return resolve();
                            }, 60000);
                        }) : setTimeout(function () {
                            return resolve();
                        }, 60000);
                    });

                    // ipfs dom nodes error handling
                    this.ipfs_onerror = 'window.sst_IPFS_onFetchError';
                    window.sst_IPFS_onFetchError = this.onFetchError.bind(this);
                }

                _createClass(IPFS, [{
                    key: 'add',
                    value: function add(path, content) {
                        var _this = this;

                        // file.link, which depends on this.baseUrl is only used at EditorSummernote and has an error handling "onFetchError" to findPeers
                        return this.node.then(function (node) {
                            return node.add({ path: path, content: content });
                        }).then(function (file) {
                            return _Object$assign({ link: _this.baseUrl + file.cid }, file);
                        });
                    }
                }, {
                    key: 'fetch',
                    value: (function (_fetch) {
                        function fetch(_x) {
                            return _fetch.apply(this, arguments);
                        }

                        fetch.toString = function () {
                            return _fetch.toString();
                        };

                        return fetch;
                    })(function (cid) {
                        var type = arguments.length <= 1 || arguments[1] === undefined ? 'text' : arguments[1];

                        var _this2 = this;

                        var abortController = arguments.length <= 2 || arguments[2] === undefined ? new AbortController() : arguments[2];
                        var queryString = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];

                        return new _Promise(function (resolve, reject) {
                            // Fetch
                            fetch(_this2.baseUrl + cid + queryString, { signal: abortController.signal }).then(function (response) {
                                if (_this2.validateResponse(response)) {
                                    try {
                                        resolve(type ? response[type]() : response);
                                    } catch (error) {
                                        reject(_this2.baseUrl + cid + error && error.message);
                                    }
                                } else {
                                    reject(_this2.baseUrl + cid);
                                }
                            })['catch'](function (error) {
                                return reject(_this2.baseUrl + cid);
                            });
                        });
                    })
                }, {
                    key: 'cat',
                    value: function cat(cid) {
                        var raw = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

                        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
                        // for await alternative
                        return this.node.then(function (node) {
                            var chunksIterator = node.cat(cid);
                            var chunks = [];
                            var consume = function consume(obj) {
                                if (obj.done) return raw ? chunks : chunks.toString();
                                chunks.push(obj.value);
                                return chunksIterator.next().then(consume);
                            };
                            return chunksIterator.next().then(consume); // kick off the recursive function
                        });
                    }
                }, {
                    key: 'raceFetchVsCat',
                    value: function raceFetchVsCat(cid, type, queryString) {
                        var _this3 = this;

                        return new _Promise(function (resolve, reject) {
                            var rejectFunc = _this3.getRejectFunc(reject, 2);
                            var abortController = new AbortController();
                            _this3.fetch(cid, type, abortController, queryString).then(function (result) {
                                console.info('@IPFS: Got Page ' + cid + ' through fetch');
                                resolve(result);
                            })['catch'](rejectFunc);
                            _this3.cat(cid, false).then(function (result) {
                                console.info('@IPFS: Got Page ' + cid + ' through cat');
                                resolve(result);
                                abortController.abort();
                            })['catch'](rejectFunc);
                        });
                    }
                }, {
                    key: 'getBlobByFileCID',
                    value: function getBlobByFileCID(url) {
                        var _this4 = this;

                        //QmQKaoJcU9QoHHgaSMZ4htAoSXHwBBx25oShbk2f5W1bh1
                        // <img src="https://gateway.ipfs.io/ipfs/QmQKaoJcU9QoHHgaSMZ4htAoSXHwBBx25oShbk2f5W1bh1#svg"></img>
                        return new _Promise(function (resolve) {
                            url = _this4.digestUrl(url);
                            var type = '';
                            if (url.cid && url.filename && (type = _this4.Helper.mime.getType(url.filename, false))) {
                                _this4.cat(url.cid, true).then(function (chunks) {
                                    return resolve(new Blob(chunks, { type: type }));
                                })['catch'](function (error) {
                                    console.error('SST_IPFS_onFetchError: Could not find ' + url + ' nor findPeer at el:', error);
                                    resolve(null);
                                });
                            } else {
                                resolve(null);
                            }
                        });
                    }
                }, {
                    key: 'pin',
                    value: function pin(url) {
                        url = this.digestUrl(url);
                        if (url.urlString.includes(this.baseUrl) && url.cid) return _Promise.all([this.isIdle, this.node]).then(function (results) {
                            return results[1].pin.add(url.cid);
                        });
                        return null;
                    }
                }, {
                    key: 'pinIfSender',
                    value: function pinIfSender(url) {
                        if (this.isSender) this.pin(url);
                    }
                }, {
                    key: 'pinCid',
                    value: function pinCid(cid) {
                        if (cid) return _Promise.all([this.isIdle, this.node]).then(function (results) {
                            return results[1].pin.add(cid);
                        });
                        return null;
                    }
                }, {
                    key: 'onFetchError',
                    value: function onFetchError(event, url, name, type, isAudioVideo, el) {
                        var _this5 = this;

                        if (this.isSender) return false;
                        var sanitize = function sanitize() {
                            type = type.split(',');
                            // findPeer and don't be dependend on this.baserUrl
                            var errorFunc = function errorFunc(error) {
                                el[type[1]] = el[type[1]];
                                console.error('SST_IPFS_onFetchError: Could not find ' + url + ' nor findPeer at el:', el, error);
                            };
                            url = _this5.digestUrl(url);
                            if (!url.cid) return errorFunc('NO cid found!');
                            el.classList.add('ipfsLoading');
                            if (isAudioVideo && el.parentElement) {
                                el.parentElement.classList.add('ipfsLoading');
                                el.parentElement.sst_hasError = true;
                            }
                            return _this5.cat(url.cid, true).then(function (chunks) {
                                el[type[1]] = URL.createObjectURL(new Blob(chunks, { type: _this5.Helper.mime.getType(name) }));
                                el.classList.remove('ipfsLoading');
                                if (isAudioVideo && el.parentElement) {
                                    el.parentElement.classList.remove('ipfsLoading');
                                    el.parentElement.sst_hasError = false;
                                    el.parentElement.innerHTML = el.parentElement.innerHTML;
                                }
                            })['catch'](function (error) {
                                return errorFunc(error);
                            });
                        };
                        // means is a link with onclick
                        if (event) {
                            (function () {
                                event.preventDefault();
                                var onclick = el.getAttribute('onclick');
                                var click = function click() {
                                    el.removeAttribute('onclick');
                                    el.click();
                                    el.setAttribute('onclick', onclick);
                                };
                                fetch(url).then(function () {
                                    return click();
                                })['catch'](function (error) {
                                    sanitize().then(function () {
                                        return click();
                                    });
                                });
                            })();
                        } else {
                            sanitize();
                        }
                    }
                }, {
                    key: 'digestUrl',
                    value: function digestUrl() {
                        var url = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

                        var urlString = url;
                        url = new URL(url) || { pathname: '', searchParams: { get: function get() {
                                    return null;
                                } } };
                        return {
                            cid: url.pathname.split('/').splice(-1)[0] || null,
                            filename: url.searchParams.get('filename') || null,
                            urlString: urlString,
                            url: url
                        };
                    }
                }, {
                    key: 'validateResponse',
                    value: function validateResponse(response) {
                        // 0 is for cache
                        return response && (response.status === 0 || response.status >= 200 && response.status <= 299);
                    }
                }, {
                    key: 'getRejectFunc',
                    value: function getRejectFunc(reject) {
                        var max = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];

                        var counter = 0;
                        return function (url) {
                            counter++;
                            if (counter >= max) reject('@IPFS: No response for ' + url);
                        };
                    }

                    // download all IPFS files
                }, {
                    key: 'getAllIPFSFiles',
                    value: function getAllIPFSFiles() {
                        var _this6 = this;

                        var callback = arguments.length <= 0 || arguments[0] === undefined ? function (success) {} : arguments[0];

                        var src = [];
                        document.querySelectorAll('[src^="' + this.baseUrl + '"]').forEach(function (node) {
                            if (src.every(function (srcNode) {
                                return srcNode.src !== node.src;
                            })) src.push(node); // only add a link once
                        });
                        var href = [];
                        document.querySelectorAll('[href^="' + this.baseUrl + '"]').forEach(function (node) {
                            if (href.every(function (hrefNode) {
                                return hrefNode.href !== node.href;
                            }) && src.every(function (srcNode) {
                                return srcNode.src !== node.href;
                            })) href.push(node); // only add a link once
                        });
                        var length = src.length + href.length + 1;
                        src.forEach(function (node) {
                            return _this6.getBlobByFileCID(node.src).then(function (blob) {
                                callback(!!blob);
                                var url = _this6.digestUrl(node.src);
                                if (blob) _this6.Helper.saveBlob(blob, node.getAttribute('data-filename') || node.parentNode && node.parentNode.getAttribute('data-filename') || url.filename);
                            });
                        });
                        href.forEach(function (node) {
                            return _this6.getBlobByFileCID(node.href).then(function (blob) {
                                callback(!!blob);
                                var url = _this6.digestUrl(node.href);
                                if (blob) _this6.Helper.saveBlob(blob, node.getAttribute('data-filename') || node.parentNode && node.parentNode.getAttribute('data-filename') || url.filename);
                            });
                        });
                        var cid = location.hash.substr(6);
                        var filename = 'peerWebSite.txt';
                        this.getBlobByFileCID(this.baseUrl + cid + ('?filename=' + filename)).then(function (blob) {
                            callback(!!blob);
                            if (blob) _this6.Helper.saveBlob(blob, 'peerWebSite_' + cid + '.txt');
                        });
                        return length;
                    }
                }]);

                return IPFS;
            })();

            _export('IPFS', IPFS);
        }
    };
});
$__System.register('18', ['7', 'a'], function (_export) {
	var _classCallCheck, _createClass, MasterWorker;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterWorker = (function () {
				function MasterWorker() {
					var spreadArgs = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

					_classCallCheck(this, MasterWorker);

					this.spreadArgs = spreadArgs;
					this.name = 'MasterWorker';
					this.workers = [];
					this.callbacks = [];
					this.trackers = []; // simply used to track if function has already been set as this.workers
					this.scripts = [];
				}

				// workerFunc can not reference anything outside (func becomes string), data has to be passed to the worker function

				_createClass(MasterWorker, [{
					key: 'create',
					value: function create(workerFunc, callback, scripts) {
						if (workerFunc === undefined) workerFunc = this.workerFunc;
						if (callback === undefined) callback = this.callbackFunc;

						var index = this.trackers.indexOf(workerFunc);
						if (index === -1) {
							this.workers.push(this.getWebWorker(workerFunc, scripts));
							this.callbacks.push(callback);
							this.trackers.push(workerFunc);
							return this.trackers.length - 1;
						}
						return index;
					}
				}, {
					key: 'run',
					value: function run() {
						var data = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

						var _this = this;

						var worker = arguments.length <= 1 || arguments[1] === undefined ? this.workers[0] : arguments[1];
						var callback = arguments.length <= 2 || arguments[2] === undefined ? this.callbacks[0] : arguments[2];

						worker(data, function (err, result) {
							if (err) return console.warn('SST: Error at ' + _this.name + ' -> ' + err.message);
							callback(result);
						});
					}

					// dummy examples
				}, {
					key: 'workerFunc',
					value: function workerFunc(data) {
						return data;
					}
				}, {
					key: 'callbackFunc',
					value: function callbackFunc(result) {
						console.log(result);
					}
				}, {
					key: 'getWebWorker',
					value: function getWebWorker(workerFunc) {
						var scripts = arguments.length <= 1 || arguments[1] === undefined ? this.scripts : arguments[1];

						// URL.createObjectURL
						window.URL = window.URL || window.webkitURL;

						// add scripts outside of event
						scripts = Array.isArray(scripts) && scripts.length ? 'importScripts(\'' + scripts.join("','") + '\');\n' : '';
						if (typeof workerFunc !== 'string') {
							workerFunc = workerFunc.toLocaleString();
							workerFunc = workerFunc.replace(/this\./g, '');
							if (/^\(.*?\).*?\=\>.*?\{/.test(workerFunc)) {
								// arrow functions need to be wrapped with ()
								workerFunc = '(' + workerFunc + ')';
							} else if (!/^function/.test(workerFunc)) {
								// class functions need the keyword function
								workerFunc = 'function ' + workerFunc;
							}
						}
						var response = 'onmessage=(event)=>{postMessage(' + workerFunc + '(' + (this.spreadArgs ? '...' : '') + 'event.data));}';

						var blob = undefined;
						try {
							blob = new Blob([scripts, response], { type: 'application/javascript' });
						} catch (e) {
							// Backwards-compatibility
							window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
							blob = new BlobBuilder();
							blob.append(scripts);
							blob.append(response);
							blob = blob.getBlob();
						}

						var worker = new Worker(URL.createObjectURL(blob));
						return function () {
							var data = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
							var callback = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];

							var ran = undefined;
							worker.onmessage = function (e) {
								if (ran) return;
								ran = true;
								callback(null, e.data);
							};
							worker.onerror = function (e) {
								if (ran) return;
								ran = true;
								callback(e);
								return false;
							};
							worker.postMessage.apply(worker, [data]); // can only have one argument as message
						};
					}
				}]);

				return MasterWorker;
			})();

			_export('MasterWorker', MasterWorker);
		}
	};
});
$__System.register('59', ['5', '6', '7', '18', '33', 'a'], function (_export) {
    var _get, _inherits, _classCallCheck, MasterWorker, _Promise, _createClass, EncryptDecrypt;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _classCallCheck = _3['default'];
        }, function (_5) {
            MasterWorker = _5.MasterWorker;
        }, function (_4) {
            _Promise = _4['default'];
        }, function (_a) {
            _createClass = _a['default'];
        }],
        execute: function () {

            // https://github.com/okandavut/hencrypt/blob/master/index.js
            'use strict';

            EncryptDecrypt = (function (_MasterWorker) {
                _inherits(EncryptDecrypt, _MasterWorker);

                function EncryptDecrypt() {
                    var _this = this;

                    _classCallCheck(this, EncryptDecrypt);

                    _get(Object.getPrototypeOf(EncryptDecrypt.prototype), 'constructor', this).call(this);

                    this.encryptedIndicator = 'SST_Encrypted:';

                    this.create(this.encrypt);
                    this.encrypt = function (text, salt) {
                        var encryptResolve = null;
                        var encryptPromise = new _Promise(function (resolve) {
                            encryptResolve = resolve;
                        });
                        if (!salt) salt = window.prompt('Enter a password or passphrase in case you want to encrypt the html/text!?');
                        if (salt) {
                            _this.run([text, salt], _this.workers[0], function (encryptedText) {
                                return encryptResolve({ text: _this.encryptedIndicator + encryptedText, encrypted: true });
                            });
                        } else {
                            encryptResolve({ text: text, encrypted: false });
                        }
                        return encryptPromise;
                    };
                    this.create(this.decrypt);
                    this.decrypt = function (text, salt) {
                        var failedFunc = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

                        var decryptResolve = null;
                        var decryptPromise = new _Promise(function (resolve) {
                            decryptResolve = resolve;
                        });
                        if (_this.isEncrypted(text)) {
                            if (!salt) salt = window.prompt('Enter a password or passphrase to decrypt this Peer Web Site\'s html/text!');
                            if (salt) {
                                _this.run([text.replace(_this.encryptedIndicator, ''), salt], _this.workers[1], function (decryptedText) {
                                    return decryptResolve({ text: decryptedText, decrypted: true });
                                });
                            } else if (typeof failedFunc === 'function') {
                                (function () {
                                    var funcName = 'SSTdecryptFunc';
                                    window[funcName] = function (event) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                        window[funcName] = function (event) {};
                                        _this.decrypt(text).then(function (result) {
                                            var text = result.text;
                                            var decrypted = result.decrypted;

                                            failedFunc(text);
                                        });
                                    };
                                    decryptResolve({ text: '<div class="SSTdecrypt" onclick="' + funcName + '(event)"><span class="glyphicon glyphicon-lock"></span><a onclick="' + funcName + '(event)">Click and fill in the prompt with the password or passphrase!<br>' + text + '</a></div>', decrypted: 'failed' });
                                })();
                            } else {
                                decryptResolve({ text: text, decrypted: 'failed' });
                            }
                        } else {
                            decryptResolve({ text: text, decrypted: false });
                        }
                        return decryptPromise;
                    };
                }

                _createClass(EncryptDecrypt, [{
                    key: 'encrypt',
                    value: function encrypt(text, salt) {
                        var textToChars = function textToChars(text) {
                            return text.split("").map(function (c) {
                                return c.charCodeAt(0);
                            });
                        };
                        var byteHex = function byteHex(n) {
                            return ("0" + Number(n).toString(16)).substr(-2);
                        };
                        var applySaltToChar = function applySaltToChar(code) {
                            return textToChars(salt).reduce(function (a, b) {
                                return a ^ b;
                            }, code);
                        };
                        return text.split("").map(textToChars).map(applySaltToChar).map(byteHex).join("");
                    }
                }, {
                    key: 'decrypt',
                    value: function decrypt(text, salt) {
                        var textToChars = function textToChars(text) {
                            return text.split("").map(function (c) {
                                return c.charCodeAt(0);
                            });
                        };
                        var applySaltToChar = function applySaltToChar(code) {
                            return textToChars(salt).reduce(function (a, b) {
                                return a ^ b;
                            }, code);
                        };
                        return text.match(/.{1,2}/g).map(function (hex) {
                            return parseInt(hex, 16);
                        }).map(applySaltToChar).map(function (charCode) {
                            return String.fromCharCode(charCode);
                        }).join("");
                    }
                }, {
                    key: 'isEncrypted',
                    value: function isEncrypted(text) {
                        return text.includes(this.encryptedIndicator);
                    }
                }]);

                return EncryptDecrypt;
            })(MasterWorker);

            _export('EncryptDecrypt', EncryptDecrypt);
        }
    };
});
$__System.registerDynamic('5a', ['38', '45', '54', '5b', '5c', '5d', '5e', '5f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ctx = $__require('38'),
      $export = $__require('45'),
      toObject = $__require('54'),
      call = $__require('5b'),
      isArrayIter = $__require('5c'),
      toLength = $__require('5d'),
      getIterFn = $__require('5e');
  $export($export.S + $export.F * !$__require('5f')(function (iter) {
    Array.from(iter);
  }), 'Array', { from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping) mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    } });
});
$__System.registerDynamic('60', ['4e', '5a', '50'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('4e');
  $__require('5a');
  module.exports = $__require('50').Array.from;
});
$__System.registerDynamic("2a", ["60"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("60"), __esModule: true };
});
$__System.registerDynamic('54', ['3a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var defined = $__require('3a');
  module.exports = function (it) {
    return Object(defined(it));
  };
});
$__System.registerDynamic('61', ['54', '62'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toObject = $__require('54');
  $__require('62')('keys', function ($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
});
$__System.registerDynamic('63', ['61', '50'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('61');
  module.exports = $__require('50').Object.keys;
});
$__System.registerDynamic("64", ["63"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("63"), __esModule: true };
});
$__System.registerDynamic("4d", [], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var global = this || self,
      GLOBAL = global;
});
$__System.registerDynamic("39", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it, Constructor, name) {
    if (!(it instanceof Constructor)) throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
});
$__System.registerDynamic('5b', ['65'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('65');
  module.exports = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) anObject(ret.call(iterator));
      throw e;
    }
  };
});
$__System.registerDynamic('5c', ['66', '67'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var Iterators = $__require('66'),
        ITERATOR = $__require('67')('iterator'),
        ArrayProto = Array.prototype;
    module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
    };
});
$__System.registerDynamic('5d', ['68'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('68'),
      min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
});
$__System.registerDynamic('3b', ['38', '5b', '5c', '65', '5d', '5e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ctx = $__require('38'),
      call = $__require('5b'),
      isArrayIter = $__require('5c'),
      anObject = $__require('65'),
      toLength = $__require('5d'),
      getIterFn = $__require('5e');
  module.exports = function (iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
      entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      call(iterator, f, step.value, entries);
    }
  };
});
$__System.registerDynamic("69", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.9 SameValue(x, y)
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
});
$__System.registerDynamic('6a', ['65', '6b', '67'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var anObject = $__require('65'),
        aFunction = $__require('6b'),
        SPECIES = $__require('67')('species');
    module.exports = function (O, D) {
        var C = anObject(O).constructor,
            S;
        return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
    };
});
$__System.registerDynamic("6c", [], true, function ($__require, exports, module) {
                  var global = this || self,
                      GLOBAL = global;
                  // fast apply, http://jsperf.lnkit.com/fast-apply/5
                  module.exports = function (fn, args, that) {
                                    var un = that === undefined;
                                    switch (args.length) {
                                                      case 0:
                                                                        return un ? fn() : fn.call(that);
                                                      case 1:
                                                                        return un ? fn(args[0]) : fn.call(that, args[0]);
                                                      case 2:
                                                                        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                                      case 3:
                                                                        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                                      case 4:
                                                                        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                                    }return fn.apply(that, args);
                  };
});
$__System.registerDynamic('6d', ['44'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('44').document && document.documentElement;
});
$__System.registerDynamic('6e', ['40', '44'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var isObject = $__require('40'),
        document = $__require('44').document,
        is = isObject(document) && isObject(document.createElement);
    module.exports = function (it) {
        return is ? document.createElement(it) : {};
    };
});
$__System.registerDynamic('6f', ['38', '6c', '6d', '6e', '44', '70', '71'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var ctx = $__require('38'),
        invoke = $__require('6c'),
        html = $__require('6d'),
        cel = $__require('6e'),
        global = $__require('44'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function () {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function (event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i) args.push(arguments[i++]);
        queue[++counter] = function () {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('70')(process) == 'process') {
        defer = function (id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function (id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function (id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function (id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('71'));
});
$__System.registerDynamic('72', ['44', '6f', '70', '71'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var global = $__require('44'),
        macrotask = $__require('6f').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('70')(process) == 'process',
        head,
        last,
        notify;
    var flush = function () {
      var parent, domain, fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain) domain.enter();
        fn();
        if (domain) domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent) parent.enter();
    };
    if (isNode) {
      notify = function () {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, { characterData: true });
      notify = function () {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function () {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function () {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('71'));
});
$__System.registerDynamic('37', ['73'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var redefine = $__require('73');
  module.exports = function (target, src) {
    for (var key in src) redefine(target, key, src[key]);
    return target;
  };
});
$__System.registerDynamic('41', ['50', '35', '42', '67'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var core = $__require('50'),
      $ = $__require('35'),
      DESCRIPTORS = $__require('42'),
      SPECIES = $__require('67')('species');
  module.exports = function (KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES]) $.setDesc(C, SPECIES, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  };
});
$__System.registerDynamic('5f', ['67'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ITERATOR = $__require('67')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function () {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {}
  module.exports = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function () {
        return { done: safe = true };
      };
      arr[ITERATOR] = function () {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
});
$__System.registerDynamic('74', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    })();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) {
        return [];
    };

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
});
$__System.registerDynamic("75", ["74"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("74");
});
$__System.registerDynamic('76', ['75'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__System._nodeRequire ? process : $__require('75');
});
$__System.registerDynamic("71", ["76"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("76");
});
$__System.registerDynamic('77', ['35', '78', '44', '38', '4a', '45', '40', '65', '6b', '39', '3b', '79', '69', '67', '6a', '72', '42', '37', '47', '41', '50', '5f', '71'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var $ = $__require('35'),
        LIBRARY = $__require('78'),
        global = $__require('44'),
        ctx = $__require('38'),
        classof = $__require('4a'),
        $export = $__require('45'),
        isObject = $__require('40'),
        anObject = $__require('65'),
        aFunction = $__require('6b'),
        strictNew = $__require('39'),
        forOf = $__require('3b'),
        setProto = $__require('79').set,
        same = $__require('69'),
        SPECIES = $__require('67')('species'),
        speciesConstructor = $__require('6a'),
        asap = $__require('72'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        empty = function () {},
        Wrapper;
    var testResolve = function (sub) {
      var test = new P(empty),
          promise;
      if (sub) test.constructor = function (exec) {
        exec(empty, empty);
      };
      (promise = P.resolve(test))['catch'](empty);
      return promise === test;
    };
    var USE_NATIVE = function () {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, { constructor: { value: P2 } });
        if (!(P2.resolve(5).then(function () {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('42')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', { get: function () {
              thenableThenGotten = true;
            } }));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function (a, b) {
      if (LIBRARY && a === P && b === Wrapper) return true;
      return same(a, b);
    };
    var getConstructor = function (C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function (it) {
      var then;
      return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function (C) {
      var resolve, reject;
      this.promise = new C(function ($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function (exec) {
      try {
        exec();
      } catch (e) {
        return { error: e };
      }
    };
    var notify = function (record, isReject) {
      if (record.n) return;
      record.n = true;
      var chain = record.c;
      asap(function () {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function (reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok) record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else resolve(result);
            } else reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i) run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject) setTimeout(function () {
          var promise = record.p,
              handler,
              console;
          if (isUnhandled(promise)) {
            if (isNode) {
              process.emit('unhandledRejection', value, promise);
            } else if (handler = global.onunhandledrejection) {
              handler({
                promise: promise,
                reason: value
              });
            } else if ((console = global.console) && console.error) {
              console.error('Unhandled promise rejection', value);
            }
          }
          record.a = undefined;
        }, 1);
      });
    };
    var isUnhandled = function (promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h) return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise)) return false;
      }
      return true;
    };
    var $reject = function (value) {
      var record = this;
      if (record.d) return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function (value) {
      var record = this,
          then;
      if (record.d) return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value) throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function () {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('37')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a) record.a.push(reaction);
          if (record.s) notify(record, false);
          return promise;
        },
        'catch': function (onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: P });
    $__require('47')(P, PROMISE);
    $__require('41')(PROMISE);
    Wrapper = $__require('50')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, { reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      } });
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, { resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this)) return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      } });
    $export($export.S + $export.F * !(USE_NATIVE && $__require('5f')(function (iter) {
      P.all(iter)['catch'](function () {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function () {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining) $.each.call(values, function (promise, index) {
            var alreadyCalled = false;
            C.resolve(promise).then(function (value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });else resolve(results);
        });
        if (abrupt) reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function () {
          forOf(iterable, false, function (promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt) reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('71'));
});
$__System.registerDynamic('7a', ['4d', '4e', '4f', '77', '50'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('4d');
  $__require('4e');
  $__require('4f');
  $__require('77');
  module.exports = $__require('50').Promise;
});
$__System.registerDynamic("33", ["7a"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("7a"), __esModule: true };
});
$__System.register('7b', ['7', '33', '64', 'a'], function (_export) {
	var _classCallCheck, _Promise, _Object$keys, _createClass, MasterEditor;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_3) {
			_Promise = _3['default'];
		}, function (_2) {
			_Object$keys = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterEditor = (function () {
				function MasterEditor() {
					_classCallCheck(this, MasterEditor);
				}

				_createClass(MasterEditor, [{
					key: 'addEmojis',
					value: function addEmojis() {
						$.ajax({
							url: 'https://api.github.com/emojis',
							crossDomain: true,
							dataType: 'json'
						}).then(function (data) {
							window.emojis = _Object$keys(data);
							window.emojiUrls = data;
						});
					}
				}, {
					key: 'loadFile',
					value: function loadFile(files, text) {
						var _this = this;

						var container = arguments.length <= 2 || arguments[2] === undefined ? this.container : arguments[2];
						var doRead = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

						return new _Promise(function (resolve) {
							var results = [];
							$.each(files, function (i, file) {
								var name = file.name;
								if (text) {
									name = files.length > 1 ? text + '_' + i : text;
								}
								var Reader = new FileReader();
								var setData = function setData() {
									var type = file.type.includes('image') ? ['img', 'src'] : file.type.includes('video') ? ['video', 'src'] : file.type.includes('audio') ? ['audio', 'src'] : ['a', 'href'];
									var node = document.createElement(type[0]);
									node.id = _this.Helper.createFileId(file); // give each node an id, so that virtual-dom doesn't mix up things
									var source = null;
									if (type[0] === 'video' || type[0] === 'audio') {
										node.controls = true;
										source = document.createElement('source');
										if (Reader.result) source[type[1]] = Reader.result;
										source.type = file.type;
										node.appendChild(source);
									} else {
										if (Reader.result) node[type[1]] = Reader.result;
										node.text = name;
									}
									results.push({ name: name, content: file, source: source || node, type: type, audioVideo: source ? node : null });
									if (i + 1 === files.length) resolve(results);
									node.setAttribute('download', name);
									node.setAttribute('data-filename', name);
									if (i > 0) {
										_this.setData(container, ' ');
									}
									_this.setData(container, node, 'insertNode');
								};
								doRead ? Reader.addEventListener('load', setData, false) : setData();
								Reader.readAsDataURL(file);
							});
						});
					}
				}]);

				return MasterEditor;
			})();

			_export('MasterEditor', MasterEditor);
		}
	};
});
$__System.register('7c', ['5', '6', '7', '19'], function (_export) {
  var _get, _inherits, _classCallCheck, MasterHelper, Helper;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      MasterHelper = _4.MasterHelper;
    }],
    execute: function () {
      /*jshint esnext: true */

      'use strict';

      Helper = (function (_MasterHelper) {
        _inherits(Helper, _MasterHelper);

        function Helper() {
          _classCallCheck(this, Helper);

          _get(Object.getPrototypeOf(Helper.prototype), 'constructor', this).apply(this, arguments);
        }

        return Helper;
      })(MasterHelper);

      _export('Helper', Helper);
    }
  };
});
$__System.registerDynamic("7d", ["28"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "$", null);

  (function ($__global) {
    /* */
    "format global";
    "deps jquery";
    "exports $";
    /*!
     * Bootstrap v3.3.7 (http://getbootstrap.com)
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under the MIT license
     */

    if (typeof jQuery === 'undefined') {
      throw new Error('Bootstrap\'s JavaScript requires jQuery');
    }

    +function ($) {
      'use strict';

      var version = $.fn.jquery.split(' ')[0].split('.');
      if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 3) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4');
      }
    }(jQuery);

    /* ========================================================================
     * Bootstrap: transition.js v3.3.7
     * http://getbootstrap.com/javascript/#transitions
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
      // ============================================================

      function transitionEnd() {
        var el = document.createElement('bootstrap');

        var transEndEventNames = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };

        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return { end: transEndEventNames[name] };
          }
        }

        return false; // explicit for ie8 (  ._.)
      }

      // http://blog.alexmaccaw.com/css-transitions
      $.fn.emulateTransitionEnd = function (duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function () {
          called = true;
        });
        var callback = function () {
          if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
      };

      $(function () {
        $.support.transition = transitionEnd();

        if (!$.support.transition) return;

        $.event.special.bsTransitionEnd = {
          bindType: $.support.transition.end,
          delegateType: $.support.transition.end,
          handle: function (e) {
            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
          }
        };
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: alert.js v3.3.7
     * http://getbootstrap.com/javascript/#alerts
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // ALERT CLASS DEFINITION
      // ======================

      var dismiss = '[data-dismiss="alert"]';
      var Alert = function (el) {
        $(el).on('click', dismiss, this.close);
      };

      Alert.VERSION = '3.3.7';

      Alert.TRANSITION_DURATION = 150;

      Alert.prototype.close = function (e) {
        var $this = $(this);
        var selector = $this.attr('data-target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        var $parent = $(selector === '#' ? [] : selector);

        if (e) e.preventDefault();

        if (!$parent.length) {
          $parent = $this.closest('.alert');
        }

        $parent.trigger(e = $.Event('close.bs.alert'));

        if (e.isDefaultPrevented()) return;

        $parent.removeClass('in');

        function removeElement() {
          // detach from parent, fire event then clean up data
          $parent.detach().trigger('closed.bs.alert').remove();
        }

        $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
      };

      // ALERT PLUGIN DEFINITION
      // =======================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.alert');

          if (!data) $this.data('bs.alert', data = new Alert(this));
          if (typeof option == 'string') data[option].call($this);
        });
      }

      var old = $.fn.alert;

      $.fn.alert = Plugin;
      $.fn.alert.Constructor = Alert;

      // ALERT NO CONFLICT
      // =================

      $.fn.alert.noConflict = function () {
        $.fn.alert = old;
        return this;
      };

      // ALERT DATA-API
      // ==============

      $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: button.js v3.3.7
     * http://getbootstrap.com/javascript/#buttons
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // BUTTON PUBLIC CLASS DEFINITION
      // ==============================

      var Button = function (element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
      };

      Button.VERSION = '3.3.7';

      Button.DEFAULTS = {
        loadingText: 'loading...'
      };

      Button.prototype.setState = function (state) {
        var d = 'disabled';
        var $el = this.$element;
        var val = $el.is('input') ? 'val' : 'html';
        var data = $el.data();

        state += 'Text';

        if (data.resetText == null) $el.data('resetText', $el[val]());

        // push to event loop to allow forms to submit
        setTimeout($.proxy(function () {
          $el[val](data[state] == null ? this.options[state] : data[state]);

          if (state == 'loadingText') {
            this.isLoading = true;
            $el.addClass(d).attr(d, d).prop(d, true);
          } else if (this.isLoading) {
            this.isLoading = false;
            $el.removeClass(d).removeAttr(d).prop(d, false);
          }
        }, this), 0);
      };

      Button.prototype.toggle = function () {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');

        if ($parent.length) {
          var $input = this.$element.find('input');
          if ($input.prop('type') == 'radio') {
            if ($input.prop('checked')) changed = false;
            $parent.find('.active').removeClass('active');
            this.$element.addClass('active');
          } else if ($input.prop('type') == 'checkbox') {
            if ($input.prop('checked') !== this.$element.hasClass('active')) changed = false;
            this.$element.toggleClass('active');
          }
          $input.prop('checked', this.$element.hasClass('active'));
          if (changed) $input.trigger('change');
        } else {
          this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
          this.$element.toggleClass('active');
        }
      };

      // BUTTON PLUGIN DEFINITION
      // ========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.button');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.button', data = new Button(this, options));

          if (option == 'toggle') data.toggle();else if (option) data.setState(option);
        });
      }

      var old = $.fn.button;

      $.fn.button = Plugin;
      $.fn.button.Constructor = Button;

      // BUTTON NO CONFLICT
      // ==================

      $.fn.button.noConflict = function () {
        $.fn.button = old;
        return this;
      };

      // BUTTON DATA-API
      // ===============

      $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
        var $btn = $(e.target).closest('.btn');
        Plugin.call($btn, 'toggle');
        if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
          // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
          e.preventDefault();
          // The target component still receive the focus
          if ($btn.is('input,button')) $btn.trigger('focus');else $btn.find('input:visible,button:visible').first().trigger('focus');
        }
      }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
        $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: carousel.js v3.3.7
     * http://getbootstrap.com/javascript/#carousel
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // CAROUSEL CLASS DEFINITION
      // =========================

      var Carousel = function (element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find('.carousel-indicators');
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;

        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));

        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
      };

      Carousel.VERSION = '3.3.7';

      Carousel.TRANSITION_DURATION = 600;

      Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
      };

      Carousel.prototype.keydown = function (e) {
        if (/input|textarea/i.test(e.target.tagName)) return;
        switch (e.which) {
          case 37:
            this.prev();break;
          case 39:
            this.next();break;
          default:
            return;
        }

        e.preventDefault();
      };

      Carousel.prototype.cycle = function (e) {
        e || (this.paused = false);

        this.interval && clearInterval(this.interval);

        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));

        return this;
      };

      Carousel.prototype.getItemIndex = function (item) {
        this.$items = item.parent().children('.item');
        return this.$items.index(item || this.$active);
      };

      Carousel.prototype.getItemForDirection = function (direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = direction == 'prev' && activeIndex === 0 || direction == 'next' && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = direction == 'prev' ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
      };

      Carousel.prototype.to = function (pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));

        if (pos > this.$items.length - 1 || pos < 0) return;

        if (this.sliding) return this.$element.one('slid.bs.carousel', function () {
          that.to(pos);
        }); // yes, "slid"
        if (activeIndex == pos) return this.pause().cycle();

        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
      };

      Carousel.prototype.pause = function (e) {
        e || (this.paused = true);

        if (this.$element.find('.next, .prev').length && $.support.transition) {
          this.$element.trigger($.support.transition.end);
          this.cycle(true);
        }

        this.interval = clearInterval(this.interval);

        return this;
      };

      Carousel.prototype.next = function () {
        if (this.sliding) return;
        return this.slide('next');
      };

      Carousel.prototype.prev = function () {
        if (this.sliding) return;
        return this.slide('prev');
      };

      Carousel.prototype.slide = function (type, next) {
        var $active = this.$element.find('.item.active');
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == 'next' ? 'left' : 'right';
        var that = this;

        if ($next.hasClass('active')) return this.sliding = false;

        var relatedTarget = $next[0];
        var slideEvent = $.Event('slide.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented()) return;

        this.sliding = true;

        isCycling && this.pause();

        if (this.$indicators.length) {
          this.$indicators.find('.active').removeClass('active');
          var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
          $nextIndicator && $nextIndicator.addClass('active');
        }

        var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }); // yes, "slid"
        if ($.support.transition && this.$element.hasClass('slide')) {
          $next.addClass(type);
          $next[0].offsetWidth; // force reflow
          $active.addClass(direction);
          $next.addClass(direction);
          $active.one('bsTransitionEnd', function () {
            $next.removeClass([type, direction].join(' ')).addClass('active');
            $active.removeClass(['active', direction].join(' '));
            that.sliding = false;
            setTimeout(function () {
              that.$element.trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
          $active.removeClass('active');
          $next.addClass('active');
          this.sliding = false;
          this.$element.trigger(slidEvent);
        }

        isCycling && this.cycle();

        return this;
      };

      // CAROUSEL PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.carousel');
          var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
          var action = typeof option == 'string' ? option : options.slide;

          if (!data) $this.data('bs.carousel', data = new Carousel(this, options));
          if (typeof option == 'number') data.to(option);else if (action) data[action]();else if (options.interval) data.pause().cycle();
        });
      }

      var old = $.fn.carousel;

      $.fn.carousel = Plugin;
      $.fn.carousel.Constructor = Carousel;

      // CAROUSEL NO CONFLICT
      // ====================

      $.fn.carousel.noConflict = function () {
        $.fn.carousel = old;
        return this;
      };

      // CAROUSEL DATA-API
      // =================

      var clickHandler = function (e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
        if (!$target.hasClass('carousel')) return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr('data-slide-to');
        if (slideIndex) options.interval = false;

        Plugin.call($target, options);

        if (slideIndex) {
          $target.data('bs.carousel').to(slideIndex);
        }

        e.preventDefault();
      };

      $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);

      $(window).on('load', function () {
        $('[data-ride="carousel"]').each(function () {
          var $carousel = $(this);
          Plugin.call($carousel, $carousel.data());
        });
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: collapse.js v3.3.7
     * http://getbootstrap.com/javascript/#collapse
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    /* jshint latedef: false */

    +function ($) {
      'use strict';

      // COLLAPSE PUBLIC CLASS DEFINITION
      // ================================

      var Collapse = function (element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;

        if (this.options.parent) {
          this.$parent = this.getParent();
        } else {
          this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }

        if (this.options.toggle) this.toggle();
      };

      Collapse.VERSION = '3.3.7';

      Collapse.TRANSITION_DURATION = 350;

      Collapse.DEFAULTS = {
        toggle: true
      };

      Collapse.prototype.dimension = function () {
        var hasWidth = this.$element.hasClass('width');
        return hasWidth ? 'width' : 'height';
      };

      Collapse.prototype.show = function () {
        if (this.transitioning || this.$element.hasClass('in')) return;

        var activesData;
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');

        if (actives && actives.length) {
          activesData = actives.data('bs.collapse');
          if (activesData && activesData.transitioning) return;
        }

        var startEvent = $.Event('show.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;

        if (actives && actives.length) {
          Plugin.call(actives, 'hide');
          activesData || actives.data('bs.collapse', null);
        }

        var dimension = this.dimension();

        this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);

        this.$trigger.removeClass('collapsed').attr('aria-expanded', true);

        this.transitioning = 1;

        var complete = function () {
          this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
          this.transitioning = 0;
          this.$element.trigger('shown.bs.collapse');
        };

        if (!$.support.transition) return complete.call(this);

        var scrollSize = $.camelCase(['scroll', dimension].join('-'));

        this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
      };

      Collapse.prototype.hide = function () {
        if (this.transitioning || !this.$element.hasClass('in')) return;

        var startEvent = $.Event('hide.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;

        var dimension = this.dimension();

        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;

        this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);

        this.$trigger.addClass('collapsed').attr('aria-expanded', false);

        this.transitioning = 1;

        var complete = function () {
          this.transitioning = 0;
          this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
        };

        if (!$.support.transition) return complete.call(this);

        this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
      };

      Collapse.prototype.toggle = function () {
        this[this.$element.hasClass('in') ? 'hide' : 'show']();
      };

      Collapse.prototype.getParent = function () {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
          var $element = $(element);
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
      };

      Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
        var isOpen = $element.hasClass('in');

        $element.attr('aria-expanded', isOpen);
        $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
      };

      function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

        return $(target);
      }

      // COLLAPSE PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.collapse');
          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);

          if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
          if (!data) $this.data('bs.collapse', data = new Collapse(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.collapse;

      $.fn.collapse = Plugin;
      $.fn.collapse.Constructor = Collapse;

      // COLLAPSE NO CONFLICT
      // ====================

      $.fn.collapse.noConflict = function () {
        $.fn.collapse = old;
        return this;
      };

      // COLLAPSE DATA-API
      // =================

      $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
        var $this = $(this);

        if (!$this.attr('data-target')) e.preventDefault();

        var $target = getTargetFromTrigger($this);
        var data = $target.data('bs.collapse');
        var option = data ? 'toggle' : $this.data();

        Plugin.call($target, option);
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: dropdown.js v3.3.7
     * http://getbootstrap.com/javascript/#dropdowns
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // DROPDOWN CLASS DEFINITION
      // =========================

      var backdrop = '.dropdown-backdrop';
      var toggle = '[data-toggle="dropdown"]';
      var Dropdown = function (element) {
        $(element).on('click.bs.dropdown', this.toggle);
      };

      Dropdown.VERSION = '3.3.7';

      function getParent($this) {
        var selector = $this.attr('data-target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        var $parent = selector && $(selector);

        return $parent && $parent.length ? $parent : $this.parent();
      }

      function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function () {
          var $this = $(this);
          var $parent = getParent($this);
          var relatedTarget = { relatedTarget: this };

          if (!$parent.hasClass('open')) return;

          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;

          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));

          if (e.isDefaultPrevented()) return;

          $this.attr('aria-expanded', 'false');
          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
        });
      }

      Dropdown.prototype.toggle = function (e) {
        var $this = $(this);

        if ($this.is('.disabled, :disabled')) return;

        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');

        clearMenus();

        if (!isActive) {
          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
            // if mobile we use a backdrop because click events don't delegate
            $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
          }

          var relatedTarget = { relatedTarget: this };
          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));

          if (e.isDefaultPrevented()) return;

          $this.trigger('focus').attr('aria-expanded', 'true');

          $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
        }

        return false;
      };

      Dropdown.prototype.keydown = function (e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;

        var $this = $(this);

        e.preventDefault();
        e.stopPropagation();

        if ($this.is('.disabled, :disabled')) return;

        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');

        if (!isActive && e.which != 27 || isActive && e.which == 27) {
          if (e.which == 27) $parent.find(toggle).trigger('focus');
          return $this.trigger('click');
        }

        var desc = ' li:not(.disabled):visible a';
        var $items = $parent.find('.dropdown-menu' + desc);

        if (!$items.length) return;

        var index = $items.index(e.target);

        if (e.which == 38 && index > 0) index--; // up
        if (e.which == 40 && index < $items.length - 1) index++; // down
        if (!~index) index = 0;

        $items.eq(index).trigger('focus');
      };

      // DROPDOWN PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.dropdown');

          if (!data) $this.data('bs.dropdown', data = new Dropdown(this));
          if (typeof option == 'string') data[option].call($this);
        });
      }

      var old = $.fn.dropdown;

      $.fn.dropdown = Plugin;
      $.fn.dropdown.Constructor = Dropdown;

      // DROPDOWN NO CONFLICT
      // ====================

      $.fn.dropdown.noConflict = function () {
        $.fn.dropdown = old;
        return this;
      };

      // APPLY TO STANDARD DROPDOWN ELEMENTS
      // ===================================

      $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {
        e.stopPropagation();
      }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: modal.js v3.3.7
     * http://getbootstrap.com/javascript/#modals
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // MODAL CLASS DEFINITION
      // ======================

      var Modal = function (element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find('.modal-dialog');
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;

        if (this.options.remote) {
          this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
            this.$element.trigger('loaded.bs.modal');
          }, this));
        }
      };

      Modal.VERSION = '3.3.7';

      Modal.TRANSITION_DURATION = 300;
      Modal.BACKDROP_TRANSITION_DURATION = 150;

      Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
      };

      Modal.prototype.toggle = function (_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
      };

      Modal.prototype.show = function (_relatedTarget) {
        var that = this;
        var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });

        this.$element.trigger(e);

        if (this.isShown || e.isDefaultPrevented()) return;

        this.isShown = true;

        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass('modal-open');

        this.escape();
        this.resize();

        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));

        this.$dialog.on('mousedown.dismiss.bs.modal', function () {
          that.$element.one('mouseup.dismiss.bs.modal', function (e) {
            if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
          });
        });

        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade');

          if (!that.$element.parent().length) {
            that.$element.appendTo(that.$body); // don't move modals dom position
          }

          that.$element.show().scrollTop(0);

          that.adjustDialog();

          if (transition) {
            that.$element[0].offsetWidth; // force reflow
          }

          that.$element.addClass('in');

          that.enforceFocus();

          var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });

          transition ? that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e);
          }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
        });
      };

      Modal.prototype.hide = function (e) {
        if (e) e.preventDefault();

        e = $.Event('hide.bs.modal');

        this.$element.trigger(e);

        if (!this.isShown || e.isDefaultPrevented()) return;

        this.isShown = false;

        this.escape();
        this.resize();

        $(document).off('focusin.bs.modal');

        this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');

        this.$dialog.off('mousedown.dismiss.bs.modal');

        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
      };

      Modal.prototype.enforceFocus = function () {
        $(document).off('focusin.bs.modal') // guard against infinite focus loop
        .on('focusin.bs.modal', $.proxy(function (e) {
          if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
            this.$element.trigger('focus');
          }
        }, this));
      };

      Modal.prototype.escape = function () {
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
            e.which == 27 && this.hide();
          }, this));
        } else if (!this.isShown) {
          this.$element.off('keydown.dismiss.bs.modal');
        }
      };

      Modal.prototype.resize = function () {
        if (this.isShown) {
          $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
        } else {
          $(window).off('resize.bs.modal');
        }
      };

      Modal.prototype.hideModal = function () {
        var that = this;
        this.$element.hide();
        this.backdrop(function () {
          that.$body.removeClass('modal-open');
          that.resetAdjustments();
          that.resetScrollbar();
          that.$element.trigger('hidden.bs.modal');
        });
      };

      Modal.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
      };

      Modal.prototype.backdrop = function (callback) {
        var that = this;
        var animate = this.$element.hasClass('fade') ? 'fade' : '';

        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate;

          this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);

          this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
            if (this.ignoreBackdropClick) {
              this.ignoreBackdropClick = false;
              return;
            }
            if (e.target !== e.currentTarget) return;
            this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
          }, this));

          if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

          this.$backdrop.addClass('in');

          if (!callback) return;

          doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in');

          var callbackRemove = function () {
            that.removeBackdrop();
            callback && callback();
          };
          $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
          callback();
        }
      };

      // these following methods are used to handle overflowing modals

      Modal.prototype.handleUpdate = function () {
        this.adjustDialog();
      };

      Modal.prototype.adjustDialog = function () {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;

        this.$element.css({
          paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
          paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        });
      };

      Modal.prototype.resetAdjustments = function () {
        this.$element.css({
          paddingLeft: '',
          paddingRight: ''
        });
      };

      Modal.prototype.checkScrollbar = function () {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
          // workaround for missing window.innerWidth in IE8
          var documentElementRect = document.documentElement.getBoundingClientRect();
          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
      };

      Modal.prototype.setScrollbar = function () {
        var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || '';
        if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
      };

      Modal.prototype.resetScrollbar = function () {
        this.$body.css('padding-right', this.originalBodyPad);
      };

      Modal.prototype.measureScrollbar = function () {
        // thx walsh
        var scrollDiv = document.createElement('div');
        scrollDiv.className = 'modal-scrollbar-measure';
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
      };

      // MODAL PLUGIN DEFINITION
      // =======================

      function Plugin(option, _relatedTarget) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.modal');
          var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);

          if (!data) $this.data('bs.modal', data = new Modal(this, options));
          if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
        });
      }

      var old = $.fn.modal;

      $.fn.modal = Plugin;
      $.fn.modal.Constructor = Modal;

      // MODAL NO CONFLICT
      // =================

      $.fn.modal.noConflict = function () {
        $.fn.modal = old;
        return this;
      };

      // MODAL DATA-API
      // ==============

      $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
        var $this = $(this);
        var href = $this.attr('href');
        var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
        var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());

        if ($this.is('a')) e.preventDefault();

        $target.one('show.bs.modal', function (showEvent) {
          if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown
          $target.one('hidden.bs.modal', function () {
            $this.is(':visible') && $this.trigger('focus');
          });
        });
        Plugin.call($target, option, this);
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: tooltip.js v3.3.7
     * http://getbootstrap.com/javascript/#tooltip
     * Inspired by the original jQuery.tipsy by Jason Frame
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // TOOLTIP PUBLIC CLASS DEFINITION
      // ===============================

      var Tooltip = function (element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;

        this.init('tooltip', element, options);
      };

      Tooltip.VERSION = '3.3.7';

      Tooltip.TRANSITION_DURATION = 150;

      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };

      Tooltip.prototype.init = function (type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
        this.inState = { click: false, hover: false, focus: false };

        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
          throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
        }

        var triggers = this.options.trigger.split(' ');

        for (var i = triggers.length; i--;) {
          var trigger = triggers[i];

          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';

            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }

        this.options.selector ? this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' }) : this.fixTitle();
      };

      Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS;
      };

      Tooltip.prototype.getOptions = function (options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);

        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }

        return options;
      };

      Tooltip.prototype.getDelegateOptions = function () {
        var options = {};
        var defaults = this.getDefaults();

        this._options && $.each(this._options, function (key, value) {
          if (defaults[key] != value) options[key] = value;
        });

        return options;
      };

      Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
        }

        if (self.tip().hasClass('in') || self.hoverState == 'in') {
          self.hoverState = 'in';
          return;
        }

        clearTimeout(self.timeout);

        self.hoverState = 'in';

        if (!self.options.delay || !self.options.delay.show) return self.show();

        self.timeout = setTimeout(function () {
          if (self.hoverState == 'in') self.show();
        }, self.options.delay.show);
      };

      Tooltip.prototype.isInStateTrue = function () {
        for (var key in this.inState) {
          if (this.inState[key]) return true;
        }

        return false;
      };

      Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
        }

        if (self.isInStateTrue()) return;

        clearTimeout(self.timeout);

        self.hoverState = 'out';

        if (!self.options.delay || !self.options.delay.hide) return self.hide();

        self.timeout = setTimeout(function () {
          if (self.hoverState == 'out') self.hide();
        }, self.options.delay.hide);
      };

      Tooltip.prototype.show = function () {
        var e = $.Event('show.bs.' + this.type);

        if (this.hasContent() && this.enabled) {
          this.$element.trigger(e);

          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
          if (e.isDefaultPrevented() || !inDom) return;
          var that = this;

          var $tip = this.tip();

          var tipId = this.getUID(this.type);

          this.setContent();
          $tip.attr('id', tipId);
          this.$element.attr('aria-describedby', tipId);

          if (this.options.animation) $tip.addClass('fade');

          var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;

          var autoToken = /\s?auto?\s?/i;
          var autoPlace = autoToken.test(placement);
          if (autoPlace) placement = placement.replace(autoToken, '') || 'top';

          $tip.detach().css({ top: 0, left: 0, display: 'block' }).addClass(placement).data('bs.' + this.type, this);

          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
          this.$element.trigger('inserted.bs.' + this.type);

          var pos = this.getPosition();
          var actualWidth = $tip[0].offsetWidth;
          var actualHeight = $tip[0].offsetHeight;

          if (autoPlace) {
            var orgPlacement = placement;
            var viewportDim = this.getPosition(this.$viewport);

            placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;

            $tip.removeClass(orgPlacement).addClass(placement);
          }

          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);

          this.applyPlacement(calculatedOffset, placement);

          var complete = function () {
            var prevHoverState = that.hoverState;
            that.$element.trigger('shown.bs.' + that.type);
            that.hoverState = null;

            if (prevHoverState == 'out') that.leave(that);
          };

          $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
      };

      Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;

        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10);

        // we must check for NaN for ie 8/9
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;

        offset.top += marginTop;
        offset.left += marginLeft;

        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset($tip[0], $.extend({
          using: function (props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }
        }, offset), 0);

        $tip.addClass('in');

        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;

        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }

        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);

        if (delta.left) offset.left += delta.left;else offset.top += delta.top;

        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';

        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };

      Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
        this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
      };

      Tooltip.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();

        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };

      Tooltip.prototype.hide = function (callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event('hide.bs.' + this.type);

        function complete() {
          if (that.hoverState != 'in') $tip.detach();
          if (that.$element) {
            // TODO: Check whether guarding this code with this `if` is really necessary.
            that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
          }
          callback && callback();
        }

        this.$element.trigger(e);

        if (e.isDefaultPrevented()) return;

        $tip.removeClass('in');

        $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();

        this.hoverState = null;

        return this;
      };

      Tooltip.prototype.fixTitle = function () {
        var $e = this.$element;
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };

      Tooltip.prototype.hasContent = function () {
        return this.getTitle();
      };

      Tooltip.prototype.getPosition = function ($element) {
        $element = $element || this.$element;

        var el = $element[0];
        var isBody = el.tagName == 'BODY';

        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
          // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
          elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });
        }
        var isSvg = window.SVGElement && el instanceof window.SVGElement;
        // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
        // See https://github.com/twbs/bootstrap/issues/20280
        var elOffset = isBody ? { top: 0, left: 0 } : isSvg ? null : $element.offset();
        var scroll = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() };
        var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null;

        return $.extend({}, elRect, scroll, outerDims, elOffset);
      };

      Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'top' ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'left' ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */{ top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width };
      };

      Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = { top: 0, left: 0 };
        if (!this.$viewport) return delta;

        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);

        if (/right|left/.test(placement)) {
          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
          if (topEdgeOffset < viewportDimensions.top) {
            // top overflow
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
            // bottom overflow
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
          if (leftEdgeOffset < viewportDimensions.left) {
            // left overflow
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.right) {
            // right overflow
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }

        return delta;
      };

      Tooltip.prototype.getTitle = function () {
        var title;
        var $e = this.$element;
        var o = this.options;

        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);

        return title;
      };

      Tooltip.prototype.getUID = function (prefix) {
        do prefix += ~~(Math.random() * 1000000); while (document.getElementById(prefix));
        return prefix;
      };

      Tooltip.prototype.tip = function () {
        if (!this.$tip) {
          this.$tip = $(this.options.template);
          if (this.$tip.length != 1) {
            throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
          }
        }
        return this.$tip;
      };

      Tooltip.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
      };

      Tooltip.prototype.enable = function () {
        this.enabled = true;
      };

      Tooltip.prototype.disable = function () {
        this.enabled = false;
      };

      Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled;
      };

      Tooltip.prototype.toggle = function (e) {
        var self = this;
        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);
          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }

        if (e) {
          self.inState.click = !self.inState.click;
          if (self.isInStateTrue()) self.enter(self);else self.leave(self);
        } else {
          self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
        }
      };

      Tooltip.prototype.destroy = function () {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function () {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
          if (that.$tip) {
            that.$tip.detach();
          }
          that.$tip = null;
          that.$arrow = null;
          that.$viewport = null;
          that.$element = null;
        });
      };

      // TOOLTIP PLUGIN DEFINITION
      // =========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.tooltip');
          var options = typeof option == 'object' && option;

          if (!data && /destroy|hide/.test(option)) return;
          if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.tooltip;

      $.fn.tooltip = Plugin;
      $.fn.tooltip.Constructor = Tooltip;

      // TOOLTIP NO CONFLICT
      // ===================

      $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old;
        return this;
      };
    }(jQuery);

    /* ========================================================================
     * Bootstrap: popover.js v3.3.7
     * http://getbootstrap.com/javascript/#popovers
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // POPOVER PUBLIC CLASS DEFINITION
      // ===============================

      var Popover = function (element, options) {
        this.init('popover', element, options);
      };

      if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');

      Popover.VERSION = '3.3.7';

      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      });

      // NOTE: POPOVER EXTENDS tooltip.js
      // ================================

      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);

      Popover.prototype.constructor = Popover;

      Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS;
      };

      Popover.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();

        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[// we use append for html objects to maintain js events
        this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);

        $tip.removeClass('fade top bottom left right in');

        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
      };

      Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent();
      };

      Popover.prototype.getContent = function () {
        var $e = this.$element;
        var o = this.options;

        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
      };

      Popover.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.arrow');
      };

      // POPOVER PLUGIN DEFINITION
      // =========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.popover');
          var options = typeof option == 'object' && option;

          if (!data && /destroy|hide/.test(option)) return;
          if (!data) $this.data('bs.popover', data = new Popover(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.popover;

      $.fn.popover = Plugin;
      $.fn.popover.Constructor = Popover;

      // POPOVER NO CONFLICT
      // ===================

      $.fn.popover.noConflict = function () {
        $.fn.popover = old;
        return this;
      };
    }(jQuery);

    /* ========================================================================
     * Bootstrap: scrollspy.js v3.3.7
     * http://getbootstrap.com/javascript/#scrollspy
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // SCROLLSPY CLASS DEFINITION
      // ==========================

      function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || '') + ' .nav li > a';
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;

        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
        this.refresh();
        this.process();
      }

      ScrollSpy.VERSION = '3.3.7';

      ScrollSpy.DEFAULTS = {
        offset: 10
      };

      ScrollSpy.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
      };

      ScrollSpy.prototype.refresh = function () {
        var that = this;
        var offsetMethod = 'offset';
        var offsetBase = 0;

        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();

        if (!$.isWindow(this.$scrollElement[0])) {
          offsetMethod = 'position';
          offsetBase = this.$scrollElement.scrollTop();
        }

        this.$body.find(this.selector).map(function () {
          var $el = $(this);
          var href = $el.data('target') || $el.attr('href');
          var $href = /^#./.test(href) && $(href);

          return $href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]] || null;
        }).sort(function (a, b) {
          return a[0] - b[0];
        }).each(function () {
          that.offsets.push(this[0]);
          that.targets.push(this[1]);
        });
      };

      ScrollSpy.prototype.process = function () {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;

        if (this.scrollHeight != scrollHeight) {
          this.refresh();
        }

        if (scrollTop >= maxScroll) {
          return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }

        if (activeTarget && scrollTop < offsets[0]) {
          this.activeTarget = null;
          return this.clear();
        }

        for (i = offsets.length; i--;) {
          activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
      };

      ScrollSpy.prototype.activate = function (target) {
        this.activeTarget = target;

        this.clear();

        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';

        var active = $(selector).parents('li').addClass('active');

        if (active.parent('.dropdown-menu').length) {
          active = active.closest('li.dropdown').addClass('active');
        }

        active.trigger('activate.bs.scrollspy');
      };

      ScrollSpy.prototype.clear = function () {
        $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
      };

      // SCROLLSPY PLUGIN DEFINITION
      // ===========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.scrollspy');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.scrollspy', data = new ScrollSpy(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.scrollspy;

      $.fn.scrollspy = Plugin;
      $.fn.scrollspy.Constructor = ScrollSpy;

      // SCROLLSPY NO CONFLICT
      // =====================

      $.fn.scrollspy.noConflict = function () {
        $.fn.scrollspy = old;
        return this;
      };

      // SCROLLSPY DATA-API
      // ==================

      $(window).on('load.bs.scrollspy.data-api', function () {
        $('[data-spy="scroll"]').each(function () {
          var $spy = $(this);
          Plugin.call($spy, $spy.data());
        });
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: tab.js v3.3.7
     * http://getbootstrap.com/javascript/#tabs
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // TAB CLASS DEFINITION
      // ====================

      var Tab = function (element) {
        // jscs:disable requireDollarBeforejQueryAssignment
        this.element = $(element);
        // jscs:enable requireDollarBeforejQueryAssignment
      };

      Tab.VERSION = '3.3.7';

      Tab.TRANSITION_DURATION = 150;

      Tab.prototype.show = function () {
        var $this = this.element;
        var $ul = $this.closest('ul:not(.dropdown-menu)');
        var selector = $this.data('target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        if ($this.parent('li').hasClass('active')) return;

        var $previous = $ul.find('.active:last a');
        var hideEvent = $.Event('hide.bs.tab', {
          relatedTarget: $this[0]
        });
        var showEvent = $.Event('show.bs.tab', {
          relatedTarget: $previous[0]
        });

        $previous.trigger(hideEvent);
        $this.trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;

        var $target = $(selector);

        this.activate($this.closest('li'), $ul);
        this.activate($target, $target.parent(), function () {
          $previous.trigger({
            type: 'hidden.bs.tab',
            relatedTarget: $this[0]
          });
          $this.trigger({
            type: 'shown.bs.tab',
            relatedTarget: $previous[0]
          });
        });
      };

      Tab.prototype.activate = function (element, container, callback) {
        var $active = container.find('> .active');
        var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);

        function next() {
          $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);

          element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);

          if (transition) {
            element[0].offsetWidth; // reflow for transition
            element.addClass('in');
          } else {
            element.removeClass('fade');
          }

          if (element.parent('.dropdown-menu').length) {
            element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
          }

          callback && callback();
        }

        $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();

        $active.removeClass('in');
      };

      // TAB PLUGIN DEFINITION
      // =====================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.tab');

          if (!data) $this.data('bs.tab', data = new Tab(this));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.tab;

      $.fn.tab = Plugin;
      $.fn.tab.Constructor = Tab;

      // TAB NO CONFLICT
      // ===============

      $.fn.tab.noConflict = function () {
        $.fn.tab = old;
        return this;
      };

      // TAB DATA-API
      // ============

      var clickHandler = function (e) {
        e.preventDefault();
        Plugin.call($(this), 'show');
      };

      $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: affix.js v3.3.7
     * http://getbootstrap.com/javascript/#affix
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // AFFIX CLASS DEFINITION
      // ======================

      var Affix = function (element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);

        this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));

        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;

        this.checkPosition();
      };

      Affix.VERSION = '3.3.7';

      Affix.RESET = 'affix affix-top affix-bottom';

      Affix.DEFAULTS = {
        offset: 0,
        target: window
      };

      Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();

        if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false;

        if (this.affixed == 'bottom') {
          if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : 'bottom';
          return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : 'bottom';
        }

        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;

        if (offsetTop != null && scrollTop <= offsetTop) return 'top';
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return 'bottom';

        return false;
      };

      Affix.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass('affix');
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
      };

      Affix.prototype.checkPositionWithEventLoop = function () {
        setTimeout($.proxy(this.checkPosition, this), 1);
      };

      Affix.prototype.checkPosition = function () {
        if (!this.$element.is(':visible')) return;

        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());

        if (typeof offset != 'object') offsetBottom = offsetTop = offset;
        if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element);

        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);

        if (this.affixed != affix) {
          if (this.unpin != null) this.$element.css('top', '');

          var affixType = 'affix' + (affix ? '-' + affix : '');
          var e = $.Event(affixType + '.bs.affix');

          this.$element.trigger(e);

          if (e.isDefaultPrevented()) return;

          this.affixed = affix;
          this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;

          this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
        }

        if (affix == 'bottom') {
          this.$element.offset({
            top: scrollHeight - height - offsetBottom
          });
        }
      };

      // AFFIX PLUGIN DEFINITION
      // =======================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.affix');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.affix', data = new Affix(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.affix;

      $.fn.affix = Plugin;
      $.fn.affix.Constructor = Affix;

      // AFFIX NO CONFLICT
      // =================

      $.fn.affix.noConflict = function () {
        $.fn.affix = old;
        return this;
      };

      // AFFIX DATA-API
      // ==============

      $(window).on('load', function () {
        $('[data-spy="affix"]').each(function () {
          var $spy = $(this);
          var data = $spy.data();

          data.offset = data.offset || {};

          if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
          if (data.offsetTop != null) data.offset.top = data.offsetTop;

          Plugin.call($spy, data);
        });
      });
    }(jQuery);
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("7e", ["7d"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("7d");
});
$__System.registerDynamic('7f', ['80'], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    CodeMirror.defineMode("xml", function (config, parserConfig) {
      var indentUnit = config.indentUnit;
      var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;
      var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag || true;

      var Kludges = parserConfig.htmlMode ? {
        autoSelfClosers: { 'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
          'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
          'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
          'track': true, 'wbr': true },
        implicitlyClosed: { 'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
          'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
          'th': true, 'tr': true },
        contextGrabbers: {
          'dd': { 'dd': true, 'dt': true },
          'dt': { 'dd': true, 'dt': true },
          'li': { 'li': true },
          'option': { 'option': true, 'optgroup': true },
          'optgroup': { 'optgroup': true },
          'p': { 'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true },
          'rp': { 'rp': true, 'rt': true },
          'rt': { 'rp': true, 'rt': true },
          'tbody': { 'tbody': true, 'tfoot': true },
          'td': { 'td': true, 'th': true },
          'tfoot': { 'tbody': true },
          'th': { 'td': true, 'th': true },
          'thead': { 'tbody': true, 'tfoot': true },
          'tr': { 'tr': true }
        },
        doNotIndent: { "pre": true },
        allowUnquoted: true,
        allowMissing: true
      } : {
        autoSelfClosers: {},
        implicitlyClosed: {},
        contextGrabbers: {},
        doNotIndent: {},
        allowUnquoted: false,
        allowMissing: false
      };
      var alignCDATA = parserConfig.alignCDATA;

      // Return variables for tokenizers
      var tagName, type;

      function inText(stream, state) {
        function chain(parser) {
          state.tokenize = parser;
          return parser(stream, state);
        }

        var ch = stream.next();
        if (ch == "<") {
          if (stream.eat("!")) {
            if (stream.eat("[")) {
              if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));else return null;
            } else if (stream.match("--")) {
              return chain(inBlock("comment", "-->"));
            } else if (stream.match("DOCTYPE", true, true)) {
              stream.eatWhile(/[\w\._\-]/);
              return chain(doctype(1));
            } else {
              return null;
            }
          } else if (stream.eat("?")) {
            stream.eatWhile(/[\w\._\-]/);
            state.tokenize = inBlock("meta", "?>");
            return "meta";
          } else {
            var isClose = stream.eat("/");
            tagName = "";
            var c;
            while (c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/)) tagName += c;
            if (!tagName) return "tag error";
            type = isClose ? "closeTag" : "openTag";
            state.tokenize = inTag;
            return "tag";
          }
        } else if (ch == "&") {
          var ok;
          if (stream.eat("#")) {
            if (stream.eat("x")) {
              ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
            } else {
              ok = stream.eatWhile(/[\d]/) && stream.eat(";");
            }
          } else {
            ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
          }
          return ok ? "atom" : "error";
        } else {
          stream.eatWhile(/[^&<]/);
          return null;
        }
      }

      function inTag(stream, state) {
        var ch = stream.next();
        if (ch == ">" || ch == "/" && stream.eat(">")) {
          state.tokenize = inText;
          type = ch == ">" ? "endTag" : "selfcloseTag";
          return "tag";
        } else if (ch == "=") {
          type = "equals";
          return null;
        } else if (ch == "<") {
          state.tokenize = inText;
          var next = state.tokenize(stream, state);
          return next ? next + " error" : "error";
        } else if (/[\'\"]/.test(ch)) {
          state.tokenize = inAttribute(ch);
          state.stringStartCol = stream.column();
          return state.tokenize(stream, state);
        } else {
          stream.eatWhile(/[^\s\u00a0=<>\"\']/);
          return "word";
        }
      }

      function inAttribute(quote) {
        var closure = function (stream, state) {
          while (!stream.eol()) {
            if (stream.next() == quote) {
              state.tokenize = inTag;
              break;
            }
          }
          return "string";
        };
        closure.isInAttribute = true;
        return closure;
      }

      function inBlock(style, terminator) {
        return function (stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = inText;
              break;
            }
            stream.next();
          }
          return style;
        };
      }
      function doctype(depth) {
        return function (stream, state) {
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch == "<") {
              state.tokenize = doctype(depth + 1);
              return state.tokenize(stream, state);
            } else if (ch == ">") {
              if (depth == 1) {
                state.tokenize = inText;
                break;
              } else {
                state.tokenize = doctype(depth - 1);
                return state.tokenize(stream, state);
              }
            }
          }
          return "meta";
        };
      }

      var curState, curStream, setStyle;
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }

      function pushContext(tagName, startOfLine) {
        var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || curState.context && curState.context.noIndent;
        curState.context = {
          prev: curState.context,
          tagName: tagName,
          indent: curState.indented,
          startOfLine: startOfLine,
          noIndent: noIndent
        };
      }
      function popContext() {
        if (curState.context) curState.context = curState.context.prev;
      }

      function element(type) {
        if (type == "openTag") {
          curState.tagName = tagName;
          curState.tagStart = curStream.column();
          return cont(attributes, endtag(curState.startOfLine));
        } else if (type == "closeTag") {
          var err = false;
          if (curState.context) {
            if (curState.context.tagName != tagName) {
              if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
                popContext();
              }
              err = !curState.context || curState.context.tagName != tagName;
            }
          } else {
            err = true;
          }
          if (err) setStyle = "error";
          return cont(endclosetag(err));
        }
        return cont();
      }
      function endtag(startOfLine) {
        return function (type) {
          var tagName = curState.tagName;
          curState.tagName = curState.tagStart = null;
          if (type == "selfcloseTag" || type == "endTag" && Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) {
            maybePopContext(tagName.toLowerCase());
            return cont();
          }
          if (type == "endTag") {
            maybePopContext(tagName.toLowerCase());
            pushContext(tagName, startOfLine);
            return cont();
          }
          return cont();
        };
      }
      function endclosetag(err) {
        return function (type) {
          if (err) setStyle = "error";
          if (type == "endTag") {
            popContext();return cont();
          }
          setStyle = "error";
          return cont(arguments.callee);
        };
      }
      function maybePopContext(nextTagName) {
        var parentTagName;
        while (true) {
          if (!curState.context) {
            return;
          }
          parentTagName = curState.context.tagName.toLowerCase();
          if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
            return;
          }
          popContext();
        }
      }

      function attributes(type) {
        if (type == "word") {
          setStyle = "attribute";return cont(attribute, attributes);
        }
        if (type == "endTag" || type == "selfcloseTag") return pass();
        setStyle = "error";
        return cont(attributes);
      }
      function attribute(type) {
        if (type == "equals") return cont(attvalue, attributes);
        if (!Kludges.allowMissing) setStyle = "error";else if (type == "word") {
          setStyle = "attribute";return cont(attribute, attributes);
        }
        return type == "endTag" || type == "selfcloseTag" ? pass() : cont();
      }
      function attvalue(type) {
        if (type == "string") return cont(attvaluemaybe);
        if (type == "word" && Kludges.allowUnquoted) {
          setStyle = "string";return cont();
        }
        setStyle = "error";
        return type == "endTag" || type == "selfCloseTag" ? pass() : cont();
      }
      function attvaluemaybe(type) {
        if (type == "string") return cont(attvaluemaybe);else return pass();
      }

      return {
        startState: function () {
          return { tokenize: inText, cc: [], indented: 0, startOfLine: true, tagName: null, tagStart: null, context: null };
        },

        token: function (stream, state) {
          if (!state.tagName && stream.sol()) {
            state.startOfLine = true;
            state.indented = stream.indentation();
          }
          if (stream.eatSpace()) return null;

          setStyle = type = tagName = null;
          var style = state.tokenize(stream, state);
          state.type = type;
          if ((style || type) && style != "comment") {
            curState = state;curStream = stream;
            while (true) {
              var comb = state.cc.pop() || element;
              if (comb(type || style)) break;
            }
          }
          state.startOfLine = false;
          if (setStyle) style = setStyle == "error" ? style + " error" : setStyle;
          return style;
        },

        indent: function (state, textAfter, fullLine) {
          var context = state.context;
          // Indent multi-line strings (e.g. css).
          if (state.tokenize.isInAttribute) {
            return state.stringStartCol + 1;
          }
          if (state.tokenize != inTag && state.tokenize != inText || context && context.noIndent) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
          // Indent the starts of attribute names.
          if (state.tagName) {
            if (multilineTagIndentPastTag) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * multilineTagIndentFactor;
          }
          if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
          if (context && /^<\//.test(textAfter)) context = context.prev;
          while (context && !context.startOfLine) context = context.prev;
          if (context) return context.indent + indentUnit;else return 0;
        },

        electricChars: "/",
        blockCommentStart: "<!--",
        blockCommentEnd: "-->",

        configuration: parserConfig.htmlMode ? "html" : "xml",
        helperType: parserConfig.htmlMode ? "html" : "xml"
      };
    });

    CodeMirror.defineMIME("text/xml", "xml");
    CodeMirror.defineMIME("application/xml", "xml");
    if (!CodeMirror.mimeModes.hasOwnProperty("text/html")) CodeMirror.defineMIME("text/html", { name: "xml", htmlMode: true });
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("81", ["80"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    // TODO actually recognize syntax of TypeScript constructs

    CodeMirror.defineMode("javascript", function (config, parserConfig) {
      var indentUnit = config.indentUnit;
      var statementIndent = parserConfig.statementIndent;
      var jsonMode = parserConfig.json;
      var isTS = parserConfig.typescript;

      // Tokenizer

      var keywords = function () {
        function kw(type) {
          return { type: type, style: "keyword" };
        }
        var A = kw("keyword a"),
            B = kw("keyword b"),
            C = kw("keyword c");
        var operator = kw("operator"),
            atom = { type: "atom", style: "atom" };

        var jsKeywords = {
          "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
          "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C,
          "var": kw("var"), "const": kw("var"), "let": kw("var"),
          "function": kw("function"), "catch": kw("catch"),
          "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
          "in": operator, "typeof": operator, "instanceof": operator,
          "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
          "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
          "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
        };

        // Extend the 'normal' keywords with the TypeScript language extensions
        if (isTS) {
          var type = { type: "variable", style: "variable-3" };
          var tsKeywords = {
            // object-like things
            "interface": kw("interface"),
            "extends": kw("extends"),
            "constructor": kw("constructor"),

            // scope modifiers
            "public": kw("public"),
            "private": kw("private"),
            "protected": kw("protected"),
            "static": kw("static"),

            // types
            "string": type, "number": type, "bool": type, "any": type
          };

          for (var attr in tsKeywords) {
            jsKeywords[attr] = tsKeywords[attr];
          }
        }

        return jsKeywords;
      }();

      var isOperatorChar = /[+\-*&%=<>!?|~^]/;

      function nextUntilUnescaped(stream, end) {
        var escaped = false,
            next;
        while ((next = stream.next()) != null) {
          if (next == end && !escaped) return false;
          escaped = !escaped && next == "\\";
        }
        return escaped;
      }

      // Used as scratch variables to communicate multiple values without
      // consing up tons of objects.
      var type, content;
      function ret(tp, style, cont) {
        type = tp;content = cont;
        return style;
      }
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
          return ret("number", "number");
        } else if (ch == "." && stream.match("..")) {
          return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return ret(ch);
        } else if (ch == "=" && stream.eat(">")) {
          return ret("=>");
        } else if (ch == "0" && stream.eat(/x/i)) {
          stream.eatWhile(/[\da-f]/i);
          return ret("number", "number");
        } else if (/\d/.test(ch)) {
          stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
          return ret("number", "number");
        } else if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (state.lastType == "operator" || state.lastType == "keyword c" || state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
            nextUntilUnescaped(stream, "/");
            stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
            return ret("regexp", "string-2");
          } else {
            stream.eatWhile(isOperatorChar);
            return ret("operator", null, stream.current());
          }
        } else if (ch == "`") {
          state.tokenize = tokenQuasi;
          return tokenQuasi(stream, state);
        } else if (ch == "#") {
          stream.skipToEnd();
          return ret("error", "error");
        } else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return ret("operator", null, stream.current());
        } else {
          stream.eatWhile(/[\w\$_]/);
          var word = stream.current(),
              known = keywords.propertyIsEnumerable(word) && keywords[word];
          return known && state.lastType != "." ? ret(known.type, known.style, word) : ret("variable", "variable", word);
        }
      }

      function tokenString(quote) {
        return function (stream, state) {
          if (!nextUntilUnescaped(stream, quote)) state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false,
            ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = ch == "*";
        }
        return ret("comment", "comment");
      }

      function tokenQuasi(stream, state) {
        var escaped = false,
            next;
        while ((next = stream.next()) != null) {
          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
            state.tokenize = tokenBase;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
      }

      var brackets = "([{}])";
      // This is a crude lookahead trick to try and notice that we're
      // parsing the argument patterns for a fat-arrow function before we
      // actually hit the arrow token. It only works if the arrow is on
      // the same line as the arguments and there's no strange noise
      // (comments) in between. Fallback is to only notice when we hit the
      // arrow, and not declare the arguments as locals for the arrow
      // body.
      function findFatArrow(stream, state) {
        if (state.fatArrowAt) state.fatArrowAt = null;
        var arrow = stream.string.indexOf("=>", stream.start);
        if (arrow < 0) return;

        var depth = 0,
            sawSomething = false;
        for (var pos = arrow - 1; pos >= 0; --pos) {
          var ch = stream.string.charAt(pos);
          var bracket = brackets.indexOf(ch);
          if (bracket >= 0 && bracket < 3) {
            if (!depth) {
              ++pos;break;
            }
            if (--depth == 0) break;
          } else if (bracket >= 3 && bracket < 6) {
            ++depth;
          } else if (/[$\w]/.test(ch)) {
            sawSomething = true;
          } else if (sawSomething && !depth) {
            ++pos;
            break;
          }
        }
        if (sawSomething && !depth) state.fatArrowAt = pos;
      }

      // Parser

      var atomicTypes = { "atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true };

      function JSLexical(indented, column, type, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.prev = prev;
        this.info = info;
        if (align != null) this.align = align;
      }

      function inScope(state, varname) {
        for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;
        for (var cx = state.context; cx; cx = cx.prev) {
          for (var v = cx.vars; v; v = v.next) if (v.name == varname) return true;
        }
      }

      function parseJS(state, style, type, content, stream) {
        var cc = state.cc;
        // Communicate our context to the combinators.
        // (Less wasteful than consing up a hundred closures on every call.)
        cx.state = state;cx.stream = stream;cx.marked = null, cx.cc = cc;

        if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;

        while (true) {
          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
          if (combinator(type, content)) {
            while (cc.length && cc[cc.length - 1].lex) cc.pop()();
            if (cx.marked) return cx.marked;
            if (type == "variable" && inScope(state, content)) return "variable-2";
            return style;
          }
        }
      }

      // Combinator utils

      var cx = { state: null, column: null, marked: null, cc: null };
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function register(varname) {
        function inList(list) {
          for (var v = list; v; v = v.next) if (v.name == varname) return true;
          return false;
        }
        var state = cx.state;
        if (state.context) {
          cx.marked = "def";
          if (inList(state.localVars)) return;
          state.localVars = { name: varname, next: state.localVars };
        } else {
          if (inList(state.globalVars)) return;
          if (parserConfig.globalVars) state.globalVars = { name: varname, next: state.globalVars };
        }
      }

      // Combinators

      var defaultVars = { name: "this", next: { name: "arguments" } };
      function pushcontext() {
        cx.state.context = { prev: cx.state.context, vars: cx.state.localVars };
        cx.state.localVars = defaultVars;
      }
      function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
      }
      function pushlex(type, info) {
        var result = function () {
          var state = cx.state,
              indent = state.indented;
          if (state.lexical.type == "stat") indent = state.lexical.indented;
          state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
        };
        result.lex = true;
        return result;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")") state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;

      function expect(wanted) {
        return function (type) {
          if (type == wanted) return cont();else if (wanted == ";") return pass();else return cont(arguments.callee);
        };
      }

      function statement(type, value) {
        if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
        if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
        if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
        if (type == "{") return cont(pushlex("}"), block, poplex);
        if (type == ";") return cont();
        if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);
        if (type == "function") return cont(functiondef);
        if (type == "for") return cont(pushlex("form"), forspec, poplex, statement, poplex);
        if (type == "variable") return cont(pushlex("stat"), maybelabel);
        if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"), block, poplex, poplex);
        if (type == "case") return cont(expression, expect(":"));
        if (type == "default") return cont(expect(":"));
        if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext);
        if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
        if (type == "class") return cont(pushlex("form"), className, objlit, poplex);
        if (type == "export") return cont(pushlex("form"), afterExport, poplex);
        if (type == "import") return cont(pushlex("form"), afterImport, poplex);
        return pass(pushlex("stat"), expression, expect(";"), poplex);
      }
      function expression(type) {
        return expressionInner(type, false);
      }
      function expressionNoComma(type) {
        return expressionInner(type, true);
      }
      function expressionInner(type, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
          var body = noComma ? arrowBodyNoComma : arrowBody;
          if (type == "(") return cont(pushcontext, commasep(pattern, ")"), expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
        }

        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
        if (type == "function") return cont(functiondef);
        if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
        if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
        if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
        if (type == "[") return cont(pushlex("]"), expressionNoComma, maybeArrayComprehension, poplex, maybeop);
        if (type == "{") return cont(commasep(objprop, "}"), maybeop);
        return cont();
      }
      function maybeexpression(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expression);
      }
      function maybeexpressionNoComma(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expressionNoComma);
      }

      function maybeoperatorComma(type, value) {
        if (type == ",") return cont(expression);
        return maybeoperatorNoComma(type, value, false);
      }
      function maybeoperatorNoComma(type, value, noComma) {
        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type == "operator") {
          if (/\+\+|--/.test(value)) return cont(me);
          if (value == "?") return cont(expression, expect(":"), expr);
          return cont(expr);
        }
        if (type == "quasi") {
          cx.cc.push(me);return quasi(value);
        }
        if (type == ";") return;
        if (type == "(") return cont(commasep(expressionNoComma, ")", "call"), me);
        if (type == ".") return cont(property, me);
        if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      }
      function quasi(value) {
        if (!value) debugger;
        if (value.slice(value.length - 2) != "${") return cont();
        return cont(expression, continueQuasi);
      }
      function continueQuasi(type) {
        if (type == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont();
        }
      }
      function arrowBody(type) {
        findFatArrow(cx.stream, cx.state);
        if (type == "{") return pass(statement);
        return pass(expression);
      }
      function arrowBodyNoComma(type) {
        findFatArrow(cx.stream, cx.state);
        if (type == "{") return pass(statement);
        return pass(expressionNoComma);
      }
      function maybelabel(type) {
        if (type == ":") return cont(poplex, statement);
        return pass(maybeoperatorComma, expect(";"), poplex);
      }
      function property(type) {
        if (type == "variable") {
          cx.marked = "property";return cont();
        }
      }
      function objprop(type, value) {
        if (type == "variable") {
          cx.marked = "property";
          if (value == "get" || value == "set") return cont(getterSetter);
        } else if (type == "number" || type == "string") {
          cx.marked = type + " property";
        } else if (type == "[") {
          return cont(expression, expect("]"), afterprop);
        }
        if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);
      }
      function getterSetter(type) {
        if (type != "variable") return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
      }
      function afterprop(type) {
        if (type == ":") return cont(expressionNoComma);
        if (type == "(") return pass(functiondef);
      }
      function commasep(what, end, info) {
        function proceed(type) {
          if (type == ",") {
            var lex = cx.state.lexical;
            if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
            return cont(what, proceed);
          }
          if (type == end) return cont();
          return cont(expect(end));
        }
        return function (type) {
          if (type == end) return cont();
          if (info === false) return pass(what, proceed);
          return pass(pushlex(end, info), what, proceed, poplex);
        };
      }
      function block(type) {
        if (type == "}") return cont();
        return pass(statement, block);
      }
      function maybetype(type) {
        if (isTS && type == ":") return cont(typedef);
      }
      function typedef(type) {
        if (type == "variable") {
          cx.marked = "variable-3";return cont();
        }
      }
      function vardef() {
        return pass(pattern, maybetype, maybeAssign, vardefCont);
      }
      function pattern(type, value) {
        if (type == "variable") {
          register(value);return cont();
        }
        if (type == "[") return cont(commasep(pattern, "]"));
        if (type == "{") return cont(commasep(proppattern, "}"));
      }
      function proppattern(type, value) {
        if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
          register(value);
          return cont(maybeAssign);
        }
        if (type == "variable") cx.marked = "property";
        return cont(expect(":"), pattern, maybeAssign);
      }
      function maybeAssign(_type, value) {
        if (value == "=") return cont(expressionNoComma);
      }
      function vardefCont(type) {
        if (type == ",") return cont(vardef);
      }
      function maybeelse(type, value) {
        if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);
      }
      function forspec(type) {
        if (type == "(") return cont(pushlex(")"), forspec1, expect(")"));
      }
      function forspec1(type) {
        if (type == "var") return cont(vardef, expect(";"), forspec2);
        if (type == ";") return cont(forspec2);
        if (type == "variable") return cont(formaybeinof);
        return pass(expression, expect(";"), forspec2);
      }
      function formaybeinof(_type, value) {
        if (value == "in" || value == "of") {
          cx.marked = "keyword";return cont(expression);
        }
        return cont(maybeoperatorComma, forspec2);
      }
      function forspec2(type, value) {
        if (type == ";") return cont(forspec3);
        if (value == "in" || value == "of") {
          cx.marked = "keyword";return cont(expression);
        }
        return pass(expression, expect(";"), forspec3);
      }
      function forspec3(type) {
        if (type != ")") cont(expression);
      }
      function functiondef(type, value) {
        if (value == "*") {
          cx.marked = "keyword";return cont(functiondef);
        }
        if (type == "variable") {
          register(value);return cont(functiondef);
        }
        if (type == "(") return cont(pushcontext, commasep(funarg, ")"), statement, popcontext);
      }
      function funarg(type) {
        if (type == "spread") return cont(funarg);
        return pass(pattern, maybetype);
      }
      function className(type, value) {
        if (type == "variable") {
          register(value);return cont(classNameAfter);
        }
      }
      function classNameAfter(_type, value) {
        if (value == "extends") return cont(expression);
      }
      function objlit(type) {
        if (type == "{") return cont(commasep(objprop, "}"));
      }
      function afterModule(type, value) {
        if (type == "string") return cont(statement);
        if (type == "variable") {
          register(value);return cont(maybeFrom);
        }
      }
      function afterExport(_type, value) {
        if (value == "*") {
          cx.marked = "keyword";return cont(maybeFrom, expect(";"));
        }
        if (value == "default") {
          cx.marked = "keyword";return cont(expression, expect(";"));
        }
        return pass(statement);
      }
      function afterImport(type) {
        if (type == "string") return cont();
        return pass(importSpec, maybeFrom);
      }
      function importSpec(type, value) {
        if (type == "{") return cont(commasep(importSpec, "}"));
        if (type == "variable") register(value);
        return cont();
      }
      function maybeFrom(_type, value) {
        if (value == "from") {
          cx.marked = "keyword";return cont(expression);
        }
      }
      function maybeArrayComprehension(type) {
        if (type == "for") return pass(comprehension);
        if (type == ",") return cont(commasep(expressionNoComma, "]", false));
        return pass(commasep(expressionNoComma, "]", false));
      }
      function comprehension(type) {
        if (type == "for") return cont(forspec, comprehension);
        if (type == "if") return cont(expression, comprehension);
      }

      // Interface

      return {
        startState: function (basecolumn) {
          var state = {
            tokenize: tokenBase,
            lastType: "sof",
            cc: [],
            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            context: parserConfig.localVars && { vars: parserConfig.localVars },
            indented: 0
          };
          if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;
          return state;
        },

        token: function (stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;
            state.indented = stream.indentation();
            findFatArrow(stream, state);
          }
          if (state.tokenize != tokenComment && stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (type == "comment") return style;
          state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
          return parseJS(state, style, type, content, stream);
        },

        indent: function (state, textAfter) {
          if (state.tokenize == tokenComment) return CodeMirror.Pass;
          if (state.tokenize != tokenBase) return 0;
          var firstChar = textAfter && textAfter.charAt(0),
              lexical = state.lexical;
          // Kludge to prevent 'maybelse' from blocking lexical scope pops
          for (var i = state.cc.length - 1; i >= 0; --i) {
            var c = state.cc[i];
            if (c == poplex) lexical = lexical.prev;else if (c != maybeelse) break;
          }
          if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;
          var type = lexical.type,
              closing = firstChar == type;

          if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
        },

        electricChars: ":{}",
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        lineComment: jsonMode ? null : "//",
        fold: "brace",

        helperType: jsonMode ? "json" : "javascript",
        jsonMode: jsonMode
      };
    });

    CodeMirror.defineMIME("text/javascript", "javascript");
    CodeMirror.defineMIME("text/ecmascript", "javascript");
    CodeMirror.defineMIME("application/javascript", "javascript");
    CodeMirror.defineMIME("application/ecmascript", "javascript");
    CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
    CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
    CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
    CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("82", ["80"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    CodeMirror.defineMode("css", function (config, parserConfig) {
      "use strict";

      if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

      var indentUnit = config.indentUnit || config.tabSize || 2,
          hooks = parserConfig.hooks || {},
          atMediaTypes = parserConfig.atMediaTypes || {},
          atMediaFeatures = parserConfig.atMediaFeatures || {},
          propertyKeywords = parserConfig.propertyKeywords || {},
          colorKeywords = parserConfig.colorKeywords || {},
          valueKeywords = parserConfig.valueKeywords || {},
          allowNested = !!parserConfig.allowNested,
          type = null;

      function ret(style, tp) {
        type = tp;return style;
      }

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          // result[0] is style and result[1] is type
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == "@") {
          stream.eatWhile(/[\w\\\-]/);return ret("def", stream.current());
        } else if (ch == "=") ret(null, "compare");else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "#") {
          stream.eatWhile(/[\w\\\-]/);
          return ret("atom", "hash");
        } else if (ch == "!") {
          stream.match(/^\s*\w*/);
          return ret("keyword", "important");
        } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        } else if (ch === "-") {
          if (/\d/.test(stream.peek())) {
            stream.eatWhile(/[\w.%]/);
            return ret("number", "unit");
          } else if (stream.match(/^[^-]+-/)) {
            return ret("meta", "meta");
          }
        } else if (/[,+>*\/]/.test(ch)) {
          return ret(null, "select-op");
        } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
          return ret("qualifier", "qualifier");
        } else if (ch == ":") {
          return ret("operator", ch);
        } else if (/[;{}\[\]\(\)]/.test(ch)) {
          return ret(null, ch);
        } else if (ch == "u" && stream.match("rl(")) {
          stream.backUp(1);
          state.tokenize = tokenParenthesized;
          return ret("property", "variable");
        } else {
          stream.eatWhile(/[\w\\\-]/);
          return ret("property", "variable");
        }
      }

      function tokenString(quote, nonInclusive) {
        return function (stream, state) {
          var escaped = false,
              ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) break;
            escaped = !escaped && ch == "\\";
          }
          if (!escaped) {
            if (nonInclusive) stream.backUp(1);
            state.tokenize = tokenBase;
          }
          return ret("string", "string");
        };
      }

      function tokenParenthesized(stream, state) {
        stream.next(); // Must be '('
        if (!stream.match(/\s*[\"\']/, false)) state.tokenize = tokenString(")", true);else state.tokenize = tokenBase;
        return ret(null, "(");
      }

      return {
        startState: function (base) {
          return { tokenize: tokenBase,
            baseIndent: base || 0,
            stack: [],
            lastToken: null };
        },

        token: function (stream, state) {

          // Use these terms when applicable (see http://www.xanthir.com/blog/b4E50)
          //
          // rule** or **ruleset:
          // A selector + braces combo, or an at-rule.
          //
          // declaration block:
          // A sequence of declarations.
          //
          // declaration:
          // A property + colon + value combo.
          //
          // property value:
          // The entire value of a property.
          //
          // component value:
          // A single piece of a property value. Like the 5px in
          // text-shadow: 0 0 5px blue;. Can also refer to things that are
          // multiple terms, like the 1-4 terms that make up the background-size
          // portion of the background shorthand.
          //
          // term:
          // The basic unit of author-facing CSS, like a single number (5),
          // dimension (5px), string ("foo"), or function. Officially defined
          //  by the CSS 2.1 grammar (look for the 'term' production)
          //
          //
          // simple selector:
          // A single atomic selector, like a type selector, an attr selector, a
          // class selector, etc.
          //
          // compound selector:
          // One or more simple selectors without a combinator. div.example is
          // compound, div > .example is not.
          //
          // complex selector:
          // One or more compound selectors chained with combinators.
          //
          // combinator:
          // The parts of selectors that express relationships. There are four
          // currently - the space (descendant combinator), the greater-than
          // bracket (child combinator), the plus sign (next sibling combinator),
          // and the tilda (following sibling combinator).
          //
          // sequence of selectors:
          // One or more of the named type of selector chained with commas.

          state.tokenize = state.tokenize || tokenBase;
          if (state.tokenize == tokenBase && stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (style && typeof style != "string") style = ret(style[0], style[1]);

          // Changing style returned based on context
          var context = state.stack[state.stack.length - 1];
          if (style == "variable") {
            if (type == "variable-definition") state.stack.push("propertyValue");
            return state.lastToken = "variable-2";
          } else if (style == "property") {
            var word = stream.current().toLowerCase();
            if (context == "propertyValue") {
              if (valueKeywords.hasOwnProperty(word)) {
                style = "string-2";
              } else if (colorKeywords.hasOwnProperty(word)) {
                style = "keyword";
              } else {
                style = "variable-2";
              }
            } else if (context == "rule") {
              if (!propertyKeywords.hasOwnProperty(word)) {
                style += " error";
              }
            } else if (context == "block") {
              // if a value is present in both property, value, or color, the order
              // of preference is property -> color -> value
              if (propertyKeywords.hasOwnProperty(word)) {
                style = "property";
              } else if (colorKeywords.hasOwnProperty(word)) {
                style = "keyword";
              } else if (valueKeywords.hasOwnProperty(word)) {
                style = "string-2";
              } else {
                style = "tag";
              }
            } else if (!context || context == "@media{") {
              style = "tag";
            } else if (context == "@media") {
              if (atMediaTypes[stream.current()]) {
                style = "attribute"; // Known attribute
              } else if (/^(only|not)$/.test(word)) {
                style = "keyword";
              } else if (word == "and") {
                style = "error"; // "and" is only allowed in @mediaType
              } else if (atMediaFeatures.hasOwnProperty(word)) {
                style = "error"; // Known property, should be in @mediaType(
              } else {
                // Unknown, expecting keyword or attribute, assuming attribute
                style = "attribute error";
              }
            } else if (context == "@mediaType") {
              if (atMediaTypes.hasOwnProperty(word)) {
                style = "attribute";
              } else if (word == "and") {
                style = "operator";
              } else if (/^(only|not)$/.test(word)) {
                style = "error"; // Only allowed in @media
              } else {
                // Unknown attribute or property, but expecting property (preceded
                // by "and"). Should be in parentheses
                style = "error";
              }
            } else if (context == "@mediaType(") {
              if (propertyKeywords.hasOwnProperty(word)) {
                // do nothing, remains "property"
              } else if (atMediaTypes.hasOwnProperty(word)) {
                style = "error"; // Known property, should be in parentheses
              } else if (word == "and") {
                style = "operator";
              } else if (/^(only|not)$/.test(word)) {
                style = "error"; // Only allowed in @media
              } else {
                style += " error";
              }
            } else if (context == "@import") {
              style = "tag";
            } else {
              style = "error";
            }
          } else if (style == "atom") {
            if (!context || context == "@media{" || context == "block") {
              style = "builtin";
            } else if (context == "propertyValue") {
              if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
                style += " error";
              }
            } else {
              style = "error";
            }
          } else if (context == "@media" && type == "{") {
            style = "error";
          }

          // Push/pop context stack
          if (type == "{") {
            if (context == "@media" || context == "@mediaType") {
              state.stack[state.stack.length - 1] = "@media{";
            } else {
              var newContext = allowNested ? "block" : "rule";
              state.stack.push(newContext);
            }
          } else if (type == "}") {
            if (context == "interpolation") style = "operator";
            // Pop off end of array until { is reached
            while (state.stack.length) {
              var removed = state.stack.pop();
              if (removed.indexOf("{") > -1 || removed == "block" || removed == "rule") {
                break;
              }
            }
          } else if (type == "interpolation") state.stack.push("interpolation");else if (type == "@media") state.stack.push("@media");else if (type == "@import") state.stack.push("@import");else if (context == "@media" && /\b(keyword|attribute)\b/.test(style)) state.stack[state.stack.length - 1] = "@mediaType";else if (context == "@mediaType" && stream.current() == ",") state.stack[state.stack.length - 1] = "@media";else if (type == "(") {
            if (context == "@media" || context == "@mediaType") {
              // Make sure @mediaType is used to avoid error on {
              state.stack[state.stack.length - 1] = "@mediaType";
              state.stack.push("@mediaType(");
            } else state.stack.push("(");
          } else if (type == ")") {
            // Pop off end of array until ( is reached
            while (state.stack.length) {
              var removed = state.stack.pop();
              if (removed.indexOf("(") > -1) {
                break;
              }
            }
          } else if (type == ":" && state.lastToken == "property") state.stack.push("propertyValue");else if (context == "propertyValue" && type == ";") state.stack.pop();else if (context == "@import" && type == ";") state.stack.pop();

          return state.lastToken = style;
        },

        indent: function (state, textAfter) {
          var n = state.stack.length;
          if (/^\}/.test(textAfter)) n -= state.stack[n - 1] == "propertyValue" ? 2 : 1;
          return state.baseIndent + n * indentUnit;
        },

        electricChars: "}",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        fold: "brace"
      };
    });

    (function () {
      function keySet(array) {
        var keys = {};
        for (var i = 0; i < array.length; ++i) {
          keys[array[i]] = true;
        }
        return keys;
      }

      var atMediaTypes = keySet(["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"]);

      var atMediaFeatures = keySet(["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"]);

      var propertyKeywords = keySet(["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid-cell", "grid-column", "grid-column-align", "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow", "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span", "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index", "zoom",
      // SVG-specific
      "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"]);

      var colorKeywords = keySet(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]);

      var valueKeywords = keySet(["above", "absolute", "activeborder", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "single", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "x-large", "x-small", "xor", "xx-large", "xx-small"]);

      function tokenCComment(stream, state) {
        var maybeEnd = false,
            ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == "/") {
            state.tokenize = null;
            break;
          }
          maybeEnd = ch == "*";
        }
        return ["comment", "comment"];
      }

      CodeMirror.defineMIME("text/css", {
        atMediaTypes: atMediaTypes,
        atMediaFeatures: atMediaFeatures,
        propertyKeywords: propertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        hooks: {
          "<": function (stream, state) {
            function tokenSGMLComment(stream, state) {
              var dashes = 0,
                  ch;
              while ((ch = stream.next()) != null) {
                if (dashes >= 2 && ch == ">") {
                  state.tokenize = null;
                  break;
                }
                dashes = ch == "-" ? dashes + 1 : 0;
              }
              return ["comment", "comment"];
            }
            if (stream.eat("!")) {
              state.tokenize = tokenSGMLComment;
              return tokenSGMLComment(stream, state);
            }
          },
          "/": function (stream, state) {
            if (stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            }
            return false;
          }
        },
        name: "css"
      });

      CodeMirror.defineMIME("text/x-scss", {
        atMediaTypes: atMediaTypes,
        atMediaFeatures: atMediaFeatures,
        propertyKeywords: propertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        allowNested: true,
        hooks: {
          ":": function (stream) {
            if (stream.match(/\s*{/)) {
              return [null, "{"];
            }
            return false;
          },
          "$": function (stream) {
            stream.match(/^[\w-]+/);
            if (stream.peek() == ":") {
              return ["variable", "variable-definition"];
            }
            return ["variable", "variable"];
          },
          ",": function (stream, state) {
            if (state.stack[state.stack.length - 1] == "propertyValue" && stream.match(/^ *\$/, false)) {
              return ["operator", ";"];
            }
          },
          "/": function (stream, state) {
            if (stream.eat("/")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            } else if (stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            } else {
              return ["operator", "operator"];
            }
          },
          "#": function (stream) {
            if (stream.eat("{")) {
              return ["operator", "interpolation"];
            } else {
              stream.eatWhile(/[\w\\\-]/);
              return ["atom", "hash"];
            }
          }
        },
        name: "css"
      });
    })();
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("83", ["80"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
      var htmlMode = CodeMirror.getMode(config, { name: "xml", htmlMode: true });
      var cssMode = CodeMirror.getMode(config, "css");

      var scriptTypes = [],
          scriptTypesConf = parserConfig && parserConfig.scriptTypes;
      scriptTypes.push({ matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i,
        mode: CodeMirror.getMode(config, "javascript") });
      if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {
        var conf = scriptTypesConf[i];
        scriptTypes.push({ matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode) });
      }
      scriptTypes.push({ matches: /./,
        mode: CodeMirror.getMode(config, "text/plain") });

      function html(stream, state) {
        var tagName = state.htmlState.tagName;
        var style = htmlMode.token(stream, state.htmlState);
        if (tagName == "script" && /\btag\b/.test(style) && stream.current() == ">") {
          // Script block: mode to change to depends on type attribute
          var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i);
          scriptType = scriptType ? scriptType[1] : "";
          if (scriptType && /[\"\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);
          for (var i = 0; i < scriptTypes.length; ++i) {
            var tp = scriptTypes[i];
            if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {
              if (tp.mode) {
                state.token = script;
                state.localMode = tp.mode;
                state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));
              }
              break;
            }
          }
        } else if (tagName == "style" && /\btag\b/.test(style) && stream.current() == ">") {
          state.token = css;
          state.localMode = cssMode;
          state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));
        }
        return style;
      }
      function maybeBackup(stream, pat, style) {
        var cur = stream.current();
        var close = cur.search(pat),
            m;
        if (close > -1) stream.backUp(cur.length - close);else if (m = cur.match(/<\/?$/)) {
          stream.backUp(cur.length);
          if (!stream.match(pat, false)) stream.match(cur);
        }
        return style;
      }
      function script(stream, state) {
        if (stream.match(/^<\/\s*script\s*>/i, false)) {
          state.token = html;
          state.localState = state.localMode = null;
          return html(stream, state);
        }
        return maybeBackup(stream, /<\/\s*script\s*>/, state.localMode.token(stream, state.localState));
      }
      function css(stream, state) {
        if (stream.match(/^<\/\s*style\s*>/i, false)) {
          state.token = html;
          state.localState = state.localMode = null;
          return html(stream, state);
        }
        return maybeBackup(stream, /<\/\s*style\s*>/, cssMode.token(stream, state.localState));
      }

      return {
        startState: function () {
          var state = htmlMode.startState();
          return { token: html, localMode: null, localState: null, htmlState: state };
        },

        copyState: function (state) {
          if (state.localState) var local = CodeMirror.copyState(state.localMode, state.localState);
          return { token: state.token, localMode: state.localMode, localState: local,
            htmlState: CodeMirror.copyState(htmlMode, state.htmlState) };
        },

        token: function (stream, state) {
          return state.token(stream, state);
        },

        indent: function (state, textAfter) {
          if (!state.localMode || /^\s*<\//.test(textAfter)) return htmlMode.indent(state.htmlState, textAfter);else if (state.localMode.indent) return state.localMode.indent(state.localState, textAfter);else return CodeMirror.Pass;
        },

        electricChars: "/{}:",

        innerMode: function (state) {
          return { state: state.localState || state.htmlState, mode: state.localMode || htmlMode };
        }
      };
    }, "xml", "javascript", "css");

    CodeMirror.defineMIME("text/html", "htmlmixed");
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("80", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    // CodeMirror version 3.20
    //
    // CodeMirror is the only global var we claim
    window.CodeMirror = function () {
      "use strict";

      // BROWSER SNIFFING

      // Crude, but necessary to handle a number of hard-to-feature-detect
      // bugs and behavior differences.

      var gecko = /gecko\/\d/i.test(navigator.userAgent);
      // IE11 currently doesn't count as 'ie', since it has almost none of
      // the same bugs as earlier versions. Use ie_gt10 to handle
      // incompatibilities in that version.
      var ie = /MSIE \d/.test(navigator.userAgent);
      var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
      var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
      var ie_gt10 = /Trident\/([7-9]|\d{2,})\./.test(navigator.userAgent);
      var webkit = /WebKit\//.test(navigator.userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
      var chrome = /Chrome\//.test(navigator.userAgent);
      var opera = /Opera\//.test(navigator.userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var khtml = /KHTML\//.test(navigator.userAgent);
      var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
      var phantom = /PhantomJS/.test(navigator.userAgent);

      var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
      // This is woefully incomplete. Suggestions for alternative methods welcome.
      var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
      var mac = ios || /Mac/.test(navigator.platform);
      var windows = /win/i.test(navigator.platform);

      var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
      if (opera_version) opera_version = Number(opera_version[1]);
      if (opera_version && opera_version >= 15) {
        opera = false;webkit = true;
      }
      // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
      var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
      var captureMiddleClick = gecko || ie && !ie_lt9;

      // Optimize some code when these features are not used
      var sawReadOnlySpans = false,
          sawCollapsedSpans = false;

      // CONSTRUCTOR

      function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

        this.options = options = options || {};
        // Determine effective options based on given values and defaults.
        for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt)) options[opt] = defaults[opt];
        setGuttersForLineNumbers(options);

        var docStart = typeof options.value == "string" ? 0 : options.value.first;
        var display = this.display = makeDisplay(place, docStart);
        display.wrapper.CodeMirror = this;
        updateGutters(this);
        if (options.autofocus && !mobile) focusInput(this);

        this.state = { keyMaps: [],
          overlays: [],
          modeGen: 0,
          overwrite: false, focused: false,
          suppressEdits: false, pasteIncoming: false,
          draggingText: false,
          highlight: new Delayed() };

        themeChanged(this);
        if (options.lineWrapping) this.display.wrapper.className += " CodeMirror-wrap";

        var doc = options.value;
        if (typeof doc == "string") doc = new Doc(options.value, options.mode);
        operation(this, attachDoc)(this, doc);

        // Override magic textarea content restore that IE sometimes does
        // on our hidden textarea on reload
        if (ie) setTimeout(bind(resetInput, this, true), 20);

        registerEventHandlers(this);
        // IE throws unspecified error in certain cases, when
        // trying to access activeElement before onload
        var hasFocus;try {
          hasFocus = document.activeElement == display.input;
        } catch (e) {}
        if (hasFocus || options.autofocus && !mobile) setTimeout(bind(onFocus, this), 20);else onBlur(this);

        operation(this, function () {
          for (var opt in optionHandlers) if (optionHandlers.propertyIsEnumerable(opt)) optionHandlers[opt](this, options[opt], Init);
          for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
        })();
      }

      // DISPLAY CONSTRUCTOR

      function makeDisplay(place, docStart) {
        var d = {};

        var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");
        if (webkit) input.style.width = "1000px";else input.setAttribute("wrap", "off");
        // if border: 0; -- iOS fails to open keyboard (issue #1287)
        if (ios) input.style.border = "1px solid black";
        input.setAttribute("autocorrect", "off");input.setAttribute("autocapitalize", "off");input.setAttribute("spellcheck", "false");

        // Wraps and hides input textarea
        d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        // The actual fake scrollbars.
        d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");
        d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        // DIVs containing the selection and the actual code
        d.lineDiv = elt("div", null, "CodeMirror-code");
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        // Blinky cursor, and element used to ensure cursor fits at the end of a line
        d.cursor = elt("div", "\u00a0", "CodeMirror-cursor");
        // Secondary cursor, shown when on a 'jump' in bi-directional text
        d.otherCursor = elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");
        // Used to measure text size
        d.measure = elt("div", null, "CodeMirror-measure");
        // Wraps everything that needs to exist inside the vertically-padded coordinate system
        d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor], null, "position: relative; outline: none");
        // Moved around its parent to cover visible view
        d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
        // Set to the height of the text, causes scrolling
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
        // Will contain the gutters, if any
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        // Provides scrolling
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        // The element in which the editor lives.
        d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV, d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
        // Work around IE7 z-index bug
        if (ie_lt8) {
          d.gutters.style.zIndex = -1;d.scroller.style.paddingRight = 0;
        }
        if (place.appendChild) place.appendChild(d.wrapper);else place(d.wrapper);

        // Needed to hide big blue blinking cursor on Mobile Safari
        if (ios) input.style.width = "0px";
        if (!webkit) d.scroller.draggable = true;
        // Needed to handle Tab key in KHTML
        if (khtml) {
          d.inputDiv.style.height = "1px";d.inputDiv.style.position = "absolute";
        }
        // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
        else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";

        // Current visible range (may be bigger than the view window).
        d.viewOffset = d.lastSizeC = 0;
        d.showingFrom = d.showingTo = docStart;

        // Used to only resize the line number gutter when necessary (when
        // the amount of lines crosses a boundary that makes its width change)
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        // See readInput and resetInput
        d.prevInput = "";
        // Set to true when a non-horizontal-scrolling widget is added. As
        // an optimization, widget aligning is skipped when d is false.
        d.alignWidgets = false;
        // Flag that indicates whether we currently expect input to appear
        // (after some event like 'keypress' or 'input') and are polling
        // intensively.
        d.pollingFast = false;
        // Self-resetting timeout for the poller
        d.poll = new Delayed();

        d.cachedCharWidth = d.cachedTextHeight = null;
        d.measureLineCache = [];
        d.measureLineCachePos = 0;

        // Tracks when resetInput has punted to just putting a short
        // string instead of the (large) selection.
        d.inaccurateSelection = false;

        // Tracks the maximum line length so that the horizontal scrollbar
        // can be kept static when scrolling.
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;

        // Used for measuring wheel scrolling granularity
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

        return d;
      }

      // STATE UPDATES

      // Used to get the editor into a consistent state again when options change.

      function loadMode(cm) {
        cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
        cm.doc.iter(function (line) {
          if (line.stateAfter) line.stateAfter = null;
          if (line.styles) line.styles = null;
        });
        cm.doc.frontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp) regChange(cm);
      }

      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          cm.display.wrapper.className += " CodeMirror-wrap";
          cm.display.sizer.style.minWidth = "";
        } else {
          cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");
          computeMaxLength(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function () {
          updateScrollbars(cm);
        }, 100);
      }

      function estimateHeight(cm) {
        var th = textHeight(cm.display),
            wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
          if (lineIsHidden(cm.doc, line)) return 0;else if (wrapping) return (Math.ceil(line.text.length / perLine) || 1) * th;else return th;
        };
      }

      function estimateLineHeights(cm) {
        var doc = cm.doc,
            est = estimateHeight(cm);
        doc.iter(function (line) {
          var estHeight = est(line);
          if (estHeight != line.height) updateLineHeight(line, estHeight);
        });
      }

      function keyMapChanged(cm) {
        var map = keyMap[cm.options.keyMap],
            style = map.style;
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") + (style ? " cm-keymap-" + style : "");
        cm.state.disableInput = map.disableInput;
      }

      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }

      function guttersChanged(cm) {
        updateGutters(cm);
        regChange(cm);
        setTimeout(function () {
          alignHorizontally(cm);
        }, 20);
      }

      function updateGutters(cm) {
        var gutters = cm.display.gutters,
            specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
          var gutterClass = specs[i];
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
          if (gutterClass == "CodeMirror-linenumbers") {
            cm.display.lineGutter = gElt;
            gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = i ? "" : "none";
      }

      function lineLength(doc, line) {
        if (line.height == 0) return 0;
        var len = line.text.length,
            merged,
            cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find();
          cur = getLine(doc, found.from.line);
          len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found = merged.find();
          len -= cur.text.length - found.from.ch;
          cur = getLine(doc, found.to.line);
          len += cur.text.length - found.to.ch;
        }
        return len;
      }

      function computeMaxLength(cm) {
        var d = cm.display,
            doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(doc, d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function (line) {
          var len = lineLength(doc, line);
          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      }

      // Make sure the gutters options contains the element
      // "CodeMirror-linenumbers" when the lineNumbers option is true.
      function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        if (found == -1 && options.lineNumbers) {
          options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
        } else if (found > -1 && !options.lineNumbers) {
          options.gutters = options.gutters.slice(0);
          options.gutters.splice(found, 1);
        }
      }

      // SCROLLBARS

      // Re-synchronize the fake scrollbars with the actual size of the
      // content. Optionally force a scrollTop.
      function updateScrollbars(cm) {
        var d = cm.display,
            docHeight = cm.doc.height;
        var totalHeight = docHeight + paddingVert(d);
        d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";
        d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";
        var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
        var needsH = d.scroller.scrollWidth > d.scroller.clientWidth + 1;
        var needsV = scrollHeight > d.scroller.clientHeight + 1;
        if (needsV) {
          d.scrollbarV.style.display = "block";
          d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
          d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + "px";
        } else {
          d.scrollbarV.style.display = "";
          d.scrollbarV.firstChild.style.height = "0";
        }
        if (needsH) {
          d.scrollbarH.style.display = "block";
          d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
          d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + "px";
        } else {
          d.scrollbarH.style.display = "";
          d.scrollbarH.firstChild.style.width = "0";
        }
        if (needsH && needsV) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
        } else d.scrollbarFiller.style.display = "";
        if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";
          d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
        } else d.gutterFiller.style.display = "";

        if (mac_geLion && scrollbarWidth(d.measure) === 0) {
          d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";
          d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = "none";
        }
      }

      function visibleLines(display, doc, viewPort) {
        var top = display.scroller.scrollTop,
            height = display.wrapper.clientHeight;
        if (typeof viewPort == "number") top = viewPort;else if (viewPort) {
          top = viewPort.top;height = viewPort.bottom - viewPort.top;
        }
        top = Math.floor(top - paddingTop(display));
        var bottom = Math.ceil(top + height);
        return { from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom) };
      }

      // LINE NUMBERS

      function alignHorizontally(cm) {
        var display = cm.display;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth,
            l = comp + "px";
        for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {
          for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;
        }
        if (cm.options.fixedGutter) display.gutters.style.left = comp + gutterW + "px";
      }

      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) return false;
        var doc = cm.doc,
            last = lineNumberFor(cm.options, doc.first + doc.size - 1),
            display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth,
              padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          return true;
        }
        return false;
      }

      function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
      }
      function compensateForHScroll(display) {
        return getRect(display.scroller).left - getRect(display.sizer).left;
      }

      // DISPLAY DRAWING

      function updateDisplay(cm, changes, viewPort, forced) {
        var oldFrom = cm.display.showingFrom,
            oldTo = cm.display.showingTo,
            updated;
        var visible = visibleLines(cm.display, cm.doc, viewPort);
        for (var first = true;; first = false) {
          var oldWidth = cm.display.scroller.clientWidth;
          if (!updateDisplayInner(cm, changes, visible, forced)) break;
          updated = true;
          changes = [];
          updateSelection(cm);
          updateScrollbars(cm);
          if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {
            forced = true;
            continue;
          }
          forced = false;

          // Clip forced viewport to actual scrollable area
          if (viewPort) viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == "number" ? viewPort : viewPort.top);
          visible = visibleLines(cm.display, cm.doc, viewPort);
          if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo) break;
        }

        if (updated) {
          signalLater(cm, "update", cm);
          if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo) signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);
        }
        return updated;
      }

      // Uses a set of changes plus the current scroll position to
      // determine which DOM updates have to be made, and makes the
      // updates.
      function updateDisplayInner(cm, changes, visible, forced) {
        var display = cm.display,
            doc = cm.doc;
        if (!display.wrapper.clientWidth) {
          display.showingFrom = display.showingTo = doc.first;
          display.viewOffset = 0;
          return;
        }

        // Bail out if the visible area is already rendered and nothing changed.
        if (!forced && changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo) return;

        if (maybeUpdateLineNumberWidth(cm)) changes = [{ from: doc.first, to: doc.first + doc.size }];
        var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";
        display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";

        // Used to determine which lines need their line numbers updated
        var positionsChangedFrom = Infinity;
        if (cm.options.lineNumbers) for (var i = 0; i < changes.length; ++i) if (changes[i].diff && changes[i].from < positionsChangedFrom) {
          positionsChangedFrom = changes[i].from;
        }

        var end = doc.first + doc.size;
        var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, visible.to + cm.options.viewportMargin);
        if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);
        if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);
        if (sawCollapsedSpans) {
          from = lineNo(visualLine(doc, getLine(doc, from)));
          while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;
        }

        // Create a range of theoretically intact lines, and punch holes
        // in that using the change info.
        var intact = [{ from: Math.max(display.showingFrom, doc.first),
          to: Math.min(display.showingTo, end) }];
        if (intact[0].from >= intact[0].to) intact = [];else intact = computeIntact(intact, changes);
        // When merged lines are present, we might have to reduce the
        // intact ranges because changes in continued fragments of the
        // intact lines do require the lines to be redrawn.
        if (sawCollapsedSpans) for (var i = 0; i < intact.length; ++i) {
          var range = intact[i],
              merged;
          while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
            var newTo = merged.find().from.line;
            if (newTo > range.from) range.to = newTo;else {
              intact.splice(i--, 1);break;
            }
          }
        }

        // Clip off the parts that won't be visible
        var intactLines = 0;
        for (var i = 0; i < intact.length; ++i) {
          var range = intact[i];
          if (range.from < from) range.from = from;
          if (range.to > to) range.to = to;
          if (range.from >= range.to) intact.splice(i--, 1);else intactLines += range.to - range.from;
        }
        if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
          updateViewOffset(cm);
          return;
        }
        intact.sort(function (a, b) {
          return a.from - b.from;
        });

        // Avoid crashing on IE's "unspecified error" when in iframes
        try {
          var focused = document.activeElement;
        } catch (e) {}
        if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";
        patchDisplay(cm, from, to, intact, positionsChangedFrom);
        display.lineDiv.style.display = "";
        if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();

        var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
        // This is just a bogus formula that detects when the editor is
        // resized or the font size changes.
        if (different) {
          display.lastSizeC = display.wrapper.clientHeight;
          startWorker(cm, 400);
        }
        display.showingFrom = from;display.showingTo = to;

        updateHeightsInViewport(cm);
        updateViewOffset(cm);

        return true;
      }

      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {
          if (ie_lt8) {
            var bot = node.offsetTop + node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = getRect(node);
            height = box.bottom - box.top;
          }
          var diff = node.lineObj.height - height;
          if (height < 2) height = textHeight(display);
          if (diff > .001 || diff < -.001) {
            updateLineHeight(node.lineObj, height);
            var widgets = node.lineObj.widgets;
            if (widgets) for (var i = 0; i < widgets.length; ++i) widgets[i].height = widgets[i].node.offsetHeight;
          }
        }
      }

      function updateViewOffset(cm) {
        var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
        // Position the mover div to align with the current virtual scroll position
        cm.display.mover.style.top = off + "px";
      }

      function computeIntact(intact, changes) {
        for (var i = 0, l = changes.length || 0; i < l; ++i) {
          var change = changes[i],
              intact2 = [],
              diff = change.diff || 0;
          for (var j = 0, l2 = intact.length; j < l2; ++j) {
            var range = intact[j];
            if (change.to <= range.from && change.diff) {
              intact2.push({ from: range.from + diff, to: range.to + diff });
            } else if (change.to <= range.from || change.from >= range.to) {
              intact2.push(range);
            } else {
              if (change.from > range.from) intact2.push({ from: range.from, to: change.from });
              if (change.to < range.to) intact2.push({ from: change.to + diff, to: range.to + diff });
            }
          }
          intact = intact2;
        }
        return intact;
      }

      function getDimensions(cm) {
        var d = cm.display,
            left = {},
            width = {};
        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
          left[cm.options.gutters[i]] = n.offsetLeft;
          width[cm.options.gutters[i]] = n.offsetWidth;
        }
        return { fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth };
      }

      function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
        var dims = getDimensions(cm);
        var display = cm.display,
            lineNumbers = cm.options.lineNumbers;
        if (!intact.length && (!webkit || !cm.display.currentWheelTarget)) removeChildren(display.lineDiv);
        var container = display.lineDiv,
            cur = container.firstChild;

        function rm(node) {
          var next = node.nextSibling;
          if (webkit && mac && cm.display.currentWheelTarget == node) {
            node.style.display = "none";
            node.lineObj = null;
          } else {
            node.parentNode.removeChild(node);
          }
          return next;
        }

        var nextIntact = intact.shift(),
            lineN = from;
        cm.doc.iter(from, to, function (line) {
          if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();
          if (lineIsHidden(cm.doc, line)) {
            if (line.height != 0) updateLineHeight(line, 0);
            if (line.widgets && cur && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {
              var w = line.widgets[i];
              if (w.showIfHidden) {
                var prev = cur.previousSibling;
                if (/pre/i.test(prev.nodeName)) {
                  var wrap = elt("div", null, null, "position: relative");
                  prev.parentNode.replaceChild(wrap, prev);
                  wrap.appendChild(prev);
                  prev = wrap;
                }
                var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));
                if (!w.handleMouseEvents) wnode.ignoreEvents = true;
                positionLineWidget(w, wnode, prev, dims);
              }
            }
          } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
            // This line is intact. Skip to the actual node. Update its
            // line number if needed.
            while (cur.lineObj != line) cur = rm(cur);
            if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber) setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
            cur = cur.nextSibling;
          } else {
            // For lines with widgets, make an attempt to find and reuse
            // the existing element, so that widgets aren't needlessly
            // removed and re-inserted into the dom
            if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling) if (search.lineObj == line && /div/i.test(search.nodeName)) {
              reuse = search;break;
            }
            // This line needs to be generated.
            var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
            if (lineNode != reuse) {
              container.insertBefore(lineNode, cur);
            } else {
              while (cur != reuse) cur = rm(cur);
              cur = cur.nextSibling;
            }

            lineNode.lineObj = line;
          }
          ++lineN;
        });
        while (cur) cur = rm(cur);
      }

      function buildLineElement(cm, line, lineNo, dims, reuse) {
        var built = buildLineContent(cm, line),
            lineElement = built.pre;
        var markers = line.gutterMarkers,
            display = cm.display,
            wrap;

        var bgClass = built.bgClass ? built.bgClass + " " + (line.bgClass || "") : line.bgClass;
        if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets) return lineElement;

        // Lines with gutter elements, widgets or a background class need
        // to be wrapped again, and have the extra elements added to the
        // wrapper div

        if (reuse) {
          reuse.alignable = null;
          var isOk = true,
              widgetsSeen = 0,
              insertBefore = null;
          for (var n = reuse.firstChild, next; n; n = next) {
            next = n.nextSibling;
            if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
              reuse.removeChild(n);
            } else {
              for (var i = 0; i < line.widgets.length; ++i) {
                var widget = line.widgets[i];
                if (widget.node == n.firstChild) {
                  if (!widget.above && !insertBefore) insertBefore = n;
                  positionLineWidget(widget, n, reuse, dims);
                  ++widgetsSeen;
                  break;
                }
              }
              if (i == line.widgets.length) {
                isOk = false;break;
              }
            }
          }
          reuse.insertBefore(lineElement, insertBefore);
          if (isOk && widgetsSeen == line.widgets.length) {
            wrap = reuse;
            reuse.className = line.wrapClass || "";
          }
        }
        if (!wrap) {
          wrap = elt("div", null, line.wrapClass, "position: relative");
          wrap.appendChild(lineElement);
        }
        // Kludge to make sure the styled element lies behind the selection (by z-index)
        if (bgClass) wrap.insertBefore(elt("div", null, bgClass + " CodeMirror-linebackground"), wrap.firstChild);
        if (cm.options.lineNumbers || markers) {
          var gutterWrap = wrap.insertBefore(elt("div", null, null, "position: absolute; left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"), wrap.firstChild);
          if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) wrap.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineNo), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + display.lineNumInnerWidth + "px"));
          if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
            var id = cm.options.gutters[k],
                found = markers.hasOwnProperty(id) && markers[id];
            if (found) gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
          }
        }
        if (ie_lt8) wrap.style.zIndex = 2;
        if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
          var widget = ws[i],
              node = elt("div", [widget.node], "CodeMirror-linewidget");
          if (!widget.handleMouseEvents) node.ignoreEvents = true;
          positionLineWidget(widget, node, wrap, dims);
          if (widget.above) wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);else wrap.appendChild(node);
          signalLater(widget, "redraw");
        }
        return wrap;
      }

      function positionLineWidget(widget, node, wrap, dims) {
        if (widget.noHScroll) {
          (wrap.alignable || (wrap.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }

      // SELECTION / CURSOR

      function updateSelection(cm) {
        var display = cm.display;
        var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
        if (collapsed || cm.options.showCursorWhenSelecting) updateSelectionCursor(cm);else display.cursor.style.display = display.otherCursor.style.display = "none";
        if (!collapsed) updateSelectionRange(cm);else display.selectionDiv.style.display = "none";

        // Move the hidden textarea near the cursor to prevent scrolling artifacts
        if (cm.options.moveInputWithCursor) {
          var headPos = cursorCoords(cm, cm.doc.sel.head, "div");
          var wrapOff = getRect(display.wrapper),
              lineOff = getRect(display.lineDiv);
          display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + "px";
          display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + "px";
        }
      }

      // No selection, plain cursor
      function updateSelectionCursor(cm) {
        var display = cm.display,
            pos = cursorCoords(cm, cm.doc.sel.head, "div");
        display.cursor.style.left = pos.left + "px";
        display.cursor.style.top = pos.top + "px";
        display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        display.cursor.style.display = "";

        if (pos.other) {
          display.otherCursor.style.display = "";
          display.otherCursor.style.left = pos.other.left + "px";
          display.otherCursor.style.top = pos.other.top + "px";
          display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
        } else {
          display.otherCursor.style.display = "none";
        }
      }

      // Highlight selection
      function updateSelectionRange(cm) {
        var display = cm.display,
            doc = cm.doc,
            sel = cm.doc.sel;
        var fragment = document.createDocumentFragment();
        var clientWidth = display.lineSpace.offsetWidth,
            pl = paddingLeft(cm.display);

        function add(left, top, width, bottom) {
          if (top < 0) top = 0;
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) + "px; height: " + (bottom - top) + "px"));
        }

        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start, end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }

          iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
            var leftPos = coords(from, "left"),
                rightPos,
                left,
                right;
            if (from == to) {
              rightPos = leftPos;
              left = right = leftPos.left;
            } else {
              rightPos = coords(to - 1, "right");
              if (dir == "rtl") {
                var tmp = leftPos;leftPos = rightPos;rightPos = tmp;
              }
              left = leftPos.left;
              right = rightPos.right;
            }
            if (fromArg == null && from == 0) left = pl;
            if (rightPos.top - leftPos.top > 3) {
              // Different lines, draw top part
              add(left, leftPos.top, null, leftPos.bottom);
              left = pl;
              if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
            }
            if (toArg == null && to == lineLen) right = clientWidth;
            if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) start = leftPos;
            if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) end = rightPos;
            if (left < pl + 1) left = pl;
            add(left, rightPos.top, right - left, rightPos.bottom);
          });
          return { start: start, end: end };
        }

        if (sel.from.line == sel.to.line) {
          drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
        } else {
          var fromLine = getLine(doc, sel.from.line),
              toLine = getLine(doc, sel.to.line);
          var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);
          var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;
          var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(pl, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top) add(pl, leftEnd.bottom, null, rightStart.top);
        }

        removeChildrenAndAdd(display.selectionDiv, fragment);
        display.selectionDiv.style.display = "";
      }

      // Cursor-blinking
      function restartBlink(cm) {
        if (!cm.state.focused) return;
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursor.style.visibility = display.otherCursor.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0) display.blinker = setInterval(function () {
          display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";
        }, cm.options.cursorBlinkRate);
      }

      // HIGHLIGHT WORKER

      function startWorker(cm, time) {
        if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo) cm.state.highlight.set(time, bind(highlightWorker, cm));
      }

      function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first) doc.frontier = doc.first;
        if (doc.frontier >= cm.display.showingTo) return;
        var end = +new Date() + cm.options.workTime;
        var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
        var changed = [],
            prevChange;
        doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
          if (doc.frontier >= cm.display.showingFrom) {
            // Visible
            var oldStyles = line.styles;
            line.styles = highlightLine(cm, line, state, true);
            var ischange = !oldStyles || oldStyles.length != line.styles.length;
            for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
            if (ischange) {
              if (prevChange && prevChange.end == doc.frontier) prevChange.end++;else changed.push(prevChange = { start: doc.frontier, end: doc.frontier + 1 });
            }
            line.stateAfter = copyState(doc.mode, state);
          } else {
            processLine(cm, line.text, state);
            line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
          }
          ++doc.frontier;
          if (+new Date() > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        if (changed.length) operation(cm, function () {
          for (var i = 0; i < changed.length; ++i) regChange(this, changed[i].start, changed[i].end);
        })();
      }

      // Finds the line to start with when starting a parse. Tries to
      // find a line with a stateAfter, so that it can start with a
      // valid state. If that fails, it returns the line with the
      // smallest indentation, which tends to need the least context to
      // parse correctly.
      function findStartLine(cm, n, precise) {
        var minindent,
            minline,
            doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (var search = n; search > lim; --search) {
          if (search <= doc.first) return doc.first;
          var line = getLine(doc, search - 1);
          if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline;
      }

      function getStateBefore(cm, n, precise) {
        var doc = cm.doc,
            display = cm.display;
        if (!doc.mode.startState) return true;
        var pos = findStartLine(cm, n, precise),
            state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        if (!state) state = startState(doc.mode);else state = copyState(doc.mode, state);
        doc.iter(pos, n, function (line) {
          processLine(cm, line.text, state);
          var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
          line.stateAfter = save ? copyState(doc.mode, state) : null;
          ++pos;
        });
        if (precise) doc.frontier = pos;
        return state;
      }

      // POSITION MEASUREMENT

      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }
      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }
      function paddingLeft(display) {
        var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));
        return e.offsetLeft;
      }

      function measureChar(cm, line, ch, data, bias) {
        var dir = -1;
        data = data || measureLine(cm, line);
        if (data.crude) {
          var left = data.left + ch * data.width;
          return { left: left, right: left + data.width, top: data.top, bottom: data.bottom };
        }

        for (var pos = ch;; pos += dir) {
          var r = data[pos];
          if (r) break;
          if (dir < 0 && pos == 0) dir = 1;
        }
        bias = pos > ch ? "left" : pos < ch ? "right" : bias;
        if (bias == "left" && r.leftSide) r = r.leftSide;else if (bias == "right" && r.rightSide) r = r.rightSide;
        return { left: pos < ch ? r.right : r.left,
          right: pos > ch ? r.left : r.right,
          top: r.top,
          bottom: r.bottom };
      }

      function findCachedMeasurement(cm, line) {
        var cache = cm.display.measureLineCache;
        for (var i = 0; i < cache.length; ++i) {
          var memo = cache[i];
          if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + "|" + line.wrapClass) return memo;
        }
      }

      function clearCachedMeasurement(cm, line) {
        var exists = findCachedMeasurement(cm, line);
        if (exists) exists.text = exists.measure = exists.markedSpans = null;
      }

      function measureLine(cm, line) {
        // First look in the cache
        var cached = findCachedMeasurement(cm, line);
        if (cached) return cached.measure;

        // Failing that, recompute and store result in cache
        var measure = measureLineInner(cm, line);
        var cache = cm.display.measureLineCache;
        var memo = { text: line.text, width: cm.display.scroller.clientWidth,
          markedSpans: line.markedSpans, measure: measure,
          classes: line.textClass + "|" + line.wrapClass };
        if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;else cache.push(memo);
        return measure;
      }

      function measureLineInner(cm, line) {
        if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom) return crudelyMeasureLine(cm, line);

        var display = cm.display,
            measure = emptyArray(line.text.length);
        var pre = buildLineContent(cm, line, measure, true).pre;

        // IE does not cache element positions of inline elements between
        // calls to getBoundingClientRect. This makes the loop below,
        // which gathers the positions of all the characters on the line,
        // do an amount of layout work quadratic to the number of
        // characters. When line wrapping is off, we try to improve things
        // by first subdividing the line into a bunch of inline blocks, so
        // that IE can reuse most of the layout information from caches
        // for those blocks. This does interfere with line wrapping, so it
        // doesn't work when wrapping is on, but in that case the
        // situation is slightly better, since IE does cache line-wrapping
        // information and only recomputes per-line.
        if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
          var fragment = document.createDocumentFragment();
          var chunk = 10,
              n = pre.childNodes.length;
          for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
            var wrap = elt("div", null, null, "display: inline-block");
            for (var j = 0; j < chunk && n; ++j) {
              wrap.appendChild(pre.firstChild);
              --n;
            }
            fragment.appendChild(wrap);
          }
          pre.appendChild(fragment);
        }

        removeChildrenAndAdd(display.measure, pre);

        var outer = getRect(display.lineDiv);
        var vranges = [],
            data = emptyArray(line.text.length),
            maxBot = pre.offsetHeight;
        // Work around an IE7/8 bug where it will sometimes have randomly
        // replaced our pre with a clone at this point.
        if (ie_lt9 && display.measure.first != pre) removeChildrenAndAdd(display.measure, pre);

        function measureRect(rect) {
          var top = rect.top - outer.top,
              bot = rect.bottom - outer.top;
          if (bot > maxBot) bot = maxBot;
          if (top < 0) top = 0;
          for (var i = vranges.length - 2; i >= 0; i -= 2) {
            var rtop = vranges[i],
                rbot = vranges[i + 1];
            if (rtop > bot || rbot < top) continue;
            if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
              vranges[i] = Math.min(top, rtop);
              vranges[i + 1] = Math.max(bot, rbot);
              break;
            }
          }
          if (i < 0) {
            i = vranges.length;vranges.push(top, bot);
          }
          return { left: rect.left - outer.left,
            right: rect.right - outer.left,
            top: i, bottom: null };
        }
        function finishRect(rect) {
          rect.bottom = vranges[rect.top + 1];
          rect.top = vranges[rect.top];
        }

        for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {
          var node = cur,
              rect = null;
          // A widget might wrap, needs special care
          if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
            if (cur.firstChild.nodeType == 1) node = cur.firstChild;
            var rects = node.getClientRects();
            if (rects.length > 1) {
              rect = data[i] = measureRect(rects[0]);
              rect.rightSide = measureRect(rects[rects.length - 1]);
            }
          }
          if (!rect) rect = data[i] = measureRect(getRect(node));
          if (cur.measureRight) rect.right = getRect(cur.measureRight).left;
          if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));
        }
        removeChildren(cm.display.measure);
        for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {
          finishRect(cur);
          if (cur.leftSide) finishRect(cur.leftSide);
          if (cur.rightSide) finishRect(cur.rightSide);
        }
        return data;
      }

      function crudelyMeasureLine(cm, line) {
        var copy = new Line(line.text.slice(0, 100), null);
        if (line.textClass) copy.textClass = line.textClass;
        var measure = measureLineInner(cm, copy);
        var left = measureChar(cm, copy, 0, measure, "left");
        var right = measureChar(cm, copy, 99, measure, "right");
        return { crude: true, top: left.top, left: left.left, bottom: left.bottom, width: (right.right - left.left) / 100 };
      }

      function measureLineWidth(cm, line) {
        var hasBadSpan = false;
        if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {
          var sp = line.markedSpans[i];
          if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;
        }
        var cached = !hasBadSpan && findCachedMeasurement(cm, line);
        if (cached || line.text.length >= cm.options.crudeMeasuringFrom) return measureChar(cm, line, line.text.length, cached && cached.measure, "right").right;

        var pre = buildLineContent(cm, line, null, true).pre;
        var end = pre.appendChild(zeroWidthElement(cm.display.measure));
        removeChildrenAndAdd(cm.display.measure, pre);
        return getRect(end).right - getRect(cm.display.lineDiv).left;
      }

      function clearCaches(cm) {
        cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
        if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
        cm.display.lineNumChars = null;
      }

      function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      }
      function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
      }

      // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"
      function intoCoordSystem(cm, lineObj, rect, context) {
        if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;rect.bottom += size;
        }
        if (context == "line") return rect;
        if (!context) context = "local";
        var yOff = heightAtLine(cm, lineObj);
        if (context == "local") yOff += paddingTop(cm.display);else yOff -= cm.display.viewOffset;
        if (context == "page" || context == "window") {
          var lOff = getRect(cm.display.lineSpace);
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff;rect.right += xOff;
        }
        rect.top += yOff;rect.bottom += yOff;
        return rect;
      }

      // Context may be "window", "page", "div", or "local"/null
      // Result is in "div" coords
      function fromCoordSystem(cm, coords, context) {
        if (context == "div") return coords;
        var left = coords.left,
            top = coords.top;
        // First move into "page" coordinate system
        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = getRect(cm.display.sizer);
          left += localBox.left;
          top += localBox.top;
        }

        var lineSpaceBox = getRect(cm.display.lineSpace);
        return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
      }

      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) lineObj = getLine(cm.doc, pos.line);
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);
      }

      function cursorCoords(cm, pos, context, lineObj, measurement) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!measurement) measurement = measureLine(cm, lineObj);
        function get(ch, right) {
          var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");
          if (right) m.left = m.right;else m.right = m.left;
          return intoCoordSystem(cm, lineObj, m, context);
        }
        function getBidi(ch, partPos) {
          var part = order[partPos],
              right = part.level % 2;
          if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
            part = order[--partPos];
            ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
            right = true;
          } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
            part = order[++partPos];
            ch = bidiLeft(part) - part.level % 2;
            right = false;
          }
          if (right && ch == part.to && ch > part.from) return get(ch - 1);
          return get(ch, right);
        }
        var order = getOrder(lineObj),
            ch = pos.ch;
        if (!order) return get(ch);
        var partPos = getBidiPartAt(order, ch);
        var val = getBidi(ch, partPos);
        if (bidiOther != null) val.other = getBidi(ch, bidiOther);
        return val;
      }

      function PosWithInfo(line, ch, outside, xRel) {
        var pos = new Pos(line, ch);
        pos.xRel = xRel;
        if (outside) pos.outside = true;
        return pos;
      }

      // Coords must be lineSpace-local
      function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
        var lineNo = lineAtHeight(doc, y),
            last = doc.first + doc.size - 1;
        if (lineNo > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
        if (x < 0) x = 0;

        for (;;) {
          var lineObj = getLine(doc, lineNo);
          var found = coordsCharInner(cm, lineObj, lineNo, x, y);
          var merged = collapsedSpanAtEnd(lineObj);
          var mergedPos = merged && merged.find();
          if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) lineNo = mergedPos.to.line;else return found;
        }
      }

      function coordsCharInner(cm, lineObj, lineNo, x, y) {
        var innerOff = y - heightAtLine(cm, lineObj);
        var wrongLine = false,
            adjust = 2 * cm.display.wrapper.clientWidth;
        var measurement = measureLine(cm, lineObj);

        function getX(ch) {
          var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, measurement);
          wrongLine = true;
          if (innerOff > sp.bottom) return sp.left - adjust;else if (innerOff < sp.top) return sp.left + adjust;else wrongLine = false;
          return sp.left;
        }

        var bidi = getOrder(lineObj),
            dist = lineObj.text.length;
        var from = lineLeft(lineObj),
            to = lineRight(lineObj);
        var fromX = getX(from),
            fromOutside = wrongLine,
            toX = getX(to),
            toOutside = wrongLine;

        if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
        // Do a binary search between these bounds.
        for (;;) {
          if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
            var ch = x < fromX || x - fromX <= toX - x ? from : to;
            var xDiff = x - (ch == from ? fromX : toX);
            while (isExtendingChar.test(lineObj.text.charAt(ch))) ++ch;
            var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < 0 ? -1 : xDiff ? 1 : 0);
            return pos;
          }
          var step = Math.ceil(dist / 2),
              middle = from + step;
          if (bidi) {
            middle = from;
            for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
          }
          var middleX = getX(middle);
          if (middleX > x) {
            to = middle;toX = middleX;if (toOutside = wrongLine) toX += 1000;dist = step;
          } else {
            from = middle;fromX = middleX;fromOutside = wrongLine;dist -= step;
          }
        }
      }

      var measureText;
      function textHeight(display) {
        if (display.cachedTextHeight != null) return display.cachedTextHeight;
        if (measureText == null) {
          measureText = elt("pre");
          // Measure a bunch of lines, for browsers that compute
          // fractional heights.
          for (var i = 0; i < 49; ++i) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3) display.cachedTextHeight = height;
        removeChildren(display.measure);
        return height || 1;
      }

      function charWidth(display) {
        if (display.cachedCharWidth != null) return display.cachedCharWidth;
        var anchor = elt("span", "x");
        var pre = elt("pre", [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var width = anchor.offsetWidth;
        if (width > 2) display.cachedCharWidth = width;
        return width || 10;
      }

      // OPERATIONS

      // Operations are used to wrap changes in such a way that each
      // change won't have to update the cursor and display (which would
      // be awkward, slow, and error-prone), but instead updates are
      // batched and then all combined and executed at once.

      var nextOpId = 0;
      function startOperation(cm) {
        cm.curOp = {
          // An array of ranges of lines that have to be updated. See
          // updateDisplay.
          changes: [],
          forceUpdate: false,
          updateInput: null,
          userSelChange: null,
          textChanged: null,
          selectionChanged: false,
          cursorActivity: false,
          updateMaxLine: false,
          updateScrollPos: false,
          id: ++nextOpId
        };
        if (!delayedCallbackDepth++) delayedCallbacks = [];
      }

      function endOperation(cm) {
        var op = cm.curOp,
            doc = cm.doc,
            display = cm.display;
        cm.curOp = null;

        if (op.updateMaxLine) computeMaxLength(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
          var width = measureLineWidth(cm, display.maxLine);
          display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";
          display.maxLineChanged = false;
          var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
          if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos) setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
        }
        var newScrollPos, updated;
        if (op.updateScrollPos) {
          newScrollPos = op.updateScrollPos;
        } else if (op.selectionChanged && display.scroller.clientHeight) {
          // don't rescroll if not visible
          var coords = cursorCoords(cm, doc.sel.head);
          newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
        }
        if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {
          updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);
          if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;
        }
        if (!updated && op.selectionChanged) updateSelection(cm);
        if (op.updateScrollPos) {
          var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, newScrollPos.scrollTop));
          var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, newScrollPos.scrollLeft));
          display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;
          display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;
          alignHorizontally(cm);
          if (op.scrollToPos) scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from), clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);
        } else if (newScrollPos) {
          scrollCursorIntoView(cm);
        }
        if (op.selectionChanged) restartBlink(cm);

        if (cm.state.focused && op.updateInput) resetInput(cm, op.userSelChange);

        var hidden = op.maybeHiddenMarkers,
            unhidden = op.maybeUnhiddenMarkers;
        if (hidden) for (var i = 0; i < hidden.length; ++i) if (!hidden[i].lines.length) signal(hidden[i], "hide");
        if (unhidden) for (var i = 0; i < unhidden.length; ++i) if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

        var delayed;
        if (! --delayedCallbackDepth) {
          delayed = delayedCallbacks;
          delayedCallbacks = null;
        }
        if (op.textChanged) signal(cm, "change", cm, op.textChanged);
        if (op.cursorActivity) signal(cm, "cursorActivity", cm);
        if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
      }

      // Wraps a function in an operation. Returns the wrapped function.
      function operation(cm1, f) {
        return function () {
          var cm = cm1 || this,
              withOp = !cm.curOp;
          if (withOp) startOperation(cm);
          try {
            var result = f.apply(cm, arguments);
          } finally {
            if (withOp) endOperation(cm);
          }
          return result;
        };
      }
      function docOperation(f) {
        return function () {
          var withOp = this.cm && !this.cm.curOp,
              result;
          if (withOp) startOperation(this.cm);
          try {
            result = f.apply(this, arguments);
          } finally {
            if (withOp) endOperation(this.cm);
          }
          return result;
        };
      }
      function runInOp(cm, f) {
        var withOp = !cm.curOp,
            result;
        if (withOp) startOperation(cm);
        try {
          result = f();
        } finally {
          if (withOp) endOperation(cm);
        }
        return result;
      }

      function regChange(cm, from, to, lendiff) {
        if (from == null) from = cm.doc.first;
        if (to == null) to = cm.doc.first + cm.doc.size;
        cm.curOp.changes.push({ from: from, to: to, diff: lendiff });
      }

      // INPUT HANDLING

      function slowPoll(cm) {
        if (cm.display.pollingFast) return;
        cm.display.poll.set(cm.options.pollInterval, function () {
          readInput(cm);
          if (cm.state.focused) slowPoll(cm);
        });
      }

      function fastPoll(cm) {
        var missed = false;
        cm.display.pollingFast = true;
        function p() {
          var changed = readInput(cm);
          if (!changed && !missed) {
            missed = true;cm.display.poll.set(60, p);
          } else {
            cm.display.pollingFast = false;slowPoll(cm);
          }
        }
        cm.display.poll.set(20, p);
      }

      // prevInput is a hack to work with IME. If we reset the textarea
      // on every change, that breaks IME. So we look for changes
      // compared to the previous content instead. (Modern browsers have
      // events that indicate IME taking place, but these are not widely
      // supported or compatible enough yet to rely on.)
      function readInput(cm) {
        var input = cm.display.input,
            prevInput = cm.display.prevInput,
            doc = cm.doc,
            sel = doc.sel;
        if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput) return false;
        if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
          input.value = input.value.substring(0, input.value.length - 1);
          cm.state.fakedLastChar = false;
        }
        var text = input.value;
        if (text == prevInput && posEq(sel.from, sel.to)) return false;
        if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
          resetInput(cm, true);
          return false;
        }

        var withOp = !cm.curOp;
        if (withOp) startOperation(cm);
        sel.shift = false;
        var same = 0,
            l = Math.min(prevInput.length, text.length);
        while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
        var from = sel.from,
            to = sel.to;
        if (same < prevInput.length) from = Pos(from.line, from.ch - (prevInput.length - same));else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming) to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));

        var updateInput = cm.curOp.updateInput;
        var changeEvent = { from: from, to: to, text: splitLines(text.slice(same)),
          origin: cm.state.pasteIncoming ? "paste" : "+input" };
        makeChange(cm.doc, changeEvent, "end");
        cm.curOp.updateInput = updateInput;
        signalLater(cm, "inputRead", cm, changeEvent);

        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";else cm.display.prevInput = text;
        if (withOp) endOperation(cm);
        cm.state.pasteIncoming = false;
        return true;
      }

      function resetInput(cm, user) {
        var minimal,
            selected,
            doc = cm.doc;
        if (!posEq(doc.sel.from, doc.sel.to)) {
          cm.display.prevInput = "";
          minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
          var content = minimal ? "-" : selected || cm.getSelection();
          cm.display.input.value = content;
          if (cm.state.focused) selectInput(cm.display.input);
          if (ie && !ie_lt9) cm.display.inputHasSelection = content;
        } else if (user) {
          cm.display.prevInput = cm.display.input.value = "";
          if (ie && !ie_lt9) cm.display.inputHasSelection = null;
        }
        cm.display.inaccurateSelection = minimal;
      }

      function focusInput(cm) {
        if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input)) cm.display.input.focus();
      }

      function isReadOnly(cm) {
        return cm.options.readOnly || cm.doc.cantEdit;
      }

      // EVENT HANDLERS

      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie) on(d.scroller, "dblclick", operation(cm, function (e) {
          if (signalDOMEvent(cm, e)) return;
          var pos = posFromMouse(cm, e);
          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
          e_preventDefault(e);
          var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
          extendSelection(cm.doc, word.from, word.to);
        }));else on(d.scroller, "dblclick", function (e) {
          signalDOMEvent(cm, e) || e_preventDefault(e);
        });
        on(d.lineSpace, "selectstart", function (e) {
          if (!eventInWidget(d, e)) e_preventDefault(e);
        });
        // Gecko browsers fire contextmenu *after* opening the menu, at
        // which point we can't mess with it anymore. Context menu is
        // handled in onMouseDown for Gecko.
        if (!captureMiddleClick) on(d.scroller, "contextmenu", function (e) {
          onContextMenu(cm, e);
        });

        on(d.scroller, "scroll", function () {
          if (d.scroller.clientHeight) {
            setScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });
        on(d.scrollbarV, "scroll", function () {
          if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
        });
        on(d.scrollbarH, "scroll", function () {
          if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
        });

        on(d.scroller, "mousewheel", function (e) {
          onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function (e) {
          onScrollWheel(cm, e);
        });

        function reFocus() {
          if (cm.state.focused) setTimeout(bind(focusInput, cm), 0);
        }
        on(d.scrollbarH, "mousedown", reFocus);
        on(d.scrollbarV, "mousedown", reFocus);
        // Prevent wrapper from ever scrolling
        on(d.wrapper, "scroll", function () {
          d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });

        var resizeTimer;
        function onResize() {
          if (resizeTimer == null) resizeTimer = setTimeout(function () {
            resizeTimer = null;
            // Might be a text scaling operation, clear size caches.
            d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;
            clearCaches(cm);
            runInOp(cm, bind(regChange, cm));
          }, 100);
        }
        on(window, "resize", onResize);
        // Above handler holds on to the editor and its data structures.
        // Here we poll to unregister it when the editor is no longer in
        // the document, so that it can be garbage-collected.
        function unregister() {
          for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}
          if (p) setTimeout(unregister, 5000);else off(window, "resize", onResize);
        }
        setTimeout(unregister, 5000);

        on(d.input, "keyup", operation(cm, function (e) {
          if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
          if (e.keyCode == 16) cm.doc.sel.shift = false;
        }));
        on(d.input, "input", function () {
          if (ie && !ie_lt9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;
          fastPoll(cm);
        });
        on(d.input, "keydown", operation(cm, onKeyDown));
        on(d.input, "keypress", operation(cm, onKeyPress));
        on(d.input, "focus", bind(onFocus, cm));
        on(d.input, "blur", bind(onBlur, cm));

        function drag_(e) {
          if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;
          e_stop(e);
        }
        if (cm.options.dragDrop) {
          on(d.scroller, "dragstart", function (e) {
            onDragStart(cm, e);
          });
          on(d.scroller, "dragenter", drag_);
          on(d.scroller, "dragover", drag_);
          on(d.scroller, "drop", operation(cm, onDrop));
        }
        on(d.scroller, "paste", function (e) {
          if (eventInWidget(d, e)) return;
          focusInput(cm);
          fastPoll(cm);
        });
        on(d.input, "paste", function () {
          // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
          // Add a char to the end of textarea before paste occur so that
          // selection doesn't span to the end of textarea.
          if (webkit && !cm.state.fakedLastChar && !(new Date() - cm.state.lastMiddleDown < 200)) {
            var start = d.input.selectionStart,
                end = d.input.selectionEnd;
            d.input.value += "$";
            d.input.selectionStart = start;
            d.input.selectionEnd = end;
            cm.state.fakedLastChar = true;
          }
          cm.state.pasteIncoming = true;
          fastPoll(cm);
        });

        function prepareCopy() {
          if (d.inaccurateSelection) {
            d.prevInput = "";
            d.inaccurateSelection = false;
            d.input.value = cm.getSelection();
            selectInput(d.input);
          }
        }
        on(d.input, "cut", prepareCopy);
        on(d.input, "copy", prepareCopy);

        // Needed to handle Tab key in KHTML
        if (khtml) on(d.sizer, "mouseup", function () {
          if (document.activeElement == d.input) d.input.blur();
          focusInput(cm);
        });
      }

      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
        }
      }

      function posFromMouse(cm, e, liberal) {
        var display = cm.display;
        if (!liberal) {
          var target = e_target(e);
          if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller || target == display.gutterFiller) return null;
        }
        var x,
            y,
            space = getRect(display.lineSpace);
        // Fails unpredictably on IE[67] when mouse is dragged around quickly.
        try {
          x = e.clientX;y = e.clientY;
        } catch (e) {
          return null;
        }
        return coordsChar(cm, x - space.left, y - space.top);
      }

      var lastClick, lastDoubleClick;
      function onMouseDown(e) {
        if (signalDOMEvent(this, e)) return;
        var cm = this,
            display = cm.display,
            doc = cm.doc,
            sel = doc.sel;
        sel.shift = e.shiftKey;

        if (eventInWidget(display, e)) {
          if (!webkit) {
            display.scroller.draggable = false;
            setTimeout(function () {
              display.scroller.draggable = true;
            }, 100);
          }
          return;
        }
        if (clickInGutter(cm, e)) return;
        var start = posFromMouse(cm, e);

        switch (e_button(e)) {
          case 3:
            if (captureMiddleClick) onContextMenu.call(cm, cm, e);
            return;
          case 2:
            if (webkit) cm.state.lastMiddleDown = +new Date();
            if (start) extendSelection(cm.doc, start);
            setTimeout(bind(focusInput, cm), 20);
            e_preventDefault(e);
            return;
        }
        // For button 1, if it was clicked inside the editor
        // (posFromMouse returning non-null), we have to adjust the
        // selection.
        if (!start) {
          if (e_target(e) == display.scroller) e_preventDefault(e);return;
        }

        if (!cm.state.focused) onFocus(cm);

        var now = +new Date(),
            type = "single";
        if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
          type = "triple";
          e_preventDefault(e);
          setTimeout(bind(focusInput, cm), 20);
          selectLine(cm, start.line);
        } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
          type = "double";
          lastDoubleClick = { time: now, pos: start };
          e_preventDefault(e);
          var word = findWordAt(getLine(doc, start.line).text, start);
          extendSelection(cm.doc, word.from, word.to);
        } else {
          lastClick = { time: now, pos: start };
        }

        var last = start;
        if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {
          var dragEnd = operation(cm, function (e2) {
            if (webkit) display.scroller.draggable = false;
            cm.state.draggingText = false;
            off(document, "mouseup", dragEnd);
            off(display.scroller, "drop", dragEnd);
            if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
              e_preventDefault(e2);
              extendSelection(cm.doc, start);
              focusInput(cm);
            }
          });
          // Let the drag handler handle this.
          if (webkit) display.scroller.draggable = true;
          cm.state.draggingText = dragEnd;
          // IE's approach to draggable
          if (display.scroller.dragDrop) display.scroller.dragDrop();
          on(document, "mouseup", dragEnd);
          on(display.scroller, "drop", dragEnd);
          return;
        }
        e_preventDefault(e);
        if (type == "single") extendSelection(cm.doc, clipPos(doc, start));

        var startstart = sel.from,
            startend = sel.to,
            lastPos = start;

        function doSelect(cur) {
          if (posEq(lastPos, cur)) return;
          lastPos = cur;

          if (type == "single") {
            extendSelection(cm.doc, clipPos(doc, start), cur);
            return;
          }

          startstart = clipPos(doc, startstart);
          startend = clipPos(doc, startend);
          if (type == "double") {
            var word = findWordAt(getLine(doc, cur.line).text, cur);
            if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);else extendSelection(cm.doc, startstart, word.to);
          } else if (type == "triple") {
            if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
          }
        }

        var editorSize = getRect(display.wrapper);
        // Used to ensure timeout re-tries don't fire when another extend
        // happened in the meantime (clearTimeout isn't reliable -- at
        // least on Chrome, the timeouts still happen even when cleared,
        // if the clear happens after their scheduled firing time).
        var counter = 0;

        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true);
          if (!cur) return;
          if (!posEq(cur, last)) {
            if (!cm.state.focused) onFocus(cm);
            last = cur;
            doSelect(cur);
            var visible = visibleLines(display, doc);
            if (cur.line >= visible.to || cur.line < visible.from) setTimeout(operation(cm, function () {
              if (counter == curCount) extend(e);
            }), 150);
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
            if (outside) setTimeout(operation(cm, function () {
              if (counter != curCount) return;
              display.scroller.scrollTop += outside;
              extend(e);
            }), 50);
          }
        }

        function done(e) {
          counter = Infinity;
          e_preventDefault(e);
          focusInput(cm);
          off(document, "mousemove", move);
          off(document, "mouseup", up);
        }

        var move = operation(cm, function (e) {
          if (!ie && !e_button(e)) done(e);else extend(e);
        });
        var up = operation(cm, done);
        on(document, "mousemove", move);
        on(document, "mouseup", up);
      }

      function gutterEvent(cm, e, type, prevent, signalfn) {
        try {
          var mX = e.clientX,
              mY = e.clientY;
        } catch (e) {
          return false;
        }
        if (mX >= Math.floor(getRect(cm.display.gutters).right)) return false;
        if (prevent) e_preventDefault(e);

        var display = cm.display;
        var lineBox = getRect(display.lineDiv);

        if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;

        for (var i = 0; i < cm.options.gutters.length; ++i) {
          var g = display.gutters.childNodes[i];
          if (g && getRect(g).right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.options.gutters[i];
            signalfn(cm, type, cm, line, gutter, e);
            return e_defaultPrevented(e);
          }
        }
      }

      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) return false;
        return gutterEvent(cm, e, "gutterContextMenu", false, signal);
      }

      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true, signalLater);
      }

      // Kludge to work around strange IE behavior where it'll sometimes
      // re-fire a series of drag-related events right after the drop (#1551)
      var lastDrop = 0;

      function onDrop(e) {
        var cm = this;
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;
        e_preventDefault(e);
        if (ie) lastDrop = +new Date();
        var pos = posFromMouse(cm, e, true),
            files = e.dataTransfer.files;
        if (!pos || isReadOnly(cm)) return;
        if (files && files.length && window.FileReader && window.File) {
          var n = files.length,
              text = Array(n),
              read = 0;
          var loadFile = function (file, i) {
            var reader = new FileReader();
            reader.onload = function () {
              text[i] = reader.result;
              if (++read == n) {
                pos = clipPos(cm.doc, pos);
                makeChange(cm.doc, { from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste" }, "around");
              }
            };
            reader.readAsText(file);
          };
          for (var i = 0; i < n; ++i) loadFile(files[i], i);
        } else {
          // Don't do a replace if the drop happened inside of the selected text.
          if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
            cm.state.draggingText(e);
            // Ensure the editor is re-focused
            setTimeout(bind(focusInput, cm), 20);
            return;
          }
          try {
            var text = e.dataTransfer.getData("Text");
            if (text) {
              var curFrom = cm.doc.sel.from,
                  curTo = cm.doc.sel.to;
              setSelection(cm.doc, pos, pos);
              if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");
              cm.replaceSelection(text, null, "paste");
              focusInput(cm);
            }
          } catch (e) {}
        }
      }

      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
          e_stop(e);return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

        var txt = cm.getSelection();
        e.dataTransfer.setData("Text", txt);

        // Use dummy image instead of default browsers image.
        // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (opera) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            // Force a relayout, or Opera won't use our image for some obscure reason
            img._top = img.offsetTop;
          }
          e.dataTransfer.setDragImage(img, 0, 0);
          if (opera) img.parentNode.removeChild(img);
        }
      }

      function setScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) return;
        cm.doc.scrollTop = val;
        if (!gecko) updateDisplay(cm, [], val);
        if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
        if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
        if (gecko) updateDisplay(cm, []);
        startWorker(cm, 100);
      }
      function setScrollLeft(cm, val, isScroller) {
        if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
        if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
      }

      // Since the delta values reported on mouse wheel events are
      // unstandardized between browsers and even browser versions, and
      // generally horribly unpredictable, this code starts by measuring
      // the scroll effect that the first few mouse wheel events have,
      // and, from that, detects the way it can convert deltas to pixel
      // offsets afterwards.
      //
      // The reason we want to know the amount a wheel event will scroll
      // is that it gives us a chance to update the display before the
      // actual scrolling happens, reducing flickering.

      var wheelSamples = 0,
          wheelPixelsPerUnit = null;
      // Fill in a browser-detected starting value on browsers where we
      // know one. These don't have to be accurate -- the result of them
      // being wrong would just be a slight flicker on the first wheel
      // scroll (if it is large enough).
      if (ie) wheelPixelsPerUnit = -.53;else if (gecko) wheelPixelsPerUnit = 15;else if (chrome) wheelPixelsPerUnit = -.7;else if (safari) wheelPixelsPerUnit = -1 / 3;

      function onScrollWheel(cm, e) {
        var dx = e.wheelDeltaX,
            dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;else if (dy == null) dy = e.wheelDelta;

        var display = cm.display,
            scroll = display.scroller;
        // Quit if there's nothing to scroll here
        if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight)) return;

        // Webkit browsers on OS X abort momentum scrolls when the target
        // of the scroll event is removed from the scrollable element.
        // This hack (see related code in patchDisplay) makes sure the
        // element is kept around.
        if (dy && mac && webkit) {
          for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
            if (cur.lineObj) {
              cm.display.currentWheelTarget = cur;
              break;
            }
          }
        }

        // On some browsers, horizontal scrolling will cause redraws to
        // happen before the gutter has been realigned, causing it to
        // wriggle around in a most unseemly way. When we have an
        // estimated pixels/delta value, we just handle horizontal
        // scrolling entirely here. It'll be slightly off from native, but
        // better than glitching out.
        if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
          if (dy) setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
          setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
          e_preventDefault(e);
          display.wheelStartX = null; // Abort measurement, if in progress
          return;
        }

        if (dy && wheelPixelsPerUnit != null) {
          var pixels = dy * wheelPixelsPerUnit;
          var top = cm.doc.scrollTop,
              bot = top + display.wrapper.clientHeight;
          if (pixels < 0) top = Math.max(0, top + pixels - 50);else bot = Math.min(cm.doc.height, bot + pixels + 50);
          updateDisplay(cm, [], { top: top, bottom: bot });
        }

        if (wheelSamples < 20) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;display.wheelDY = dy;
            setTimeout(function () {
              if (display.wheelStartX == null) return;
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
              display.wheelStartX = display.wheelStartY = null;
              if (!sample) return;
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;display.wheelDY += dy;
          }
        }
      }

      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound) return false;
        }
        // Ensure previous input has been read, so that the handler sees a
        // consistent view of the document
        if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
        var doc = cm.doc,
            prevShift = doc.sel.shift,
            done = false;
        try {
          if (isReadOnly(cm)) cm.state.suppressEdits = true;
          if (dropShift) doc.sel.shift = false;
          done = bound(cm) != Pass;
        } finally {
          doc.sel.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done;
      }

      function allKeyMaps(cm) {
        var maps = cm.state.keyMaps.slice(0);
        if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
        maps.push(cm.options.keyMap);
        return maps;
      }

      var maybeTransition;
      function handleKeyBinding(cm, e) {
        // Handle auto keymap transitions
        var startMap = getKeyMap(cm.options.keyMap),
            next = startMap.auto;
        clearTimeout(maybeTransition);
        if (next && !isModifierKey(e)) maybeTransition = setTimeout(function () {
          if (getKeyMap(cm.options.keyMap) == startMap) {
            cm.options.keyMap = next.call ? next.call(null, cm) : next;
            keyMapChanged(cm);
          }
        }, 50);

        var name = keyName(e, true),
            handled = false;
        if (!name) return false;
        var keymaps = allKeyMaps(cm);

        if (e.shiftKey) {
          // First try to resolve full name (including 'Shift-'). Failing
          // that, see if there is a cursor-motion command (starting with
          // 'go') bound to the keyname without 'Shift-'.
          handled = lookupKey("Shift-" + name, keymaps, function (b) {
            return doHandleBinding(cm, b, true);
          }) || lookupKey(name, keymaps, function (b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b);
          });
        } else {
          handled = lookupKey(name, keymaps, function (b) {
            return doHandleBinding(cm, b);
          });
        }

        if (handled) {
          e_preventDefault(e);
          restartBlink(cm);
          if (ie_lt9) {
            e.oldKeyCode = e.keyCode;e.keyCode = 0;
          }
          signalLater(cm, "keyHandled", cm, name, e);
        }
        return handled;
      }

      function handleCharBinding(cm, e, ch) {
        var handled = lookupKey("'" + ch + "'", allKeyMaps(cm), function (b) {
          return doHandleBinding(cm, b, true);
        });
        if (handled) {
          e_preventDefault(e);
          restartBlink(cm);
          signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
        }
        return handled;
      }

      var lastStoppedKey = null;
      function onKeyDown(e) {
        var cm = this;
        if (!cm.state.focused) onFocus(cm);
        if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
        if (ie && e.keyCode == 27) e.returnValue = false;
        var code = e.keyCode;
        // IE does strange things with escape.
        cm.doc.sel.shift = code == 16 || e.shiftKey;
        // First give onKeyEvent option a chance to handle this.
        var handled = handleKeyBinding(cm, e);
        if (opera) {
          lastStoppedKey = handled ? code : null;
          // Opera has no cut event... we try to at least catch the key combo
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) cm.replaceSelection("");
        }
      }

      function onKeyPress(e) {
        var cm = this;
        if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
        var keyCode = e.keyCode,
            charCode = e.charCode;
        if (opera && keyCode == lastStoppedKey) {
          lastStoppedKey = null;e_preventDefault(e);return;
        }
        if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e)) return;
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1) setTimeout(operation(cm, function () {
          indentLine(cm, cm.doc.sel.to.line, "smart");
        }), 75);
        if (handleCharBinding(cm, e, ch)) return;
        if (ie && !ie_lt9) cm.display.inputHasSelection = null;
        fastPoll(cm);
      }

      function onFocus(cm) {
        if (cm.options.readOnly == "nocursor") return;
        if (!cm.state.focused) {
          signal(cm, "focus", cm);
          cm.state.focused = true;
          if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1) cm.display.wrapper.className += " CodeMirror-focused";
          if (!cm.curOp) {
            resetInput(cm, true);
            if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730
          }
        }
        slowPoll(cm);
        restartBlink(cm);
      }
      function onBlur(cm) {
        if (cm.state.focused) {
          signal(cm, "blur", cm);
          cm.state.focused = false;
          cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function () {
          if (!cm.state.focused) cm.doc.sel.shift = false;
        }, 150);
      }

      var detectingSelectAll;
      function onContextMenu(cm, e) {
        if (signalDOMEvent(cm, e, "contextmenu")) return;
        var display = cm.display,
            sel = cm.doc.sel;
        if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;

        var pos = posFromMouse(cm, e),
            scrollPos = display.scroller.scrollTop;
        if (!pos || opera) return; // Opera is difficult.

        // Reset the current text selection only if the click is done outside of the selection
        // and 'resetSelectionOnContextMenu' option is true.
        var reset = cm.options.resetSelectionOnContextMenu;
        if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))) operation(cm, setSelection)(cm.doc, pos, pos);

        var oldCSS = display.input.style.cssText;
        display.inputDiv.style.position = "absolute";
        display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) + "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; outline: none;" + "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";
        focusInput(cm);
        resetInput(cm, true);
        // Adds "Select all" to context menu in FF
        if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";

        function prepareSelectAllHack() {
          if (display.input.selectionStart != null) {
            var extval = display.input.value = "\u200b" + (posEq(sel.from, sel.to) ? "" : display.input.value);
            display.prevInput = "\u200b";
            display.input.selectionStart = 1;display.input.selectionEnd = extval.length;
          }
        }
        function rehide() {
          display.inputDiv.style.position = "relative";
          display.input.style.cssText = oldCSS;
          if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
          slowPoll(cm);

          // Try to detect the user choosing select-all
          if (display.input.selectionStart != null) {
            if (!ie || ie_lt9) prepareSelectAllHack();
            clearTimeout(detectingSelectAll);
            var i = 0,
                poll = function () {
              if (display.prevInput == " " && display.input.selectionStart == 0) operation(cm, commands.selectAll)(cm);else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);else resetInput(cm);
            };
            detectingSelectAll = setTimeout(poll, 200);
          }
        }

        if (ie && !ie_lt9) prepareSelectAllHack();
        if (captureMiddleClick) {
          e_stop(e);
          var mouseup = function () {
            off(window, "mouseup", mouseup);
            setTimeout(rehide, 20);
          };
          on(window, "mouseup", mouseup);
        } else {
          setTimeout(rehide, 50);
        }
      }

      // UPDATING

      var changeEnd = CodeMirror.changeEnd = function (change) {
        if (!change.text) return change.to;
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
      };

      // Make sure a position will be valid after the given change.
      function clipPostChange(doc, change, pos) {
        if (!posLess(change.from, pos)) return clipPos(doc, pos);
        var diff = change.text.length - 1 - (change.to.line - change.from.line);
        if (pos.line > change.to.line + diff) {
          var preLine = pos.line - diff,
              lastLine = doc.first + doc.size - 1;
          if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);
          return clipToLen(pos, getLine(doc, preLine).text.length);
        }
        if (pos.line == change.to.line + diff) return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
        var inside = pos.line - change.from.line;
        return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
      }

      // Hint can be null|"end"|"start"|"around"|{anchor,head}
      function computeSelAfterChange(doc, change, hint) {
        if (hint && typeof hint == "object") // Assumed to be {anchor, head} object
          return { anchor: clipPostChange(doc, change, hint.anchor),
            head: clipPostChange(doc, change, hint.head) };

        if (hint == "start") return { anchor: change.from, head: change.from };

        var end = changeEnd(change);
        if (hint == "around") return { anchor: change.from, head: end };
        if (hint == "end") return { anchor: end, head: end };

        // hint is null, leave the selection alone as much as possible
        var adjustPos = function (pos) {
          if (posLess(pos, change.from)) return pos;
          if (!posLess(change.to, pos)) return end;

          var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
              ch = pos.ch;
          if (pos.line == change.to.line) ch += end.ch - change.to.ch;
          return Pos(line, ch);
        };
        return { anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head) };
      }

      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function () {
            this.canceled = true;
          }
        };
        if (update) obj.update = function (from, to, text, origin) {
          if (from) this.from = clipPos(doc, from);
          if (to) this.to = clipPos(doc, to);
          if (text) this.text = text;
          if (origin !== undefined) this.origin = origin;
        };
        signal(doc, "beforeChange", doc, obj);
        if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

        if (obj.canceled) return null;
        return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
      }

      // Replace the range from from to to by the strings in replacement.
      // change is a {from, to, text [, origin]} object
      function makeChange(doc, change, selUpdate, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
          if (doc.cm.state.suppressEdits) return;
        }

        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);
          if (!change) return;
        }

        // Possibly split or suppress the update based on the presence
        // of read-only spans in its range.
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
          for (var i = split.length - 1; i >= 1; --i) makeChangeNoReadonly(doc, { from: split[i].from, to: split[i].to, text: [""] });
          if (split.length) makeChangeNoReadonly(doc, { from: split[0].from, to: split[0].to, text: change.text }, selUpdate);
        } else {
          makeChangeNoReadonly(doc, change, selUpdate);
        }
      }

      function makeChangeNoReadonly(doc, change, selUpdate) {
        if (change.text.length == 1 && change.text[0] == "" && posEq(change.from, change.to)) return;
        var selAfter = computeSelAfterChange(doc, change, selUpdate);
        addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];

        linkedDocs(doc, function (doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }
          makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
      }

      function makeChangeFromHistory(doc, type) {
        if (doc.cm && doc.cm.state.suppressEdits) return;

        var hist = doc.history;
        var event = (type == "undo" ? hist.done : hist.undone).pop();
        if (!event) return;

        var anti = { changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,
          anchorAfter: event.anchorBefore, headAfter: event.headBefore,
          generation: hist.generation };
        (type == "undo" ? hist.undone : hist.done).push(anti);
        hist.generation = event.generation || ++hist.maxGeneration;

        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

        for (var i = event.changes.length - 1; i >= 0; --i) {
          var change = event.changes[i];
          change.origin = type;
          if (filter && !filterChange(doc, change, false)) {
            (type == "undo" ? hist.done : hist.undone).length = 0;
            return;
          }

          anti.changes.push(historyChangeFromChange(doc, change));

          var after = i ? computeSelAfterChange(doc, change, null) : { anchor: event.anchorBefore, head: event.headBefore };
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
          var rebased = [];

          linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change);
              rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
          });
        }
      }

      function shiftDoc(doc, distance) {
        function shiftPos(pos) {
          return Pos(pos.line + distance, pos.ch);
        }
        doc.first += distance;
        if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);
        doc.sel.head = shiftPos(doc.sel.head);doc.sel.anchor = shiftPos(doc.sel.anchor);
        doc.sel.from = shiftPos(doc.sel.from);doc.sel.to = shiftPos(doc.sel.to);
      }

      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }
        if (change.from.line > doc.lastLine()) return;

        // Clip the change to the size of this doc
        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = { from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)], origin: change.origin };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
          change = { from: change.from, to: Pos(last, getLine(doc, last).text.length),
            text: [change.text[0]], origin: change.origin };
        }

        change.removed = getBetween(doc, change.from, change.to);

        if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
        if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);else updateDoc(doc, change, spans, selAfter);
      }

      function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
        var doc = cm.doc,
            display = cm.display,
            from = change.from,
            to = change.to;

        var recomputeMaxLength = false,
            checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function (line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }

        if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head)) cm.curOp.cursorActivity = true;

        updateDoc(doc, change, spans, selAfter, estimateHeight(cm));

        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
            var len = lineLength(doc, line);
            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
        }

        // Adjust frontier, schedule worker
        doc.frontier = Math.min(doc.frontier, from.line);
        startWorker(cm, 400);

        var lendiff = change.text.length - (to.line - from.line) - 1;
        // Remember that these lines changed, for updating the display
        regChange(cm, from.line, to.line + 1, lendiff);

        if (hasHandler(cm, "change")) {
          var changeObj = { from: from, to: to,
            text: change.text,
            removed: change.removed,
            origin: change.origin };
          if (cm.curOp.textChanged) {
            for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}
            cur.next = changeObj;
          } else cm.curOp.textChanged = changeObj;
        }
      }

      function replaceRange(doc, code, from, to, origin) {
        if (!to) to = from;
        if (posLess(to, from)) {
          var tmp = to;to = from;from = tmp;
        }
        if (typeof code == "string") code = splitLines(code);
        makeChange(doc, { from: from, to: to, text: code, origin: origin }, null);
      }

      // POSITION OBJECT

      function Pos(line, ch) {
        if (!(this instanceof Pos)) return new Pos(line, ch);
        this.line = line;this.ch = ch;
      }
      CodeMirror.Pos = Pos;

      function posEq(a, b) {
        return a.line == b.line && a.ch == b.ch;
      }
      function posLess(a, b) {
        return a.line < b.line || a.line == b.line && a.ch < b.ch;
      }
      function copyPos(x) {
        return Pos(x.line, x.ch);
      }

      // SELECTION

      function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
      }
      function clipPos(doc, pos) {
        if (pos.line < doc.first) return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
        return clipToLen(pos, getLine(doc, pos.line).text.length);
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen) return Pos(pos.line, linelen);else if (ch < 0) return Pos(pos.line, 0);else return pos;
      }
      function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
      }

      // If shift is held, this will move the selection anchor. Otherwise,
      // it'll set the whole selection.
      function extendSelection(doc, pos, other, bias) {
        if (doc.sel.shift || doc.sel.extend) {
          var anchor = doc.sel.anchor;
          if (other) {
            var posBefore = posLess(pos, anchor);
            if (posBefore != posLess(other, anchor)) {
              anchor = pos;
              pos = other;
            } else if (posBefore != posLess(pos, other)) {
              pos = other;
            }
          }
          setSelection(doc, anchor, pos, bias);
        } else {
          setSelection(doc, pos, other || pos, bias);
        }
        if (doc.cm) doc.cm.curOp.userSelChange = true;
      }

      function filterSelectionChange(doc, anchor, head) {
        var obj = { anchor: anchor, head: head };
        signal(doc, "beforeSelectionChange", doc, obj);
        if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        obj.anchor = clipPos(doc, obj.anchor);obj.head = clipPos(doc, obj.head);
        return obj;
      }

      // Update the selection. Last two args are only used by
      // updateDoc, since they have to be expressed in the line
      // numbers before the update.
      function setSelection(doc, anchor, head, bias, checkAtomic) {
        if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
          var filtered = filterSelectionChange(doc, anchor, head);
          head = filtered.head;
          anchor = filtered.anchor;
        }

        var sel = doc.sel;
        sel.goalColumn = null;
        if (bias == null) bias = posLess(head, sel.head) ? -1 : 1;
        // Skip over atomic spans.
        if (checkAtomic || !posEq(anchor, sel.anchor)) anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");
        if (checkAtomic || !posEq(head, sel.head)) head = skipAtomic(doc, head, bias, checkAtomic != "push");

        if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;

        sel.anchor = anchor;sel.head = head;
        var inv = posLess(head, anchor);
        sel.from = inv ? head : anchor;
        sel.to = inv ? anchor : head;

        if (doc.cm) doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;

        signalLater(doc, "cursorActivity", doc);
      }

      function reCheckSelection(cm) {
        setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");
      }

      function skipAtomic(doc, pos, bias, mayClear) {
        var flipped = false,
            curPos = pos;
        var dir = bias || 1;
        doc.cantEdit = false;
        search: for (;;) {
          var line = getLine(doc, curPos.line);
          if (line.markedSpans) {
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var sp = line.markedSpans[i],
                  m = sp.marker;
              if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                if (mayClear) {
                  signal(m, "beforeCursorEnter");
                  if (m.explicitlyCleared) {
                    if (!line.markedSpans) break;else {
                      --i;continue;
                    }
                  }
                }
                if (!m.atomic) continue;
                var newPos = m.find()[dir < 0 ? "from" : "to"];
                if (posEq(newPos, curPos)) {
                  newPos.ch += dir;
                  if (newPos.ch < 0) {
                    if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));else newPos = null;
                  } else if (newPos.ch > line.text.length) {
                    if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);else newPos = null;
                  }
                  if (!newPos) {
                    if (flipped) {
                      // Driven in a corner -- no valid cursor position found at all
                      // -- try again *with* clearing, if we didn't already
                      if (!mayClear) return skipAtomic(doc, pos, bias, true);
                      // Otherwise, turn off editing until further notice, and return the start of the doc
                      doc.cantEdit = true;
                      return Pos(doc.first, 0);
                    }
                    flipped = true;newPos = pos;dir = -dir;
                  }
                }
                curPos = newPos;
                continue search;
              }
            }
          }
          return curPos;
        }
      }

      // SCROLLING

      function scrollCursorIntoView(cm) {
        var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);
        if (!cm.state.focused) return;
        var display = cm.display,
            box = getRect(display.sizer),
            doScroll = null;
        if (coords.top + box.top < 0) doScroll = true;else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
        if (doScroll != null && !phantom) {
          var hidden = display.cursor.style.display == "none";
          if (hidden) {
            display.cursor.style.display = "";
            display.cursor.style.left = coords.left + "px";
            display.cursor.style.top = coords.top - display.viewOffset + "px";
          }
          display.cursor.scrollIntoView(doScroll);
          if (hidden) display.cursor.style.display = "none";
        }
      }

      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) margin = 0;
        for (;;) {
          var changed = false,
              coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
          var startTop = cm.doc.scrollTop,
              startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            setScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
          }
          if (!changed) return coords;
        }
      }

      function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
        if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
      }

      function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display,
            snapMargin = textHeight(cm.display);
        if (y1 < 0) y1 = 0;
        var screen = display.scroller.clientHeight - scrollerCutOff,
            screentop = display.scroller.scrollTop,
            result = {};
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = y1 < snapMargin,
            atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop) {
          result.scrollTop = atTop ? 0 : y1;
        } else if (y2 > screentop + screen) {
          var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
          if (newTop != screentop) result.scrollTop = newTop;
        }

        var screenw = display.scroller.clientWidth - scrollerCutOff,
            screenleft = display.scroller.scrollLeft;
        x1 += display.gutters.offsetWidth;x2 += display.gutters.offsetWidth;
        var gutterw = display.gutters.offsetWidth;
        var atLeft = x1 < gutterw + 10;
        if (x1 < screenleft + gutterw || atLeft) {
          if (atLeft) x1 = 0;
          result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
        } else if (x2 > screenw + screenleft - 3) {
          result.scrollLeft = x2 + 10 - screenw;
        }
        return result;
      }

      function updateScrollPos(cm, left, top) {
        cm.curOp.updateScrollPos = { scrollLeft: left == null ? cm.doc.scrollLeft : left,
          scrollTop: top == null ? cm.doc.scrollTop : top };
      }

      function addToScrollPos(cm, left, top) {
        var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = { scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop });
        var scroll = cm.display.scroller;
        pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
        pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
      }

      // API UTILITIES

      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc;
        if (how == null) how = "add";
        if (how == "smart") {
          if (!cm.doc.mode.indent) how = "prev";else var state = getStateBefore(cm, n);
        }

        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n),
            curSpace = countColumn(line.text, null, tabSize);
        var curSpaceString = line.text.match(/^\s*/)[0],
            indentation;
        if (how == "smart") {
          indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass) {
            if (!aggressive) return;
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n > doc.first) indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);else indentation = 0;
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);

        var indentString = "",
            pos = 0;
        if (cm.options.indentWithTabs) for (var i = Math.floor(indentation / tabSize); i; --i) {
          pos += tabSize;indentString += "\t";
        }
        if (pos < indentation) indentString += spaceStr(indentation - pos);

        if (indentString != curSpaceString) replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");else if (doc.sel.head.line == n && doc.sel.head.ch < curSpaceString.length) setSelection(doc, Pos(n, curSpaceString.length), Pos(n, curSpaceString.length), 1);
        line.stateAfter = null;
      }

      function changeLine(cm, handle, op) {
        var no = handle,
            line = handle,
            doc = cm.doc;
        if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));else no = lineNo(handle);
        if (no == null) return null;
        if (op(line, no)) regChange(cm, no, no + 1);else return null;
        return line;
      }

      function findPosH(doc, pos, dir, unit, visually) {
        var line = pos.line,
            ch = pos.ch,
            origDir = dir;
        var lineObj = getLine(doc, line);
        var possible = true;
        function findNextLine() {
          var l = line + dir;
          if (l < doc.first || l >= doc.first + doc.size) return possible = false;
          line = l;
          return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
          var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
          if (next == null) {
            if (!boundToLine && findNextLine()) {
              if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);else ch = dir < 0 ? lineObj.text.length : 0;
            } else return possible = false;
          } else ch = next;
          return true;
        }

        if (unit == "char") moveOnce();else if (unit == "column") moveOnce(true);else if (unit == "word" || unit == "group") {
          var sawType = null,
              group = unit == "group";
          for (var first = true;; first = false) {
            if (dir < 0 && !moveOnce(!first)) break;
            var cur = lineObj.text.charAt(ch) || "\n";
            var type = isWordChar(cur) ? "w" : !group ? null : /\s/.test(cur) ? null : "p";
            if (sawType && sawType != type) {
              if (dir < 0) {
                dir = 1;moveOnce();
              }
              break;
            }
            if (type) sawType = type;
            if (dir > 0 && !moveOnce(!first)) break;
          }
        }
        var result = skipAtomic(doc, Pos(line, ch), origDir, true);
        if (!possible) result.hitSide = true;
        return result;
      }

      function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc,
            x = pos.left,
            y;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        for (;;) {
          var target = coordsChar(cm, x, y);
          if (!target.outside) break;
          if (dir < 0 ? y <= 0 : y >= doc.height) {
            target.hitSide = true;break;
          }
          y += dir * 5;
        }
        return target;
      }

      function findWordAt(line, pos) {
        var start = pos.ch,
            end = pos.ch;
        if (line) {
          if ((pos.xRel < 0 || end == line.length) && start) --start;else ++end;
          var startChar = line.charAt(start);
          var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
            return (/\s/.test(ch)
            );
          } : function (ch) {
            return !/\s/.test(ch) && !isWordChar(ch);
          };
          while (start > 0 && check(line.charAt(start - 1))) --start;
          while (end < line.length && check(line.charAt(end))) ++end;
        }
        return { from: Pos(pos.line, start), to: Pos(pos.line, end) };
      }

      function selectLine(cm, line) {
        extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
      }

      // PROTOTYPE

      // The publicly visible API. Note that operation(null, f) means
      // 'wrap f in an operation, performed on its `this` parameter'

      CodeMirror.prototype = {
        constructor: CodeMirror,
        focus: function () {
          window.focus();focusInput(this);fastPoll(this);
        },

        setOption: function (option, value) {
          var options = this.options,
              old = options[option];
          if (options[option] == value && option != "mode") return;
          options[option] = value;
          if (optionHandlers.hasOwnProperty(option)) operation(this, optionHandlers[option])(this, value, old);
        },

        getOption: function (option) {
          return this.options[option];
        },
        getDoc: function () {
          return this.doc;
        },

        addKeyMap: function (map, bottom) {
          this.state.keyMaps[bottom ? "push" : "unshift"](map);
        },
        removeKeyMap: function (map) {
          var maps = this.state.keyMaps;
          for (var i = 0; i < maps.length; ++i) if (maps[i] == map || typeof maps[i] != "string" && maps[i].name == map) {
            maps.splice(i, 1);
            return true;
          }
        },

        addOverlay: operation(null, function (spec, options) {
          var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
          if (mode.startState) throw new Error("Overlays may not be stateful.");
          this.state.overlays.push({ mode: mode, modeSpec: spec, opaque: options && options.opaque });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: operation(null, function (spec) {
          var overlays = this.state.overlays;
          for (var i = 0; i < overlays.length; ++i) {
            var cur = overlays[i].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i, 1);
              this.state.modeGen++;
              regChange(this);
              return;
            }
          }
        }),

        indentLine: operation(null, function (n, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";else dir = dir ? "add" : "subtract";
          }
          if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
        }),
        indentSelection: operation(null, function (how) {
          var sel = this.doc.sel;
          if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);
          var e = sel.to.line - (sel.to.ch ? 0 : 1);
          for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);
        }),

        // Fetch the parser token for a given character. Useful for hacks
        // that want to inspect the mode state (say, for completion).
        getTokenAt: function (pos, precise) {
          var doc = this.doc;
          pos = clipPos(doc, pos);
          var state = getStateBefore(this, pos.line, precise),
              mode = this.doc.mode;
          var line = getLine(doc, pos.line);
          var stream = new StringStream(line.text, this.options.tabSize);
          while (stream.pos < pos.ch && !stream.eol()) {
            stream.start = stream.pos;
            var style = mode.token(stream, state);
          }
          return { start: stream.start,
            end: stream.pos,
            string: stream.current(),
            className: style || null, // Deprecated, use 'type' instead
            type: style || null,
            state: state };
        },

        getTokenTypeAt: function (pos) {
          pos = clipPos(this.doc, pos);
          var styles = getLineStyles(this, getLine(this.doc, pos.line));
          var before = 0,
              after = (styles.length - 1) / 2,
              ch = pos.ch;
          if (ch == 0) return styles[2];
          for (;;) {
            var mid = before + after >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;else if (styles[mid * 2 + 1] < ch) before = mid + 1;else return styles[mid * 2 + 2];
          }
        },

        getModeAt: function (pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode) return mode;
          return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
        },

        getHelper: function (pos, type) {
          if (!helpers.hasOwnProperty(type)) return;
          var help = helpers[type],
              mode = this.getModeAt(pos);
          return mode[type] && help[mode[type]] || mode.helperType && help[mode.helperType] || help[mode.name];
        },

        getStateAfter: function (line, precise) {
          var doc = this.doc;
          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
          return getStateBefore(this, line + 1, precise);
        },

        cursorCoords: function (start, mode) {
          var pos,
              sel = this.doc.sel;
          if (start == null) pos = sel.head;else if (typeof start == "object") pos = clipPos(this.doc, start);else pos = start ? sel.from : sel.to;
          return cursorCoords(this, pos, mode || "page");
        },

        charCoords: function (pos, mode) {
          return charCoords(this, clipPos(this.doc, pos), mode || "page");
        },

        coordsChar: function (coords, mode) {
          coords = fromCoordSystem(this, coords, mode || "page");
          return coordsChar(this, coords.left, coords.top);
        },

        lineAtHeight: function (height, mode) {
          height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
          return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function (line, mode) {
          var end = false,
              last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) line = this.doc.first;else if (line > last) {
            line = last;end = true;
          }
          var lineObj = getLine(this.doc, line);
          return intoCoordSystem(this, getLine(this.doc, line), { top: 0, left: 0 }, mode || "page").top + (end ? lineObj.height : 0);
        },

        defaultTextHeight: function () {
          return textHeight(this.display);
        },
        defaultCharWidth: function () {
          return charWidth(this.display);
        },

        setGutterMarker: operation(null, function (line, gutterID, value) {
          return changeLine(this, line, function (line) {
            var markers = line.gutterMarkers || (line.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers)) line.gutterMarkers = null;
            return true;
          });
        }),

        clearGutter: operation(null, function (gutterID) {
          var cm = this,
              doc = cm.doc,
              i = doc.first;
          doc.iter(function (line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              line.gutterMarkers[gutterID] = null;
              regChange(cm, i, i + 1);
              if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
            }
            ++i;
          });
        }),

        addLineClass: operation(null, function (handle, where, cls) {
          return changeLine(this, handle, function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
            if (!line[prop]) line[prop] = cls;else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;else line[prop] += " " + cls;
            return true;
          });
        }),

        removeLineClass: operation(null, function (handle, where, cls) {
          return changeLine(this, handle, function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
            var cur = line[prop];
            if (!cur) return false;else if (cls == null) line[prop] = null;else {
              var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
              if (!found) return false;
              var end = found.index + found[0].length;
              line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true;
          });
        }),

        addLineWidget: operation(null, function (handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),

        removeLineWidget: function (widget) {
          widget.clear();
        },

        lineInfo: function (line) {
          if (typeof line == "number") {
            if (!isLine(this.doc, line)) return null;
            var n = line;
            line = getLine(this.doc, line);
            if (!line) return null;
          } else {
            var n = lineNo(line);
            if (n == null) return null;
          }
          return { line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
            widgets: line.widgets };
        },

        getViewport: function () {
          return { from: this.display.showingFrom, to: this.display.showingTo };
        },

        addWidget: function (pos, node, scroll, vert, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top = pos.bottom,
              left = pos.left;
          node.style.position = "absolute";
          display.sizer.appendChild(node);
          if (vert == "over") {
            top = pos.top;
          } else if (vert == "above" || vert == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            // Default to positioning above (if specified and possible); otherwise default to positioning below
            if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) top = pos.top - node.offsetHeight;else if (pos.bottom + node.offsetHeight <= vspace) top = pos.bottom;
            if (left + node.offsetWidth > hspace) left = hspace - node.offsetWidth;
          }
          node.style.top = top + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left") left = 0;else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
            node.style.left = left + "px";
          }
          if (scroll) scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
        },

        triggerOnKeyDown: operation(null, onKeyDown),

        execCommand: function (cmd) {
          return commands[cmd](this);
        },

        findPosH: function (from, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;amount = -amount;
          }
          for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
            cur = findPosH(this.doc, cur, dir, unit, visually);
            if (cur.hitSide) break;
          }
          return cur;
        },

        moveH: operation(null, function (dir, unit) {
          var sel = this.doc.sel,
              pos;
          if (sel.shift || sel.extend || posEq(sel.from, sel.to)) pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);else pos = dir < 0 ? sel.from : sel.to;
          extendSelection(this.doc, pos, pos, dir);
        }),

        deleteH: operation(null, function (dir, unit) {
          var sel = this.doc.sel;
          if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");
          this.curOp.userSelChange = true;
        }),

        findPosV: function (from, amount, unit, goalColumn) {
          var dir = 1,
              x = goalColumn;
          if (amount < 0) {
            dir = -1;amount = -amount;
          }
          for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
            var coords = cursorCoords(this, cur, "div");
            if (x == null) x = coords.left;else coords.left = x;
            cur = findPosV(this, coords, dir, unit);
            if (cur.hitSide) break;
          }
          return cur;
        },

        moveV: operation(null, function (dir, unit) {
          var sel = this.doc.sel;
          var pos = cursorCoords(this, sel.head, "div");
          if (sel.goalColumn != null) pos.left = sel.goalColumn;
          var target = findPosV(this, pos, dir, unit);

          if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);
          extendSelection(this.doc, target, target, dir);
          sel.goalColumn = pos.left;
        }),

        toggleOverwrite: function (value) {
          if (value != null && value == this.state.overwrite) return;
          if (this.state.overwrite = !this.state.overwrite) this.display.cursor.className += " CodeMirror-overwrite";else this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");
        },
        hasFocus: function () {
          return this.state.focused;
        },

        scrollTo: operation(null, function (x, y) {
          updateScrollPos(this, x, y);
        }),
        getScrollInfo: function () {
          var scroller = this.display.scroller,
              co = scrollerCutOff;
          return { left: scroller.scrollLeft, top: scroller.scrollTop,
            height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
            clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co };
        },

        scrollIntoView: operation(null, function (range, margin) {
          if (range == null) range = { from: this.doc.sel.head, to: null };else if (typeof range == "number") range = { from: Pos(range, 0), to: null };else if (range.from == null) range = { from: range, to: null };
          if (!range.to) range.to = range.from;
          if (!margin) margin = 0;

          var coords = range;
          if (range.from.line != null) {
            this.curOp.scrollToPos = { from: range.from, to: range.to, margin: margin };
            coords = { from: cursorCoords(this, range.from),
              to: cursorCoords(this, range.to) };
          }
          var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left), Math.min(coords.from.top, coords.to.top) - margin, Math.max(coords.from.right, coords.to.right), Math.max(coords.from.bottom, coords.to.bottom) + margin);
          updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
        }),

        setSize: operation(null, function (width, height) {
          function interpret(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          }
          if (width != null) this.display.wrapper.style.width = interpret(width);
          if (height != null) this.display.wrapper.style.height = interpret(height);
          if (this.options.lineWrapping) this.display.measureLineCache.length = this.display.measureLineCachePos = 0;
          this.curOp.forceUpdate = true;
        }),

        operation: function (f) {
          return runInOp(this, f);
        },

        refresh: operation(null, function () {
          var badHeight = this.display.cachedTextHeight == null;
          clearCaches(this);
          updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
          regChange(this);
          if (badHeight) estimateLineHeights(this);
        }),

        swapDoc: operation(null, function (doc) {
          var old = this.doc;
          old.cm = null;
          attachDoc(this, doc);
          clearCaches(this);
          resetInput(this, true);
          updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
          signalLater(this, "swapDoc", this, old);
          return old;
        }),

        getInputField: function () {
          return this.display.input;
        },
        getWrapperElement: function () {
          return this.display.wrapper;
        },
        getScrollerElement: function () {
          return this.display.scroller;
        },
        getGutterElement: function () {
          return this.display.gutters;
        }
      };
      eventMixin(CodeMirror);

      // OPTION DEFAULTS

      var optionHandlers = CodeMirror.optionHandlers = {};

      // The default configuration options.
      var defaults = CodeMirror.defaults = {};

      function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt;
        if (handle) optionHandlers[name] = notOnInit ? function (cm, val, old) {
          if (old != Init) handle(cm, val, old);
        } : handle;
      }

      var Init = CodeMirror.Init = { toString: function () {
          return "CodeMirror.Init";
        } };

      // These two are, on init, called from the constructor because they
      // have to be initialized before the editor can start at all.
      option("value", "", function (cm, val) {
        cm.setValue(val);
      }, true);
      option("mode", null, function (cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);

      option("indentUnit", 2, loadMode, true);
      option("indentWithTabs", false);
      option("smartIndent", true);
      option("tabSize", 4, function (cm) {
        loadMode(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);
      option("specialChars", /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\ufeff]/g, function (cm, val) {
        cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
        cm.refresh();
      }, true);
      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
        cm.refresh();
      }, true);
      option("electricChars", true);
      option("rtlMoveVisually", !windows);
      option("wholeLineUpdateBefore", true);

      option("theme", "default", function (cm) {
        themeChanged(cm);
        guttersChanged(cm);
      }, true);
      option("keyMap", "default", keyMapChanged);
      option("extraKeys", null);

      option("onKeyEvent", null);
      option("onDragEvent", null);

      option("lineWrapping", false, wrappingChanged, true);
      option("gutters", [], function (cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
      }, true);
      option("fixedGutter", true, function (cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option("coverGutterNextToScrollbar", false, updateScrollbars, true);
      option("lineNumbers", false, function (cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
      }, true);
      option("firstLineNumber", 1, guttersChanged, true);
      option("lineNumberFormatter", function (integer) {
        return integer;
      }, guttersChanged, true);
      option("showCursorWhenSelecting", false, updateSelection, true);

      option("resetSelectionOnContextMenu", true);

      option("readOnly", false, function (cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
          cm.display.disabled = true;
        } else {
          cm.display.disabled = false;
          if (!val) resetInput(cm, true);
        }
      });
      option("dragDrop", true);

      option("cursorBlinkRate", 530);
      option("cursorScrollMargin", 0);
      option("cursorHeight", 1);
      option("workTime", 100);
      option("workDelay", 100);
      option("flattenSpans", true);
      option("pollInterval", 100);
      option("undoDepth", 40, function (cm, val) {
        cm.doc.history.undoDepth = val;
      });
      option("historyEventDelay", 500);
      option("viewportMargin", 10, function (cm) {
        cm.refresh();
      }, true);
      option("maxHighlightLength", 10000, function (cm) {
        loadMode(cm);cm.refresh();
      }, true);
      option("crudeMeasuringFrom", 10000);
      option("moveInputWithCursor", true, function (cm, val) {
        if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
      });

      option("tabindex", null, function (cm, val) {
        cm.display.input.tabIndex = val || "";
      });
      option("autofocus", null);

      // MODE DEFINITION AND QUERYING

      // Known modes, by name and by MIME
      var modes = CodeMirror.modes = {},
          mimeModes = CodeMirror.mimeModes = {};

      CodeMirror.defineMode = function (name, mode) {
        if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
        if (arguments.length > 2) {
          mode.dependencies = [];
          for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
        }
        modes[name] = mode;
      };

      CodeMirror.defineMIME = function (mime, spec) {
        mimeModes[mime] = spec;
      };

      CodeMirror.resolveMode = function (spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return CodeMirror.resolveMode("application/xml");
        }
        if (typeof spec == "string") return { name: spec };else return spec || { name: "null" };
      };

      CodeMirror.getMode = function (options, spec) {
        var spec = CodeMirror.resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) return CodeMirror.getMode(options, "text/plain");
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop)) continue;
            if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
            modeObj[prop] = exts[prop];
          }
        }
        modeObj.name = spec.name;

        return modeObj;
      };

      CodeMirror.defineMode("null", function () {
        return { token: function (stream) {
            stream.skipToEnd();
          } };
      });
      CodeMirror.defineMIME("text/plain", "null");

      var modeExtensions = CodeMirror.modeExtensions = {};
      CodeMirror.extendMode = function (mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
      };

      // EXTENSIONS

      CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func;
      };
      CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func;
      };
      CodeMirror.defineOption = option;

      var initHooks = [];
      CodeMirror.defineInitHook = function (f) {
        initHooks.push(f);
      };

      var helpers = CodeMirror.helpers = {};
      CodeMirror.registerHelper = function (type, name, value) {
        if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {};
        helpers[type][name] = value;
      };

      // UTILITIES

      CodeMirror.isWordChar = isWordChar;

      // MODE STATE HANDLING

      // Utility functions for working with state. Exported because modes
      // sometimes need to do this.
      function copyState(mode, state) {
        if (state === true) return state;
        if (mode.copyState) return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array) val = val.concat([]);
          nstate[n] = val;
        }
        return nstate;
      }
      CodeMirror.copyState = copyState;

      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      }
      CodeMirror.startState = startState;

      CodeMirror.innerMode = function (mode, state) {
        while (mode.innerMode) {
          var info = mode.innerMode(state);
          if (!info || info.mode == mode) break;
          state = info.state;
          mode = info.mode;
        }
        return info || { mode: mode, state: state };
      };

      // STANDARD COMMANDS

      var commands = CodeMirror.commands = {
        selectAll: function (cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
        },
        killLine: function (cm) {
          var from = cm.getCursor(true),
              to = cm.getCursor(false),
              sel = !posEq(from, to);
          if (!sel && cm.getLine(from.line).length == from.ch) cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");
        },
        deleteLine: function (cm) {
          var l = cm.getCursor().line;
          cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");
        },
        delLineLeft: function (cm) {
          var cur = cm.getCursor();
          cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");
        },
        undo: function (cm) {
          cm.undo();
        },
        redo: function (cm) {
          cm.redo();
        },
        goDocStart: function (cm) {
          cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function (cm) {
          cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function (cm) {
          cm.extendSelection(lineStart(cm, cm.getCursor().line));
        },
        goLineStartSmart: function (cm) {
          var cur = cm.getCursor(),
              start = lineStart(cm, cur.line);
          var line = cm.getLineHandle(start.line);
          var order = getOrder(line);
          if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(0, line.text.search(/\S/));
            var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
            cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
          } else cm.extendSelection(start);
        },
        goLineEnd: function (cm) {
          cm.extendSelection(lineEnd(cm, cm.getCursor().line));
        },
        goLineRight: function (cm) {
          var top = cm.charCoords(cm.getCursor(), "div").top + 5;
          cm.extendSelection(cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top }, "div"));
        },
        goLineLeft: function (cm) {
          var top = cm.charCoords(cm.getCursor(), "div").top + 5;
          cm.extendSelection(cm.coordsChar({ left: 0, top: top }, "div"));
        },
        goLineUp: function (cm) {
          cm.moveV(-1, "line");
        },
        goLineDown: function (cm) {
          cm.moveV(1, "line");
        },
        goPageUp: function (cm) {
          cm.moveV(-1, "page");
        },
        goPageDown: function (cm) {
          cm.moveV(1, "page");
        },
        goCharLeft: function (cm) {
          cm.moveH(-1, "char");
        },
        goCharRight: function (cm) {
          cm.moveH(1, "char");
        },
        goColumnLeft: function (cm) {
          cm.moveH(-1, "column");
        },
        goColumnRight: function (cm) {
          cm.moveH(1, "column");
        },
        goWordLeft: function (cm) {
          cm.moveH(-1, "word");
        },
        goGroupRight: function (cm) {
          cm.moveH(1, "group");
        },
        goGroupLeft: function (cm) {
          cm.moveH(-1, "group");
        },
        goWordRight: function (cm) {
          cm.moveH(1, "word");
        },
        delCharBefore: function (cm) {
          cm.deleteH(-1, "char");
        },
        delCharAfter: function (cm) {
          cm.deleteH(1, "char");
        },
        delWordBefore: function (cm) {
          cm.deleteH(-1, "word");
        },
        delWordAfter: function (cm) {
          cm.deleteH(1, "word");
        },
        delGroupBefore: function (cm) {
          cm.deleteH(-1, "group");
        },
        delGroupAfter: function (cm) {
          cm.deleteH(1, "group");
        },
        indentAuto: function (cm) {
          cm.indentSelection("smart");
        },
        indentMore: function (cm) {
          cm.indentSelection("add");
        },
        indentLess: function (cm) {
          cm.indentSelection("subtract");
        },
        insertTab: function (cm) {
          cm.replaceSelection("\t", "end", "+input");
        },
        defaultTab: function (cm) {
          if (cm.somethingSelected()) cm.indentSelection("add");else cm.replaceSelection("\t", "end", "+input");
        },
        transposeChars: function (cm) {
          var cur = cm.getCursor(),
              line = cm.getLine(cur.line);
          if (cur.ch > 0 && cur.ch < line.length - 1) cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
        },
        newlineAndIndent: function (cm) {
          operation(cm, function () {
            cm.replaceSelection("\n", "end", "+input");
            cm.indentLine(cm.getCursor().line, null, true);
          })();
        },
        toggleOverwrite: function (cm) {
          cm.toggleOverwrite();
        }
      };

      // STANDARD KEYMAPS

      var keyMap = CodeMirror.keyMap = {};
      keyMap.basic = {
        "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
        "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
        "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab", "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"
      };
      // Note that the save and find-related commands aren't defined by
      // default. Unknown commands are simply ignored.
      keyMap.pcDefault = {
        "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
        "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
        "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
        fallthrough: "basic"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
        "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
        "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",
        fallthrough: ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
      keyMap.emacsy = {
        "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
      };

      // KEYMAP DISPATCH

      function getKeyMap(val) {
        if (typeof val == "string") return keyMap[val];else return val;
      }

      function lookupKey(name, maps, handle) {
        function lookup(map) {
          map = getKeyMap(map);
          var found = map[name];
          if (found === false) return "stop";
          if (found != null && handle(found)) return true;
          if (map.nofallthrough) return "stop";

          var fallthrough = map.fallthrough;
          if (fallthrough == null) return false;
          if (Object.prototype.toString.call(fallthrough) != "[object Array]") return lookup(fallthrough);
          for (var i = 0, e = fallthrough.length; i < e; ++i) {
            var done = lookup(fallthrough[i]);
            if (done) return done;
          }
          return false;
        }

        for (var i = 0; i < maps.length; ++i) {
          var done = lookup(maps[i]);
          if (done) return done != "stop";
        }
      }
      function isModifierKey(event) {
        var name = keyNames[event.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
      }
      function keyName(event, noShift) {
        if (opera && event.keyCode == 34 && event["char"]) return false;
        var name = keyNames[event.keyCode];
        if (name == null || event.altGraphKey) return false;
        if (event.altKey) name = "Alt-" + name;
        if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
        if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
        if (!noShift && event.shiftKey) name = "Shift-" + name;
        return name;
      }
      CodeMirror.lookupKey = lookupKey;
      CodeMirror.isModifierKey = isModifierKey;
      CodeMirror.keyName = keyName;

      // FROMTEXTAREA

      CodeMirror.fromTextArea = function (textarea, options) {
        if (!options) options = {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabindex) options.tabindex = textarea.tabindex;
        if (!options.placeholder && textarea.placeholder) options.placeholder = textarea.placeholder;
        // Set autofocus to true if this textarea is focused, or if it has
        // autofocus and no other element is focused.
        if (options.autofocus == null) {
          var hasFocus = document.body;
          // doc.activeElement occasionally throws on IE
          try {
            hasFocus = document.activeElement;
          } catch (e) {}
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }

        function save() {
          textarea.value = cm.getValue();
        }
        if (textarea.form) {
          on(textarea.form, "submit", save);
          // Deplorable hack to make the submit method do the right thing.
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form,
                realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function () {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {}
          }
        }

        textarea.style.display = "none";
        var cm = CodeMirror(function (node) {
          textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        cm.save = save;
        cm.getTextArea = function () {
          return textarea;
        };
        cm.toTextArea = function () {
          save();
          textarea.parentNode.removeChild(cm.getWrapperElement());
          textarea.style.display = "";
          if (textarea.form) {
            off(textarea.form, "submit", save);
            if (typeof textarea.form.submit == "function") textarea.form.submit = realSubmit;
          }
        };
        return cm;
      };

      // STRING STREAM

      // Fed to the mode parsers, provides helper functions to make
      // parsers more succinct.

      // The character stream used by a mode's parser.
      function StringStream(string, tabSize) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
      }

      StringStream.prototype = {
        eol: function () {
          return this.pos >= this.string.length;
        },
        sol: function () {
          return this.pos == 0;
        },
        peek: function () {
          return this.string.charAt(this.pos) || undefined;
        },
        next: function () {
          if (this.pos < this.string.length) return this.string.charAt(this.pos++);
        },
        eat: function (match) {
          var ch = this.string.charAt(this.pos);
          if (typeof match == "string") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));
          if (ok) {
            ++this.pos;return ch;
          }
        },
        eatWhile: function (match) {
          var start = this.pos;
          while (this.eat(match)) {}
          return this.pos > start;
        },
        eatSpace: function () {
          var start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
          return this.pos > start;
        },
        skipToEnd: function () {
          this.pos = this.string.length;
        },
        skipTo: function (ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;return true;
          }
        },
        backUp: function (n) {
          this.pos -= n;
        },
        column: function () {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue;
        },
        indentation: function () {
          return countColumn(this.string, null, this.tabSize);
        },
        match: function (pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function (str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) this.pos += pattern.length;
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) return null;
            if (match && consume !== false) this.pos += match[0].length;
            return match;
          }
        },
        current: function () {
          return this.string.slice(this.start, this.pos);
        }
      };
      CodeMirror.StringStream = StringStream;

      // TEXTMARKERS

      function TextMarker(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
      }
      CodeMirror.TextMarker = TextMarker;
      eventMixin(TextMarker);

      TextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) return;
        var cm = this.doc.cm,
            withOp = cm && !cm.curOp;
        if (withOp) startOperation(cm);
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found) signalLater(this, "clear", found.from, found.to);
        }
        var min = null,
            max = null;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.to != null) max = lineNo(line);
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from != null) min = lineNo(line);else if (this.collapsed && !lineIsHidden(this.doc, line) && cm) updateLineHeight(line, textHeight(cm.display));
        }
        if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
          var visual = visualLine(cm.doc, this.lines[i]),
              len = lineLength(cm.doc, visual);
          if (len > cm.display.maxLineLength) {
            cm.display.maxLine = visual;
            cm.display.maxLineLength = len;
            cm.display.maxLineChanged = true;
          }
        }

        if (min != null && cm) regChange(cm, min, max + 1);
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm) reCheckSelection(cm);
        }
        if (withOp) endOperation(cm);
      };

      TextMarker.prototype.find = function () {
        var from, to;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.from != null || span.to != null) {
            var found = lineNo(line);
            if (span.from != null) from = Pos(found, span.from);
            if (span.to != null) to = Pos(found, span.to);
          }
        }
        if (this.type == "bookmark") return from;
        return from && { from: from, to: to };
      };

      TextMarker.prototype.changed = function () {
        var pos = this.find(),
            cm = this.doc.cm;
        if (!pos || !cm) return;
        if (this.type != "bookmark") pos = pos.from;
        var line = getLine(this.doc, pos.line);
        clearCachedMeasurement(cm, line);
        if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {
          for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {
            if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);
            break;
          }
          runInOp(cm, function () {
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;
          });
        }
      };

      TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(line);
      };
      TextMarker.prototype.detachLine = function (line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };

      function markText(doc, from, to, options, type) {
        if (options && options.shared) return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

        var marker = new TextMarker(doc, type);
        if (posLess(to, from) || posEq(from, to) && type == "range" && !(options.inclusiveLeft && options.inclusiveRight)) return marker;
        if (options) copyObj(options, marker);
        if (marker.replacedWith) {
          marker.collapsed = true;
          marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;
        }
        if (marker.collapsed) sawCollapsedSpans = true;

        if (marker.addToHistory) addToHistory(doc, { from: from, to: to, origin: "markText" }, { head: doc.sel.head, anchor: doc.sel.anchor }, NaN);

        var curLine = from.line,
            size = 0,
            collapsedAtStart,
            collapsedAtEnd,
            cm = doc.cm,
            updateMaxLine;
        doc.iter(curLine, to.line + 1, function (line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine) updateMaxLine = true;
          var span = { from: null, to: null, marker: marker };
          size += line.text.length;
          if (curLine == from.line) {
            span.from = from.ch;size -= from.ch;
          }
          if (curLine == to.line) {
            span.to = to.ch;size -= line.text.length - to.ch;
          }
          if (marker.collapsed) {
            if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);
            if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);else updateLineHeight(line, 0);
          }
          addMarkedSpan(line, span);
          ++curLine;
        });
        if (marker.collapsed) doc.iter(from.line, to.line + 1, function (line) {
          if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
        });

        if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function () {
          marker.clear();
        });

        if (marker.readOnly) {
          sawReadOnlySpans = true;
          if (doc.history.done.length || doc.history.undone.length) doc.clearHistory();
        }
        if (marker.collapsed) {
          if (collapsedAtStart != collapsedAtEnd) throw new Error("Inserting collapsed marker overlapping an existing one");
          marker.size = size;
          marker.atomic = true;
        }
        if (cm) {
          if (updateMaxLine) cm.curOp.updateMaxLine = true;
          if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed) regChange(cm, from.line, to.line + 1);
          if (marker.atomic) reCheckSelection(cm);
        }
        return marker;
      }

      // SHARED TEXTMARKERS

      function SharedTextMarker(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i = 0, me = this; i < markers.length; ++i) {
          markers[i].parent = this;
          on(markers[i], "clear", function () {
            me.clear();
          });
        }
      }
      CodeMirror.SharedTextMarker = SharedTextMarker;
      eventMixin(SharedTextMarker);

      SharedTextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) return;
        this.explicitlyCleared = true;
        for (var i = 0; i < this.markers.length; ++i) this.markers[i].clear();
        signalLater(this, "clear");
      };
      SharedTextMarker.prototype.find = function () {
        return this.primary.find();
      };

      function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type)],
            primary = markers[0];
        var widget = options.replacedWith;
        linkedDocs(doc, function (doc) {
          if (widget) options.replacedWith = widget.cloneNode(true);
          markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
          for (var i = 0; i < doc.linked.length; ++i) if (doc.linked[i].isParent) return;
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }

      // TEXTMARKER SPANS

      function getMarkedSpanFor(spans, marker) {
        if (spans) for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if (span.marker == marker) return span;
        }
      }
      function removeMarkedSpan(spans, span) {
        for (var r, i = 0; i < spans.length; ++i) if (spans[i] != span) (r || (r = [])).push(spans[i]);
        return r;
      }
      function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
      }

      function markedSpansBefore(old, startCh, isInsert) {
        if (old) for (var i = 0, nw; i < old.length; ++i) {
          var span = old[i],
              marker = span.marker;
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
          if (startsBefore || (marker.inclusiveLeft && marker.inclusiveRight || marker.type == "bookmark") && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
            (nw || (nw = [])).push({ from: span.from,
              to: endsAfter ? null : span.to,
              marker: marker });
          }
        }
        return nw;
      }

      function markedSpansAfter(old, endCh, isInsert) {
        if (old) for (var i = 0, nw; i < old.length; ++i) {
          var span = old[i],
              marker = span.marker;
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
          if (endsAfter || marker.type == "bookmark" && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
            (nw || (nw = [])).push({ from: startsBefore ? null : span.from - endCh,
              to: span.to == null ? null : span.to - endCh,
              marker: marker });
          }
        }
        return nw;
      }

      function stretchSpansOverChange(doc, change) {
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) return null;

        var startCh = change.from.ch,
            endCh = change.to.ch,
            isInsert = posEq(change.from, change.to);
        // Get the spans that 'stick out' on both sides
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);

        // Next, merge those two ends
        var sameLine = change.text.length == 1,
            offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          // Fix up .to properties of first
          for (var i = 0; i < first.length; ++i) {
            var span = first[i];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found) span.to = startCh;else if (sameLine) span.to = found.to == null ? null : found.to + offset;
            }
          }
        }
        if (last) {
          // Fix up .from in last (or move them into first in case of sameLine)
          for (var i = 0; i < last.length; ++i) {
            var span = last[i];
            if (span.to != null) span.to += offset;
            if (span.from == null) {
              var found = getMarkedSpanFor(first, span.marker);
              if (!found) {
                span.from = offset;
                if (sameLine) (first || (first = [])).push(span);
              }
            } else {
              span.from += offset;
              if (sameLine) (first || (first = [])).push(span);
            }
          }
        }
        if (sameLine && first) {
          // Make sure we didn't create any zero-length spans
          for (var i = 0; i < first.length; ++i) if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != "bookmark") first.splice(i--, 1);
          if (!first.length) first = null;
        }

        var newMarkers = [first];
        if (!sameLine) {
          // Fill gap with whole-line-spans
          var gap = change.text.length - 2,
              gapMarkers;
          if (gap > 0 && first) for (var i = 0; i < first.length; ++i) if (first[i].to == null) (gapMarkers || (gapMarkers = [])).push({ from: null, to: null, marker: first[i].marker });
          for (var i = 0; i < gap; ++i) newMarkers.push(gapMarkers);
          newMarkers.push(last);
        }
        return newMarkers;
      }

      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old) return stretched;
        if (!stretched) return old;

        for (var i = 0; i < old.length; ++i) {
          var oldCur = old[i],
              stretchCur = stretched[i];
          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k) if (oldCur[k].marker == span.marker) continue spans;
              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i] = stretchCur;
          }
        }
        return old;
      }

      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function (line) {
          if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
            var mark = line.markedSpans[i].marker;
            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) (markers || (markers = [])).push(mark);
          }
        });
        if (!markers) return null;
        var parts = [{ from: from, to: to }];
        for (var i = 0; i < markers.length; ++i) {
          var mk = markers[i],
              m = mk.find();
          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];
            if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;
            var newParts = [j, 1];
            if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from)) newParts.push({ from: p.from, to: m.from });
            if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to)) newParts.push({ from: m.to, to: p.to });
            parts.splice.apply(parts, newParts);
            j += newParts.length - 1;
          }
        }
        return parts;
      }

      function collapsedSpanAt(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;
        if (sps) for (var sp, i = 0; i < sps.length; ++i) {
          sp = sps[i];
          if (!sp.marker.collapsed) continue;
          if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width)) found = sp.marker;
        }
        return found;
      }
      function collapsedSpanAtStart(line) {
        return collapsedSpanAt(line, -1);
      }
      function collapsedSpanAtEnd(line) {
        return collapsedSpanAt(line, line.text.length + 1);
      }

      function visualLine(doc, line) {
        var merged;
        while (merged = collapsedSpanAtStart(line)) line = getLine(doc, merged.find().from.line);
        return line;
      }

      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) for (var sp, i = 0; i < sps.length; ++i) {
          sp = sps[i];
          if (!sp.marker.collapsed) continue;
          if (sp.from == null) return true;
          if (sp.marker.replacedWith) continue;
          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return true;
        }
      }
      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find().to,
              endLine = getLine(doc, end.line);
          return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length) return true;
        for (var sp, i = 0; i < line.markedSpans.length; ++i) {
          sp = line.markedSpans[i];
          if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return true;
        }
      }

      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans) return;
        for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
        line.markedSpans = null;
      }

      function attachMarkedSpans(line, spans) {
        if (!spans) return;
        for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
        line.markedSpans = spans;
      }

      // LINE WIDGETS

      var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
        if (options) for (var opt in options) if (options.hasOwnProperty(opt)) this[opt] = options[opt];
        this.cm = cm;
        this.node = node;
      };
      eventMixin(LineWidget);
      function widgetOperation(f) {
        return function () {
          var withOp = !this.cm.curOp;
          if (withOp) startOperation(this.cm);
          try {
            var result = f.apply(this, arguments);
          } finally {
            if (withOp) endOperation(this.cm);
          }
          return result;
        };
      }
      LineWidget.prototype.clear = widgetOperation(function () {
        var ws = this.line.widgets,
            no = lineNo(this.line);
        if (no == null || !ws) return;
        for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
        if (!ws.length) this.line.widgets = null;
        var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;
        updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
        if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);
        regChange(this.cm, no, no + 1);
      });
      LineWidget.prototype.changed = widgetOperation(function () {
        var oldH = this.height;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff) return;
        updateLineHeight(this.line, this.line.height + diff);
        var no = lineNo(this.line);
        regChange(this.cm, no, no + 1);
      });

      function widgetHeight(widget) {
        if (widget.height != null) return widget.height;
        if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1) removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
        return widget.height = widget.node.offsetHeight;
      }

      function addLineWidget(cm, handle, node, options) {
        var widget = new LineWidget(cm, node, options);
        if (widget.noHScroll) cm.display.alignWidgets = true;
        changeLine(cm, handle, function (line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null) widgets.push(widget);else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
          widget.line = line;
          if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
            var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible) addToScrollPos(cm, 0, widget.height);
          }
          return true;
        });
        return widget;
      }

      // LINE DATA STRUCTURE

      // Line objects. These hold state related to a line, including
      // highlighting info (the styles array).
      var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
      };
      eventMixin(Line);
      Line.prototype.lineNo = function () {
        return lineNo(this);
      };

      function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter) line.stateAfter = null;
        if (line.styles) line.styles = null;
        if (line.order != null) line.order = null;
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height) updateLineHeight(line, estHeight);
      }

      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }

      // Run the given mode's parser over a line, update the styles
      // array, which contains alternating fragments of text and CSS
      // classes.
      function runMode(cm, text, mode, state, f, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
        var curStart = 0,
            curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize),
            style;
        if (text == "" && mode.blankLine) mode.blankLine(state);
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd) processLine(cm, text, state, stream.pos);
            stream.pos = text.length;
            style = null;
          } else {
            style = mode.token(stream, state);
          }
          if (!flattenSpans || curStyle != style) {
            if (curStart < stream.start) f(stream.start, curStyle);
            curStart = stream.start;curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          // Webkit seems to refuse to render text nodes longer than 57444 characters
          var pos = Math.min(stream.pos, curStart + 50000);
          f(pos, curStyle);
          curStart = pos;
        }
      }

      function highlightLine(cm, line, state, forceToEnd) {
        // A styles array always starts with a number identifying the
        // mode/overlays that it is based on (for easy invalidation).
        var st = [cm.state.modeGen];
        // Compute the base array of styles
        runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
          st.push(end, style);
        }, forceToEnd);

        // Run overlays, adjust style array.
        for (var o = 0; o < cm.state.overlays.length; ++o) {
          var overlay = cm.state.overlays[o],
              i = 1,
              at = 0;
          runMode(cm, line.text, overlay.mode, true, function (end, style) {
            var start = i;
            // Ensure there's a token end at the current position, and that i points at it
            while (at < end) {
              var i_end = st[i];
              if (i_end > end) st.splice(i, 1, end, st[i + 1], i_end);
              i += 2;
              at = Math.min(end, i_end);
            }
            if (!style) return;
            if (overlay.opaque) {
              st.splice(start, i - start, end, style);
              i = start + 2;
            } else {
              for (; start < i; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = cur ? cur + " " + style : style;
              }
            }
          });
        }

        return st;
      }

      function getLineStyles(cm, line) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
        return line.styles;
      }

      // Lightweight form of highlight -- proceed over this line and
      // update state, but don't save a style array.
      function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize);
        stream.start = stream.pos = startAt || 0;
        if (text == "" && mode.blankLine) mode.blankLine(state);
        while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
          mode.token(stream, state);
          stream.start = stream.pos;
        }
      }

      var styleToClassCache = {};
      function interpretTokenStyle(style, builder) {
        if (!style) return null;
        for (;;) {
          var lineClass = style.match(/(?:^|\s)line-(background-)?(\S+)/);
          if (!lineClass) break;
          style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);
          var prop = lineClass[1] ? "bgClass" : "textClass";
          if (builder[prop] == null) builder[prop] = lineClass[2];else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(builder[prop])) builder[prop] += " " + lineClass[2];
        }
        return styleToClassCache[style] || (styleToClassCache[style] = "cm-" + style.replace(/ +/g, " cm-"));
      }

      function buildLineContent(cm, realLine, measure, copyWidgets) {
        var merged,
            line = realLine,
            empty = true;
        while (merged = collapsedSpanAtStart(line)) line = getLine(cm.doc, merged.find().from.line);

        var builder = { pre: elt("pre"), col: 0, pos: 0,
          measure: null, measuredSomething: false, cm: cm,
          copyWidgets: copyWidgets };

        do {
          if (line.text) empty = false;
          builder.measure = line == realLine && measure;
          builder.pos = 0;
          builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
          if ((ie || webkit) && cm.getOption("lineWrapping")) builder.addToken = buildTokenSplitSpaces(builder.addToken);
          var next = insertLineContent(line, builder, getLineStyles(cm, line));
          if (measure && line == realLine && !builder.measuredSomething) {
            measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
            builder.measuredSomething = true;
          }
          if (next) line = getLine(cm.doc, next.to.line);
        } while (next);

        if (measure && !builder.measuredSomething && !measure[0]) measure[0] = builder.pre.appendChild(empty ? elt("span", "\u00a0") : zeroWidthElement(cm.display.measure));
        if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine)) builder.pre.appendChild(document.createTextNode("\u00a0"));

        var order;
        // Work around problem with the reported dimensions of single-char
        // direction spans on IE (issue #1129). See also the comment in
        // cursorCoords.
        if (measure && (ie || ie_gt10) && (order = getOrder(line))) {
          var l = order.length - 1;
          if (order[l].from == order[l].to) --l;
          var last = order[l],
              prev = order[l - 1];
          if (last.from + 1 == last.to && prev && last.level < prev.level) {
            var span = measure[builder.pos - 1];
            if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
          }
        }

        var textClass = builder.textClass ? builder.textClass + " " + (realLine.textClass || "") : realLine.textClass;
        if (textClass) builder.pre.className = textClass;

        signal(cm, "renderLine", cm, realLine, builder.pre);
        return builder;
      }

      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        return token;
      }

      function buildToken(builder, text, style, startStyle, endStyle, title) {
        if (!text) return;
        var special = builder.cm.options.specialChars;
        if (!special.test(text)) {
          builder.col += text.length;
          var content = document.createTextNode(text);
        } else {
          var content = document.createDocumentFragment(),
              pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;
            if (skipped) {
              content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
              builder.col += skipped;
            }
            if (!m) break;
            pos += skipped + 1;
            if (m[0] == "\t") {
              var tabSize = builder.cm.options.tabSize,
                  tabWidth = tabSize - builder.col % tabSize;
              content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              builder.col += tabWidth;
            } else {
              var token = builder.cm.options.specialCharPlaceholder(m[0]);
              content.appendChild(token);
              builder.col += 1;
            }
          }
        }
        if (style || startStyle || endStyle || builder.measure) {
          var fullStyle = style || "";
          if (startStyle) fullStyle += startStyle;
          if (endStyle) fullStyle += endStyle;
          var token = elt("span", [content], fullStyle);
          if (title) token.title = title;
          return builder.pre.appendChild(token);
        }
        builder.pre.appendChild(content);
      }

      function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
        var wrapping = builder.cm.options.lineWrapping;
        for (var i = 0; i < text.length; ++i) {
          var ch = text.charAt(i),
              start = i == 0;
          if (ch >= "\ud800" && ch < "\udbff" && i < text.length - 1) {
            ch = text.slice(i, i + 2);
            ++i;
          } else if (i && wrapping && spanAffectsWrapping(text, i)) {
            builder.pre.appendChild(elt("wbr"));
          }
          var old = builder.measure[builder.pos];
          var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
          if (old) span.leftSide = old.leftSide || old;
          // In IE single-space nodes wrap differently than spaces
          // embedded in larger text nodes, except when set to
          // white-space: normal (issue #1268).
          if (ie && wrapping && ch == " " && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1))) span.style.whiteSpace = "normal";
          builder.pos += ch.length;
        }
        if (text.length) builder.measuredSomething = true;
      }

      function buildTokenSplitSpaces(inner) {
        function split(old) {
          var out = " ";
          for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
          out += " ";
          return out;
        }
        return function (builder, text, style, startStyle, endStyle, title) {
          return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
        };
      }

      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.replacedWith;
        if (widget) {
          if (builder.copyWidgets) widget = widget.cloneNode(true);
          builder.pre.appendChild(widget);
          if (builder.measure) {
            if (size) {
              builder.measure[builder.pos] = widget;
            } else {
              var elt = zeroWidthElement(builder.cm.display.measure);
              if (marker.type == "bookmark" && !marker.insertLeft) builder.measure[builder.pos] = builder.pre.appendChild(elt);else if (builder.measure[builder.pos]) return;else builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);
            }
            builder.measuredSomething = true;
          }
        }
        builder.pos += size;
      }

      // Outputs a number of spans to make up a line, taking highlighting
      // and marked text into account.
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans,
            allText = line.text,
            at = 0;
        if (!spans) {
          for (var i = 1; i < styles.length; i += 2) builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder));
          return;
        }

        var len = allText.length,
            pos = 0,
            i = 1,
            text = "",
            style;
        var nextChange = 0,
            spanStyle,
            spanEndStyle,
            spanStartStyle,
            title,
            collapsed;
        for (;;) {
          if (nextChange == pos) {
            // Update current marker set
            spanStyle = spanEndStyle = spanStartStyle = title = "";
            collapsed = null;nextChange = Infinity;
            var foundBookmarks = [];
            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j],
                  m = sp.marker;
              if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
                if (sp.to != null && nextChange > sp.to) {
                  nextChange = sp.to;spanEndStyle = "";
                }
                if (m.className) spanStyle += " " + m.className;
                if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
                if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
                if (m.title && !title) title = m.title;
                if (m.collapsed && (!collapsed || collapsed.marker.size < m.size)) collapsed = sp;
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
              if (m.type == "bookmark" && sp.from == pos && m.replacedWith) foundBookmarks.push(m);
            }
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
              if (collapsed.to == null) return collapsed.marker.find();
            }
            if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j) buildCollapsedSpan(builder, 0, foundBookmarks[j]);
          }
          if (pos >= len) break;

          var upto = Math.min(len, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);
              }
              if (end >= upto) {
                text = text.slice(upto - pos);pos = upto;break;
              }
              pos = end;
              spanStartStyle = "";
            }
            text = allText.slice(at, at = styles[i++]);
            style = interpretTokenStyle(styles[i++], builder);
          }
        }
      }

      // DOCUMENT DATA STRUCTURE

      function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
          updateLine(line, text, spans, estimateHeight);
          signalLater(line, "change", line, change);
        }

        var from = change.from,
            to = change.to,
            text = change.text;
        var firstLine = getLine(doc, from.line),
            lastLine = getLine(doc, to.line);
        var lastText = lst(text),
            lastSpans = spansFor(text.length - 1),
            nlines = to.line - from.line;

        // First adjust the line structure
        if (from.ch == 0 && to.ch == 0 && lastText == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore)) {
          // This is a whole-line replace. Treated specially to make
          // sure line objects move the way they are supposed to.
          for (var i = 0, e = text.length - 1, added = []; i < e; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
          update(lastLine, lastLine.text, lastSpans);
          if (nlines) doc.remove(from.line, nlines);
          if (added.length) doc.insert(from.line, added);
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            for (var added = [], i = 1, e = text.length - 1; i < e; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
            added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc.insert(from.line + 1, added);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          for (var i = 1, e = text.length - 1, added = []; i < e; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
          if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
          doc.insert(from.line + 1, added);
        }

        signalLater(doc, "change", doc, change);
        setSelection(doc, selAfter.anchor, selAfter.head, null, true);
      }

      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
          lines[i].parent = this;
          height += lines[i].height;
        }
        this.height = height;
      }

      LeafChunk.prototype = {
        chunkSize: function () {
          return this.lines.length;
        },
        removeInner: function (at, n) {
          for (var i = at, e = at + n; i < e; ++i) {
            var line = this.lines[i];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n);
        },
        collapse: function (lines) {
          lines.splice.apply(lines, [lines.length, 0].concat(this.lines));
        },
        insertInner: function (at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;
        },
        iterN: function (at, n, op) {
          for (var e = at + n; at < e; ++at) if (op(this.lines[at])) return true;
        }
      };

      function BranchChunk(children) {
        this.children = children;
        var size = 0,
            height = 0;
        for (var i = 0, e = children.length; i < e; ++i) {
          var ch = children[i];
          size += ch.chunkSize();height += ch.height;
          ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }

      BranchChunk.prototype = {
        chunkSize: function () {
          return this.size;
        },
        removeInner: function (at, n) {
          this.size -= n;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n, sz - at),
                  oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;
              if (sz == rm) {
                this.children.splice(i--, 1);child.parent = null;
              }
              if ((n -= rm) == 0) break;
              at = 0;
            } else at -= sz;
          }
          if (this.size - n < 25) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function (lines) {
          for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);
        },
        insertInner: function (at, lines, height) {
          this.size += lines.length;
          this.height += height;
          for (var i = 0, e = this.children.length; i < e; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                while (child.lines.length > 50) {
                  var spilled = child.lines.splice(child.lines.length - 25, 25);
                  var newleaf = new LeafChunk(spilled);
                  child.height -= newleaf.height;
                  this.children.splice(i + 1, 0, newleaf);
                  newleaf.parent = this;
                }
                this.maybeSpill();
              }
              break;
            }
            at -= sz;
          }
        },
        maybeSpill: function () {
          if (this.children.length <= 10) return;
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) {
              // Become the parent node
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10);
          me.parent.maybeSpill();
        },
        iterN: function (at, n, op) {
          for (var i = 0, e = this.children.length; i < e; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n, sz - at);
              if (child.iterN(at, used, op)) return true;
              if ((n -= used) == 0) break;
              at = 0;
            } else at -= sz;
          }
        }
      };

      var nextDocId = 0;
      var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
        if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
        if (firstLine == null) firstLine = 0;

        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.history = makeHistory();
        this.cleanGeneration = 1;
        this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = { from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null };
        this.id = ++nextDocId;
        this.modeOption = mode;

        if (typeof text == "string") text = splitLines(text);
        updateDoc(this, { from: start, to: start, text: text }, null, { head: start, anchor: start });
      };

      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function (from, to, op) {
          if (op) this.iterN(from - this.first, to - from, op);else this.iterN(this.first, this.first + this.size, from);
        },

        insert: function (at, lines) {
          var height = 0;
          for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;
          this.insertInner(at - this.first, lines, height);
        },
        remove: function (at, n) {
          this.removeInner(at - this.first, n);
        },

        getValue: function (lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false) return lines;
          return lines.join(lineSep || "\n");
        },
        setValue: function (code) {
          var top = Pos(this.first, 0),
              last = this.first + this.size - 1;
          makeChange(this, { from: top, to: Pos(last, getLine(this, last).text.length),
            text: splitLines(code), origin: "setValue" }, { head: top, anchor: top }, true);
        },
        replaceRange: function (code, from, to, origin) {
          from = clipPos(this, from);
          to = to ? clipPos(this, to) : from;
          replaceRange(this, code, from, to, origin);
        },
        getRange: function (from, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
          if (lineSep === false) return lines;
          return lines.join(lineSep || "\n");
        },

        getLine: function (line) {
          var l = this.getLineHandle(line);return l && l.text;
        },
        setLine: function (line, text) {
          if (isLine(this, line)) replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
        },
        removeLine: function (line) {
          if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));
        },

        getLineHandle: function (line) {
          if (isLine(this, line)) return getLine(this, line);
        },
        getLineNumber: function (line) {
          return lineNo(line);
        },

        getLineHandleVisualStart: function (line) {
          if (typeof line == "number") line = getLine(this, line);
          return visualLine(this, line);
        },

        lineCount: function () {
          return this.size;
        },
        firstLine: function () {
          return this.first;
        },
        lastLine: function () {
          return this.first + this.size - 1;
        },

        clipPos: function (pos) {
          return clipPos(this, pos);
        },

        getCursor: function (start) {
          var sel = this.sel,
              pos;
          if (start == null || start == "head") pos = sel.head;else if (start == "anchor") pos = sel.anchor;else if (start == "end" || start === false) pos = sel.to;else pos = sel.from;
          return copyPos(pos);
        },
        somethingSelected: function () {
          return !posEq(this.sel.head, this.sel.anchor);
        },

        setCursor: docOperation(function (line, ch, extend) {
          var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);
          if (extend) extendSelection(this, pos);else setSelection(this, pos, pos);
        }),
        setSelection: docOperation(function (anchor, head, bias) {
          setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);
        }),
        extendSelection: docOperation(function (from, to, bias) {
          extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);
        }),

        getSelection: function (lineSep) {
          return this.getRange(this.sel.from, this.sel.to, lineSep);
        },
        replaceSelection: function (code, collapse, origin) {
          makeChange(this, { from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin }, collapse || "around");
        },
        undo: docOperation(function () {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docOperation(function () {
          makeChangeFromHistory(this, "redo");
        }),

        setExtending: function (val) {
          this.sel.extend = val;
        },

        historySize: function () {
          var hist = this.history;
          return { undo: hist.done.length, redo: hist.undone.length };
        },
        clearHistory: function () {
          this.history = makeHistory(this.history.maxGeneration);
        },

        markClean: function () {
          this.cleanGeneration = this.changeGeneration();
        },
        changeGeneration: function () {
          this.history.lastOp = this.history.lastOrigin = null;
          return this.history.generation;
        },
        isClean: function (gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },

        getHistory: function () {
          return { done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone) };
        },
        setHistory: function (histData) {
          var hist = this.history = makeHistory(this.history.maxGeneration);
          hist.done = histData.done.slice(0);
          hist.undone = histData.undone.slice(0);
        },

        markText: function (from, to, options) {
          return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
        },
        setBookmark: function (pos, options) {
          var realOpts = { replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft };
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function (pos) {
          pos = clipPos(this, pos);
          var markers = [],
              spans = getLine(this, pos.line).markedSpans;
          if (spans) for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) markers.push(span.marker.parent || span.marker);
          }
          return markers;
        },
        getAllMarks: function () {
          var markers = [];
          this.iter(function (line) {
            var sps = line.markedSpans;
            if (sps) for (var i = 0; i < sps.length; ++i) if (sps[i].from != null) markers.push(sps[i].marker);
          });
          return markers;
        },

        posFromIndex: function (off) {
          var ch,
              lineNo = this.first;
          this.iter(function (line) {
            var sz = line.text.length + 1;
            if (sz > off) {
              ch = off;return true;
            }
            off -= sz;
            ++lineNo;
          });
          return clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function (coords) {
          coords = clipPos(this, coords);
          var index = coords.ch;
          if (coords.line < this.first || coords.ch < 0) return 0;
          this.iter(this.first, coords.line, function (line) {
            index += line.text.length + 1;
          });
          return index;
        },

        copy: function (copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
          doc.scrollTop = this.scrollTop;doc.scrollLeft = this.scrollLeft;
          doc.sel = { from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,
            shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn };
          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }
          return doc;
        },

        linkedDoc: function (options) {
          if (!options) options = {};
          var from = this.first,
              to = this.first + this.size;
          if (options.from != null && options.from > from) from = options.from;
          if (options.to != null && options.to < to) to = options.to;
          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
          if (options.sharedHist) copy.history = this.history;
          (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
          copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
          return copy;
        },
        unlinkDoc: function (other) {
          if (other instanceof CodeMirror) other = other.doc;
          if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
            var link = this.linked[i];
            if (link.doc != other) continue;
            this.linked.splice(i, 1);
            other.unlinkDoc(this);
            break;
          }
          // If the histories were shared, split them again
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function (doc) {
              splitIds.push(doc.id);
            }, true);
            other.history = makeHistory();
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function (f) {
          linkedDocs(this, f);
        },

        getMode: function () {
          return this.mode;
        },
        getEditor: function () {
          return this.cm;
        }
      });

      Doc.prototype.eachLine = Doc.prototype.iter;

      // The Doc methods that should be available on CodeMirror instances
      var dontDelegate = "iter insert remove copy getEditor".split(" ");
      for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);

      eventMixin(Doc);

      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
          if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
            var rel = doc.linked[i];
            if (rel.doc == skip) continue;
            var shared = sharedHist && rel.sharedHist;
            if (sharedHistOnly && !shared) continue;
            f(rel.doc, shared);
            propagate(rel.doc, doc, shared);
          }
        }
        propagate(doc, null, true);
      }

      function attachDoc(cm, doc) {
        if (doc.cm) throw new Error("This document is already in use.");
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        if (!cm.options.lineWrapping) computeMaxLength(cm);
        cm.options.mode = doc.modeOption;
        regChange(cm);
      }

      // LINE UTILITIES

      function getLine(chunk, n) {
        n -= chunk.first;
        while (!chunk.lines) {
          for (var i = 0;; ++i) {
            var child = chunk.children[i],
                sz = child.chunkSize();
            if (n < sz) {
              chunk = child;break;
            }
            n -= sz;
          }
        }
        return chunk.lines[n];
      }

      function getBetween(doc, start, end) {
        var out = [],
            n = start.line;
        doc.iter(start.line, end.line + 1, function (line) {
          var text = line.text;
          if (n == end.line) text = text.slice(0, end.ch);
          if (n == start.line) text = text.slice(start.ch);
          out.push(text);
          ++n;
        });
        return out;
      }
      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function (line) {
          out.push(line.text);
        });
        return out;
      }

      function updateLineHeight(line, height) {
        var diff = height - line.height;
        for (var n = line; n; n = n.parent) n.height += diff;
      }

      function lineNo(line) {
        if (line.parent == null) return null;
        var cur = line.parent,
            no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i = 0;; ++i) {
            if (chunk.children[i] == cur) break;
            no += chunk.children[i].chunkSize();
          }
        }
        return no + cur.first;
      }

      function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
          for (var i = 0, e = chunk.children.length; i < e; ++i) {
            var child = chunk.children[i],
                ch = child.height;
            if (h < ch) {
              chunk = child;continue outer;
            }
            h -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
        for (var i = 0, e = chunk.lines.length; i < e; ++i) {
          var line = chunk.lines[i],
              lh = line.height;
          if (h < lh) break;
          h -= lh;
        }
        return n + i;
      }

      function heightAtLine(cm, lineObj) {
        lineObj = visualLine(cm.doc, lineObj);

        var h = 0,
            chunk = lineObj.parent;
        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i];
          if (line == lineObj) break;else h += line.height;
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i = 0; i < p.children.length; ++i) {
            var cur = p.children[i];
            if (cur == chunk) break;else h += cur.height;
          }
        }
        return h;
      }

      function getOrder(line) {
        var order = line.order;
        if (order == null) order = line.order = bidiOrdering(line.text);
        return order;
      }

      // HISTORY

      function makeHistory(startGen) {
        return {
          // Arrays of history events. Doing something adds an event to
          // done and clears undo. Undoing moves events from done to
          // undone, redoing moves them in the other direction.
          done: [], undone: [], undoDepth: Infinity,
          // Used to track when changes can be merged into a single undo
          // event
          lastTime: 0, lastOp: null, lastOrigin: null,
          // Used by the isClean() method
          generation: startGen || 1, maxGeneration: startGen || 1
        };
      }

      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id],
            n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
          if (line.markedSpans) (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
          ++n;
        });
      }

      function historyChangeFromChange(doc, change) {
        var from = { line: change.from.line, ch: change.from.ch };
        var histChange = { from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function (doc) {
          attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      }

      function addToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date(),
            cur = lst(hist.done);

        if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == "*"))) {
          // Merge this change into the last event
          var last = lst(cur.changes);
          if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
            // Optimized case for simple insertion -- don't want to add
            // new changesets for every character typed
            last.to = changeEnd(change);
          } else {
            // Add new sub-event
            cur.changes.push(historyChangeFromChange(doc, change));
          }
          cur.anchorAfter = selAfter.anchor;cur.headAfter = selAfter.head;
        } else {
          // Can not be merged, start a new event.
          cur = { changes: [historyChangeFromChange(doc, change)],
            generation: hist.generation,
            anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,
            anchorAfter: selAfter.anchor, headAfter: selAfter.head };
          hist.done.push(cur);
          hist.generation = ++hist.maxGeneration;
          while (hist.done.length > hist.undoDepth) hist.done.shift();
        }
        hist.lastTime = time;
        hist.lastOp = opId;
        hist.lastOrigin = change.origin;
      }

      function removeClearedSpans(spans) {
        if (!spans) return null;
        for (var i = 0, out; i < spans.length; ++i) {
          if (spans[i].marker.explicitlyCleared) {
            if (!out) out = spans.slice(0, i);
          } else if (out) out.push(spans[i]);
        }
        return !out ? spans : out.length ? out : null;
      }

      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found) return null;
        for (var i = 0, nw = []; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
        return nw;
      }

      // Used both to provide a JSON-safe object in .getHistory, and, when
      // detaching a document, to split the history in two
      function copyHistoryArray(events, newGroup) {
        for (var i = 0, copy = []; i < events.length; ++i) {
          var event = events[i],
              changes = event.changes,
              newChanges = [];
          copy.push({ changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,
            anchorAfter: event.anchorAfter, headAfter: event.headAfter });
          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j],
                m;
            newChanges.push({ from: change.from, to: change.to, text: change.text });
            if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
        return copy;
      }

      // Rebasing/resetting history to deal with externally-sourced changes

      function rebaseHistSel(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      }

      // Tries to rebase an array of history events given a change in the
      // document. If the change touches the same lines as the event, the
      // event, and everything 'behind' it, is discarded. If the change is
      // before the event, the event's positions are updated. Uses a
      // copy-on-write scheme for the positions, to avoid having to
      // reallocate them all on every rebase, but also avoid problems with
      // shared position objects being unsafely updated.
      function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i],
              ok = true;
          for (var j = 0; j < sub.changes.length; ++j) {
            var cur = sub.changes[j];
            if (!sub.copied) {
              cur.from = copyPos(cur.from);cur.to = copyPos(cur.to);
            }
            if (to < cur.from.line) {
              cur.from.line += diff;
              cur.to.line += diff;
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }
          if (!sub.copied) {
            sub.anchorBefore = copyPos(sub.anchorBefore);sub.headBefore = copyPos(sub.headBefore);
            sub.anchorAfter = copyPos(sub.anchorAfter);sub.readAfter = copyPos(sub.headAfter);
            sub.copied = true;
          }
          if (!ok) {
            array.splice(0, i + 1);
            i = 0;
          } else {
            rebaseHistSel(sub.anchorBefore);rebaseHistSel(sub.headBefore);
            rebaseHistSel(sub.anchorAfter);rebaseHistSel(sub.headAfter);
          }
        }
      }

      function rebaseHist(hist, change) {
        var from = change.from.line,
            to = change.to.line,
            diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      }

      // EVENT OPERATORS

      function stopMethod() {
        e_stop(this);
      }
      // Ensure an event has a stop method.
      function addStop(event) {
        if (!event.stop) event.stop = stopMethod;
        return event;
      }

      function e_preventDefault(e) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      function e_stopPropagation(e) {
        if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
      }
      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }
      function e_stop(e) {
        e_preventDefault(e);e_stopPropagation(e);
      }
      CodeMirror.e_stop = e_stop;
      CodeMirror.e_preventDefault = e_preventDefault;
      CodeMirror.e_stopPropagation = e_stopPropagation;

      function e_target(e) {
        return e.target || e.srcElement;
      }
      function e_button(e) {
        var b = e.which;
        if (b == null) {
          if (e.button & 1) b = 1;else if (e.button & 2) b = 3;else if (e.button & 4) b = 2;
        }
        if (mac && e.ctrlKey && b == 1) b = 3;
        return b;
      }

      // EVENT HANDLING

      function on(emitter, type, f) {
        if (emitter.addEventListener) emitter.addEventListener(type, f, false);else if (emitter.attachEvent) emitter.attachEvent("on" + type, f);else {
          var map = emitter._handlers || (emitter._handlers = {});
          var arr = map[type] || (map[type] = []);
          arr.push(f);
        }
      }

      function off(emitter, type, f) {
        if (emitter.removeEventListener) emitter.removeEventListener(type, f, false);else if (emitter.detachEvent) emitter.detachEvent("on" + type, f);else {
          var arr = emitter._handlers && emitter._handlers[type];
          if (!arr) return;
          for (var i = 0; i < arr.length; ++i) if (arr[i] == f) {
            arr.splice(i, 1);break;
          }
        }
      }

      function signal(emitter, type /*, values...*/) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr) return;
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
      }

      var delayedCallbacks,
          delayedCallbackDepth = 0;
      function signalLater(emitter, type /*, values...*/) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr) return;
        var args = Array.prototype.slice.call(arguments, 2);
        if (!delayedCallbacks) {
          ++delayedCallbackDepth;
          delayedCallbacks = [];
          setTimeout(fireDelayed, 0);
        }
        function bnd(f) {
          return function () {
            f.apply(null, args);
          };
        };
        for (var i = 0; i < arr.length; ++i) delayedCallbacks.push(bnd(arr[i]));
      }

      function signalDOMEvent(cm, e, override) {
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }

      function fireDelayed() {
        --delayedCallbackDepth;
        var delayed = delayedCallbacks;
        delayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i) delayed[i]();
      }

      function hasHandler(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        return arr && arr.length > 0;
      }

      CodeMirror.on = on;CodeMirror.off = off;CodeMirror.signal = signal;

      function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
          on(this, type, f);
        };
        ctor.prototype.off = function (type, f) {
          off(this, type, f);
        };
      }

      // MISC UTILITIES

      // Number of pixels added to scroller and sizer to hide scrollbar
      var scrollerCutOff = 30;

      // Returned or thrown by various protocols to signal 'I'm not
      // handling this'.
      var Pass = CodeMirror.Pass = { toString: function () {
          return "CodeMirror.Pass";
        } };

      function Delayed() {
        this.id = null;
      }
      Delayed.prototype = { set: function (ms, f) {
          clearTimeout(this.id);this.id = setTimeout(f, ms);
        } };

      // Counts the column offset in a string, taking tabs into account.
      // Used mostly to find indentation.
      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1) end = string.length;
        }
        for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
          if (string.charAt(i) == "\t") n += tabSize - n % tabSize;else ++n;
        }
        return n;
      }
      CodeMirror.countColumn = countColumn;

      var spaceStrs = [""];
      function spaceStr(n) {
        while (spaceStrs.length <= n) spaceStrs.push(lst(spaceStrs) + " ");
        return spaceStrs[n];
      }

      function lst(arr) {
        return arr[arr.length - 1];
      }

      function selectInput(node) {
        if (ios) {
          // Mobile Safari apparently has a bug where select() is broken.
          node.selectionStart = 0;
          node.selectionEnd = node.value.length;
        } else {
          // Suppress mysterious IE10 errors
          try {
            node.select();
          } catch (_e) {}
        }
      }

      function indexOf(collection, elt) {
        if (collection.indexOf) return collection.indexOf(elt);
        for (var i = 0, e = collection.length; i < e; ++i) if (collection[i] == elt) return i;
        return -1;
      }

      function createObj(base, props) {
        function Obj() {}
        Obj.prototype = base;
        var inst = new Obj();
        if (props) copyObj(props, inst);
        return inst;
      }

      function copyObj(obj, target) {
        if (!target) target = {};
        for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
        return target;
      }

      function emptyArray(size) {
        for (var a = [], i = 0; i < size; ++i) a.push(undefined);
        return a;
      }

      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
          return f.apply(null, args);
        };
      }

      var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function isWordChar(ch) {
        return (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
        );
      }

      function isEmpty(obj) {
        for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
        return true;
      }

      var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\u1DC0\u1DFF\u20D0\u20FF\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff\uFE20\uFE2F]/;

      // DOM UTILITIES

      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) e.className = className;
        if (style) e.style.cssText = style;
        if (typeof content == "string") setTextContent(e, content);else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
        return e;
      }

      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
        return e;
      }

      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
      }

      function setTextContent(e, str) {
        if (ie_lt9) {
          e.innerHTML = "";
          e.appendChild(document.createTextNode(str));
        } else e.textContent = str;
      }

      function getRect(node) {
        return node.getBoundingClientRect();
      }
      CodeMirror.replaceGetRect = function (f) {
        getRect = f;
      };

      // FEATURE DETECTION

      // Detect drag-and-drop
      var dragAndDrop = function () {
        // There is *some* kind of drag-and-drop support in IE6-8, but I
        // couldn't get it to work yet.
        if (ie_lt9) return false;
        var div = elt('div');
        return "draggable" in div || "dragDrop" in div;
      }();

      // For a reason I have yet to figure out, some browsers disallow
      // word wrapping between certain characters *only* if a new inline
      // element is started between them. This makes it hard to reliably
      // measure the position of things, since that requires inserting an
      // extra span. This terribly fragile set of tests matches the
      // character combinations that suffer from this phenomenon on the
      // various browsers.
      function spanAffectsWrapping() {
        return false;
      }
      if (gecko) // Only for "$'"
        spanAffectsWrapping = function (str, i) {
          return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;
        };else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent)) spanAffectsWrapping = function (str, i) {
        return (/\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1))
        );
      };else if (webkit && /Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent)) spanAffectsWrapping = function (str, i) {
        var code = str.charCodeAt(i - 1);
        return code >= 8208 && code <= 8212;
      };else if (webkit) spanAffectsWrapping = function (str, i) {
        if (i > 1 && str.charCodeAt(i - 1) == 45) {
          if (/\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i))) return true;
          if (i > 2 && /[\d\.,]/.test(str.charAt(i - 2)) && /[\d\.,]/.test(str.charAt(i))) return false;
        }
        return (/[~!#%&*)=+}\]\\|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1))
        );
      };

      var knownScrollbarWidth;
      function scrollbarWidth(measure) {
        if (knownScrollbarWidth != null) return knownScrollbarWidth;
        var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
        removeChildrenAndAdd(measure, test);
        if (test.offsetWidth) knownScrollbarWidth = test.offsetHeight - test.clientHeight;
        return knownScrollbarWidth || 0;
      }

      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200b");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0) zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
        }
        if (zwspSupported) return elt("span", "\u200b");else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
      }

      // See if "".split is the broken IE version, if so, provide an
      // alternative way to split lines.
      var splitLines = "\n\nb".split(/\n/).length != 3 ? function (string) {
        var pos = 0,
            result = [],
            l = string.length;
        while (pos <= l) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1) nl = string.length;
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result;
      } : function (string) {
        return string.split(/\r\n?|\n/);
      };
      CodeMirror.splitLines = splitLines;

      var hasSelection = window.getSelection ? function (te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function (te) {
        try {
          var range = te.ownerDocument.selection.createRange();
        } catch (e) {}
        if (!range || range.parentElement() != te) return false;
        return range.compareEndPoints("StartToEnd", range) != 0;
      };

      var hasCopyEvent = function () {
        var e = elt("div");
        if ("oncopy" in e) return true;
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == 'function';
      }();

      // KEY NAMING

      var keyNames = { 3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
        19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
        36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
        46: "Delete", 59: ";", 91: "Mod", 92: "Mod", 93: "Mod", 109: "-", 107: "=", 127: "Delete",
        186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
        221: "]", 222: "'", 63276: "PageUp", 63277: "PageDown", 63275: "End", 63273: "Home",
        63234: "Left", 63232: "Up", 63235: "Right", 63233: "Down", 63302: "Insert", 63272: "Delete" };
      CodeMirror.keyNames = keyNames;
      (function () {
        // Number keys
        for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);
        // Alphabetic keys
        for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
        // Function keys
        for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
      })();

      // BIDI HELPERS

      function iterateBidiSections(order, from, to, f) {
        if (!order) return f(from, to, "ltr");
        var found = false;
        for (var i = 0; i < order.length; ++i) {
          var part = order[i];
          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
            found = true;
          }
        }
        if (!found) f(from, to, "ltr");
      }

      function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from;
      }
      function bidiRight(part) {
        return part.level % 2 ? part.from : part.to;
      }

      function lineLeft(line) {
        var order = getOrder(line);return order ? bidiLeft(order[0]) : 0;
      }
      function lineRight(line) {
        var order = getOrder(line);
        if (!order) return line.text.length;
        return bidiRight(lst(order));
      }

      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(cm.doc, line);
        if (visual != line) lineN = lineNo(visual);
        var order = getOrder(visual);
        var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
        return Pos(lineN, ch);
      }
      function lineEnd(cm, lineN) {
        var merged, line;
        while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN))) lineN = merged.find().to.line;
        var order = getOrder(line);
        var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
        return Pos(lineN, ch);
      }

      function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        if (a == linedir) return true;
        if (b == linedir) return false;
        return a < b;
      }
      var bidiOther;
      function getBidiPartAt(order, pos) {
        for (var i = 0, found; i < order.length; ++i) {
          var cur = order[i];
          if (cur.from < pos && cur.to > pos) {
            bidiOther = null;return i;
          }
          if (cur.from == pos || cur.to == pos) {
            if (found == null) {
              found = i;
            } else if (compareBidiLevel(order, cur.level, order[found].level)) {
              bidiOther = found;
              return i;
            } else {
              bidiOther = i;
              return found;
            }
          }
        }
        bidiOther = null;
        return found;
      }

      function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit) return pos + dir;
        do pos += dir; while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
        return pos;
      }

      // This is somewhat involved. It is needed in order to move
      // 'visually' through bi-directional text -- i.e., pressing left
      // should make the cursor go left, even when in RTL text. The
      // tricky part is the 'jumps', where RTL and LTR text touch each
      // other. This often requires the cursor offset to move more than
      // one unit, in order to visually move one unit.
      function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi) return moveLogically(line, start, dir, byUnit);
        var pos = getBidiPartAt(bidi, start),
            part = bidi[pos];
        var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

        for (;;) {
          if (target > part.from && target < part.to) return target;
          if (target == part.from || target == part.to) {
            if (getBidiPartAt(bidi, target) == pos) return target;
            part = bidi[pos += dir];
            return dir > 0 == part.level % 2 ? part.to : part.from;
          } else {
            part = bidi[pos += dir];
            if (!part) return null;
            if (dir > 0 == part.level % 2) target = moveInLine(line, part.to, -1, byUnit);else target = moveInLine(line, part.from, 1, byUnit);
          }
        }
      }

      function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) target += dir;
        return target < 0 || target > line.text.length ? null : target;
      }

      // Bidirectional ordering algorithm
      // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
      // that this (partially) implements.

      // One-char codes used for character types:
      // L (L):   Left-to-Right
      // R (R):   Right-to-Left
      // r (AL):  Right-to-Left Arabic
      // 1 (EN):  European Number
      // + (ES):  European Number Separator
      // % (ET):  European Number Terminator
      // n (AN):  Arabic Number
      // , (CS):  Common Number Separator
      // m (NSM): Non-Spacing Mark
      // b (BN):  Boundary Neutral
      // s (B):   Paragraph Separator
      // t (S):   Segment Separator
      // w (WS):  Whitespace
      // N (ON):  Other Neutrals

      // Returns null if characters are ordered as they appear
      // (left-to-right), or an array of sections ({from, to, level}
      // objects) in the order in which they occur visually.
      var bidiOrdering = function () {
        // Character types for codepoints 0 to 0xff
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";
        // Character types for codepoints 0x600 to 0x6ff
        var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";
        function charType(code) {
          if (code <= 0xff) return lowTypes.charAt(code);else if (0x590 <= code && code <= 0x5f4) return "R";else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);else if (0x700 <= code && code <= 0x8ac) return "r";else return "L";
        }

        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/,
            isStrong = /[LRr]/,
            countsAsLeft = /[Lb1n]/,
            countsAsNum = /[1n]/;
        // Browsers seem to always treat the boundaries of block elements as being L.
        var outerType = "L";

        return function (str) {
          if (!bidiRE.test(str)) return false;
          var len = str.length,
              types = [];
          for (var i = 0, type; i < len; ++i) types.push(type = charType(str.charCodeAt(i)));

          // W1. Examine each non-spacing mark (NSM) in the level run, and
          // change the type of the NSM to the type of the previous
          // character. If the NSM is at the start of the level run, it will
          // get the type of sor.
          for (var i = 0, prev = outerType; i < len; ++i) {
            var type = types[i];
            if (type == "m") types[i] = prev;else prev = type;
          }

          // W2. Search backwards from each instance of a European number
          // until the first strong type (R, L, AL, or sor) is found. If an
          // AL is found, change the type of the European number to Arabic
          // number.
          // W3. Change all ALs to R.
          for (var i = 0, cur = outerType; i < len; ++i) {
            var type = types[i];
            if (type == "1" && cur == "r") types[i] = "n";else if (isStrong.test(type)) {
              cur = type;if (type == "r") types[i] = "R";
            }
          }

          // W4. A single European separator between two European numbers
          // changes to a European number. A single common separator between
          // two numbers of the same type changes to that type.
          for (var i = 1, prev = types[0]; i < len - 1; ++i) {
            var type = types[i];
            if (type == "+" && prev == "1" && types[i + 1] == "1") types[i] = "1";else if (type == "," && prev == types[i + 1] && (prev == "1" || prev == "n")) types[i] = prev;
            prev = type;
          }

          // W5. A sequence of European terminators adjacent to European
          // numbers changes to all European numbers.
          // W6. Otherwise, separators and terminators change to Other
          // Neutral.
          for (var i = 0; i < len; ++i) {
            var type = types[i];
            if (type == ",") types[i] = "N";else if (type == "%") {
              for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
              var replace = i && types[i - 1] == "!" || end < len - 1 && types[end] == "1" ? "1" : "N";
              for (var j = i; j < end; ++j) types[j] = replace;
              i = end - 1;
            }
          }

          // W7. Search backwards from each instance of a European number
          // until the first strong type (R, L, or sor) is found. If an L is
          // found, then change the type of the European number to L.
          for (var i = 0, cur = outerType; i < len; ++i) {
            var type = types[i];
            if (cur == "L" && type == "1") types[i] = "L";else if (isStrong.test(type)) cur = type;
          }

          // N1. A sequence of neutrals takes the direction of the
          // surrounding strong text if the text on both sides has the same
          // direction. European and Arabic numbers act as if they were R in
          // terms of their influence on neutrals. Start-of-level-run (sor)
          // and end-of-level-run (eor) are used at level run boundaries.
          // N2. Any remaining neutrals take the embedding direction.
          for (var i = 0; i < len; ++i) {
            if (isNeutral.test(types[i])) {
              for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
              var before = (i ? types[i - 1] : outerType) == "L";
              var after = (end < len - 1 ? types[end] : outerType) == "L";
              var replace = before || after ? "L" : "R";
              for (var j = i; j < end; ++j) types[j] = replace;
              i = end - 1;
            }
          }

          // Here we depart from the documented algorithm, in order to avoid
          // building up an actual levels array. Since there are only three
          // levels (0, 1, 2) in an implementation that doesn't take
          // explicit embedding into account, we can build up the order on
          // the fly, without following the level-based algorithm.
          var order = [],
              m;
          for (var i = 0; i < len;) {
            if (countsAsLeft.test(types[i])) {
              var start = i;
              for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
              order.push({ from: start, to: i, level: 0 });
            } else {
              var pos = i,
                  at = order.length;
              for (++i; i < len && types[i] != "L"; ++i) {}
              for (var j = pos; j < i;) {
                if (countsAsNum.test(types[j])) {
                  if (pos < j) order.splice(at, 0, { from: pos, to: j, level: 1 });
                  var nstart = j;
                  for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
                  order.splice(at, 0, { from: nstart, to: j, level: 2 });
                  pos = j;
                } else ++j;
              }
              if (pos < i) order.splice(at, 0, { from: pos, to: i, level: 1 });
            }
          }
          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
            order[0].from = m[0].length;
            order.unshift({ from: 0, to: m[0].length, level: 0 });
          }
          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
            lst(order).to -= m[0].length;
            order.push({ from: len - m[0].length, to: len, level: 0 });
          }
          if (order[0].level != lst(order).level) order.push({ from: len, to: len, level: order[0].level });

          return order;
        };
      }();

      // THE END

      CodeMirror.version = "3.20.0";

      return CodeMirror;
    }();
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("84", ["80"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    // ============== Formatting extensions ============================
    (function () {
      // Define extensions for a few modes
      CodeMirror.extendMode("css", {
        commentStart: "/*",
        commentEnd: "*/",
        wordWrapChars: [";", "\\{", "\\}"],
        autoFormatLineBreaks: function (text) {
          return text.replace(new RegExp("(;|\\{|\\})([^\r\n])", "g"), "$1\n$2");
        }
      });

      function jsNonBreakableBlocks(text) {
        var nonBreakableRegexes = [/for\s*?\((.*?)\)/, /\"(.*?)(\"|$)/, /\'(.*?)(\'|$)/, /\/\*(.*?)(\*\/|$)/, /\/\/.*/];
        var nonBreakableBlocks = [];
        for (var i = 0; i < nonBreakableRegexes.length; i++) {
          var curPos = 0;
          while (curPos < text.length) {
            var m = text.substr(curPos).match(nonBreakableRegexes[i]);
            if (m != null) {
              nonBreakableBlocks.push({
                start: curPos + m.index,
                end: curPos + m.index + m[0].length
              });
              curPos += m.index + Math.max(1, m[0].length);
            } else {
              // No more matches
              break;
            }
          }
        }
        nonBreakableBlocks.sort(function (a, b) {
          return a.start - b.start;
        });

        return nonBreakableBlocks;
      }

      CodeMirror.extendMode("javascript", {
        commentStart: "/*",
        commentEnd: "*/",
        wordWrapChars: [";", "\\{", "\\}"],

        autoFormatLineBreaks: function (text) {
          var curPos = 0;
          var split = this.jsonMode ? function (str) {
            return str.replace(/([,{])/g, "$1\n").replace(/}/g, "\n}");
          } : function (str) {
            return str.replace(/(;|\{|\})([^\r\n;])/g, "$1\n$2");
          };
          var nonBreakableBlocks = jsNonBreakableBlocks(text),
              res = "";
          if (nonBreakableBlocks != null) {
            for (var i = 0; i < nonBreakableBlocks.length; i++) {
              if (nonBreakableBlocks[i].start > curPos) {
                // Break lines till the block
                res += split(text.substring(curPos, nonBreakableBlocks[i].start));
                curPos = nonBreakableBlocks[i].start;
              }
              if (nonBreakableBlocks[i].start <= curPos && nonBreakableBlocks[i].end >= curPos) {
                // Skip non-breakable block
                res += text.substring(curPos, nonBreakableBlocks[i].end);
                curPos = nonBreakableBlocks[i].end;
              }
            }
            if (curPos < text.length) res += split(text.substr(curPos));
          } else {
            res = split(text);
          }
          return res.replace(/^\n*|\n*$/, "");
        }
      });

      CodeMirror.extendMode("xml", {
        commentStart: "<!--",
        commentEnd: "-->",
        wordWrapChars: [">"],

        autoFormatLineBreaks: function (text) {
          var lines = text.split("\n");
          var reProcessedPortion = new RegExp("(^\\s*?<|^[^<]*?)(.+)(>\\s*?$|[^>]*?$)");
          var reOpenBrackets = new RegExp("<", "g");
          var reCloseBrackets = new RegExp("(>)([^\r\n])", "g");
          for (var i = 0; i < lines.length; i++) {
            var mToProcess = lines[i].match(reProcessedPortion);
            if (mToProcess != null && mToProcess.length > 3) {
              // The line starts with whitespaces and ends with whitespaces
              lines[i] = mToProcess[1] + mToProcess[2].replace(reOpenBrackets, "\n$&").replace(reCloseBrackets, "$1\n$2") + mToProcess[3];
              continue;
            }
          }
          return lines.join("\n");
        }
      });

      function localModeAt(cm, pos) {
        return CodeMirror.innerMode(cm.getMode(), cm.getTokenAt(pos).state).mode;
      }

      function enumerateModesBetween(cm, line, start, end) {
        var outer = cm.getMode(),
            text = cm.getLine(line);
        if (end == null) end = text.length;
        if (!outer.innerMode) return [{ from: start, to: end, mode: outer }];
        var state = cm.getTokenAt({ line: line, ch: start }).state;
        var mode = CodeMirror.innerMode(outer, state).mode;
        var found = [],
            stream = new CodeMirror.StringStream(text);
        stream.pos = stream.start = start;
        for (;;) {
          outer.token(stream, state);
          var curMode = CodeMirror.innerMode(outer, state).mode;
          if (curMode != mode) {
            var cut = stream.start;
            // Crappy heuristic to deal with the fact that a change in
            // mode can occur both at the end and the start of a token,
            // and we don't know which it was.
            if (mode.name == "xml" && text.charAt(stream.pos - 1) == ">") cut = stream.pos;
            found.push({ from: start, to: cut, mode: mode });
            start = cut;
            mode = curMode;
          }
          if (stream.pos >= end) break;
          stream.start = stream.pos;
        }
        if (start < end) found.push({ from: start, to: end, mode: mode });
        return found;
      }

      // Comment/uncomment the specified range
      CodeMirror.defineExtension("commentRange", function (isComment, from, to) {
        var curMode = localModeAt(this, from),
            cm = this;
        this.operation(function () {
          if (isComment) {
            // Comment range
            cm.replaceRange(curMode.commentEnd, to);
            cm.replaceRange(curMode.commentStart, from);
            if (from.line == to.line && from.ch == to.ch) // An empty comment inserted - put cursor inside
              cm.setCursor(from.line, from.ch + curMode.commentStart.length);
          } else {
            // Uncomment range
            var selText = cm.getRange(from, to);
            var startIndex = selText.indexOf(curMode.commentStart);
            var endIndex = selText.lastIndexOf(curMode.commentEnd);
            if (startIndex > -1 && endIndex > -1 && endIndex > startIndex) {
              // Take string till comment start
              selText = selText.substr(0, startIndex)
              // From comment start till comment end
              + selText.substring(startIndex + curMode.commentStart.length, endIndex)
              // From comment end till string end
              + selText.substr(endIndex + curMode.commentEnd.length);
            }
            cm.replaceRange(selText, from, to);
          }
        });
      });

      // Applies automatic mode-aware indentation to the specified range
      CodeMirror.defineExtension("autoIndentRange", function (from, to) {
        var cmInstance = this;
        this.operation(function () {
          for (var i = from.line; i <= to.line; i++) {
            cmInstance.indentLine(i, "smart");
          }
        });
      });

      // Applies automatic formatting to the specified range
      CodeMirror.defineExtension("autoFormatRange", function (from, to) {
        var cm = this;
        cm.operation(function () {
          for (var cur = from.line, end = to.line; cur <= end; ++cur) {
            var f = { line: cur, ch: cur == from.line ? from.ch : 0 };
            var t = { line: cur, ch: cur == end ? to.ch : null };
            var modes = enumerateModesBetween(cm, cur, f.ch, t.ch),
                mangled = "";
            var text = cm.getRange(f, t);
            for (var i = 0; i < modes.length; ++i) {
              var part = modes.length > 1 ? text.slice(modes[i].from, modes[i].to) : text;
              if (mangled) mangled += "\n";
              if (modes[i].mode.autoFormatLineBreaks) {
                mangled += modes[i].mode.autoFormatLineBreaks(part);
              } else mangled += text;
            }
            if (mangled != text) {
              for (var count = 0, pos = mangled.indexOf("\n"); pos != -1; pos = mangled.indexOf("\n", pos + 1), ++count) {}
              cm.replaceRange(mangled, f, t);
              cur += count;
              end += count;
            }
          }
          for (var cur = from.line + 1; cur <= end; ++cur) cm.indentLine(cur, "smart");
          cm.setSelection(from, cm.getCursor(false));
        });
      });
    })();
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('85', ['28'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /*!
   * 
   * Super simple wysiwyg editor v0.8.16
   * https://summernote.org
   * 
   * 
   * Copyright 2013- Alan Hong. and other contributors
   * summernote may be freely distributed under the MIT license.
   * 
   * Date: 2020-02-19T09:12Z
   * 
   */
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object') module.exports = factory($__require('28'));else if (typeof undefined === 'function' && define.amd) define(["jquery"], factory);else {
      var a = typeof exports === 'object' ? factory($__require('28')) : factory(root["jQuery"]);
      for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
    }
  })(window, function (__WEBPACK_EXTERNAL_MODULE__0__) {
    return (/******/function (modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/var installedModules = {};
        /******/
        /******/ // The require function
        /******/function __webpack_require__(moduleId) {
          /******/
          /******/ // Check if module is in cache
          /******/if (installedModules[moduleId]) {
            /******/return installedModules[moduleId].exports;
            /******/
          }
          /******/ // Create a new module (and put it into the cache)
          /******/var module = installedModules[moduleId] = {
            /******/i: moduleId,
            /******/l: false,
            /******/exports: {}
            /******/ };
          /******/
          /******/ // Execute the module function
          /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
          /******/
          /******/ // Flag the module as loaded
          /******/module.l = true;
          /******/
          /******/ // Return the exports of the module
          /******/return module.exports;
          /******/
        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/__webpack_require__.m = modules;
        /******/
        /******/ // expose the module cache
        /******/__webpack_require__.c = installedModules;
        /******/
        /******/ // define getter function for harmony exports
        /******/__webpack_require__.d = function (exports, name, getter) {
          /******/if (!__webpack_require__.o(exports, name)) {
            /******/Object.defineProperty(exports, name, { enumerable: true, get: getter });
            /******/
          }
          /******/
        };
        /******/
        /******/ // define __esModule on exports
        /******/__webpack_require__.r = function (exports) {
          /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
            /******/
          }
          /******/Object.defineProperty(exports, '__esModule', { value: true });
          /******/
        };
        /******/
        /******/ // create a fake namespace object
        /******/ // mode & 1: value is a module id, require it
        /******/ // mode & 2: merge all properties of value into the ns
        /******/ // mode & 4: return value when already ns object
        /******/ // mode & 8|1: behave like require
        /******/__webpack_require__.t = function (value, mode) {
          /******/if (mode & 1) value = __webpack_require__(value);
          /******/if (mode & 8) return value;
          /******/if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
          /******/var ns = Object.create(null);
          /******/__webpack_require__.r(ns);
          /******/Object.defineProperty(ns, 'default', { enumerable: true, value: value });
          /******/if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
            return value[key];
          }.bind(null, key));
          /******/return ns;
          /******/
        };
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/__webpack_require__.n = function (module) {
          /******/var getter = module && module.__esModule ?
          /******/function getDefault() {
            return module['default'];
          } :
          /******/function getModuleExports() {
            return module;
          };
          /******/__webpack_require__.d(getter, 'a', getter);
          /******/return getter;
          /******/
        };
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/__webpack_require__.o = function (object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/
        /******/ // __webpack_public_path__
        /******/__webpack_require__.p = "";
        /******/
        /******/
        /******/ // Load entry module and return exports
        /******/return __webpack_require__(__webpack_require__.s = 52);
        /******/
      }(
      /************************************************************************/
      /******/{

        /***/0:
        /***/function (module, exports) {

          module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

          /***/
        },

        /***/1:
        /***/function (module, __webpack_exports__, __webpack_require__) {

          "use strict";
          /* harmony import */
          var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
          /* harmony import */var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
          function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
            }return _typeof(obj);
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          var Renderer =
          /*#__PURE__*/
          function () {
            function Renderer(markup, children, options, callback) {
              _classCallCheck(this, Renderer);

              this.markup = markup;
              this.children = children;
              this.options = options;
              this.callback = callback;
            }

            _createClass(Renderer, [{
              key: "render",
              value: function render($parent) {
                var $node = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.markup);

                if (this.options && this.options.contents) {
                  $node.html(this.options.contents);
                }

                if (this.options && this.options.className) {
                  $node.addClass(this.options.className);
                }

                if (this.options && this.options.data) {
                  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(this.options.data, function (k, v) {
                    $node.attr('data-' + k, v);
                  });
                }

                if (this.options && this.options.click) {
                  $node.on('click', this.options.click);
                }

                if (this.children) {
                  var $container = $node.find('.note-children-container');
                  this.children.forEach(function (child) {
                    child.render($container.length ? $container : $node);
                  });
                }

                if (this.callback) {
                  this.callback($node, this.options);
                }

                if (this.options && this.options.callback) {
                  this.options.callback($node);
                }

                if ($parent) {
                  $parent.append($node);
                }

                return $node;
              }
            }]);

            return Renderer;
          }();

          /* harmony default export */__webpack_exports__["a"] = {
            create: function create(markup, callback) {
              return function () {
                var options = _typeof(arguments[1]) === 'object' ? arguments[1] : arguments[0];
                var children = Array.isArray(arguments[0]) ? arguments[0] : [];

                if (options && options.children) {
                  children = options.children;
                }

                return new Renderer(markup, children, options, callback);
              };
            }
          };

          /***/
        },

        /***/2:
        /***/function (module, exports) {

          /* WEBPACK VAR INJECTION */(function (__webpack_amd_options__) {
            /* globals __webpack_amd_options__ */
            module.exports = __webpack_amd_options__;

            /* WEBPACK VAR INJECTION */
          }).call(this, {});

          /***/
        },

        /***/3:
        /***/function (module, __webpack_exports__, __webpack_require__) {

          "use strict";

          // EXTERNAL MODULE: external {"root":"jQuery","commonjs2":"jquery","commonjs":"jquery","amd":"jquery"}

          var external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_ = __webpack_require__(0);
          var external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default = /*#__PURE__*/__webpack_require__.n(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_);

          // CONCATENATED MODULE: ./src/js/base/summernote-en-US.js

          external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote || {
            lang: {}
          };
          external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.lang, {
            'en-US': {
              font: {
                bold: 'Bold',
                italic: 'Italic',
                underline: 'Underline',
                clear: 'Remove Font Style',
                height: 'Line Height',
                name: 'Font Family',
                strikethrough: 'Strikethrough',
                subscript: 'Subscript',
                superscript: 'Superscript',
                size: 'Font Size',
                sizeunit: 'Font Size Unit'
              },
              image: {
                image: 'Picture',
                insert: 'Insert Image',
                resizeFull: 'Resize full',
                resizeHalf: 'Resize half',
                resizeQuarter: 'Resize quarter',
                resizeNone: 'Original size',
                floatLeft: 'Float Left',
                floatRight: 'Float Right',
                floatNone: 'Remove float',
                shapeRounded: 'Shape: Rounded',
                shapeCircle: 'Shape: Circle',
                shapeThumbnail: 'Shape: Thumbnail',
                shapeNone: 'Shape: None',
                dragImageHere: 'Drag image or text here',
                dropImage: 'Drop image or Text',
                selectFromFiles: 'Select from files',
                maximumFileSize: 'Maximum file size',
                maximumFileSizeError: 'Maximum file size exceeded.',
                url: 'Image URL',
                remove: 'Remove Image',
                original: 'Original'
              },
              video: {
                video: 'Video',
                videoLink: 'Video Link',
                insert: 'Insert Video',
                url: 'Video URL',
                providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'
              },
              link: {
                link: 'Link',
                insert: 'Insert Link',
                unlink: 'Unlink',
                edit: 'Edit',
                textToDisplay: 'Text to display',
                url: 'To what URL should this link go?',
                openInNewWindow: 'Open in new window',
                useProtocol: 'Use default protocol'
              },
              table: {
                table: 'Table',
                addRowAbove: 'Add row above',
                addRowBelow: 'Add row below',
                addColLeft: 'Add column left',
                addColRight: 'Add column right',
                delRow: 'Delete row',
                delCol: 'Delete column',
                delTable: 'Delete table'
              },
              hr: {
                insert: 'Insert Horizontal Rule'
              },
              style: {
                style: 'Style',
                p: 'Normal',
                blockquote: 'Quote',
                pre: 'Code',
                h1: 'Header 1',
                h2: 'Header 2',
                h3: 'Header 3',
                h4: 'Header 4',
                h5: 'Header 5',
                h6: 'Header 6'
              },
              lists: {
                unordered: 'Unordered list',
                ordered: 'Ordered list'
              },
              options: {
                help: 'Help',
                fullscreen: 'Full Screen',
                codeview: 'Code View'
              },
              paragraph: {
                paragraph: 'Paragraph',
                outdent: 'Outdent',
                indent: 'Indent',
                left: 'Align left',
                center: 'Align center',
                right: 'Align right',
                justify: 'Justify full'
              },
              color: {
                recent: 'Recent Color',
                more: 'More Color',
                background: 'Background Color',
                foreground: 'Text Color',
                transparent: 'Transparent',
                setTransparent: 'Set transparent',
                reset: 'Reset',
                resetToDefault: 'Reset to default',
                cpSelect: 'Select'
              },
              shortcut: {
                shortcuts: 'Keyboard shortcuts',
                close: 'Close',
                textFormatting: 'Text formatting',
                action: 'Action',
                paragraphFormatting: 'Paragraph formatting',
                documentStyle: 'Document Style',
                extraKeys: 'Extra keys'
              },
              help: {
                'insertParagraph': 'Insert Paragraph',
                'undo': 'Undoes the last command',
                'redo': 'Redoes the last command',
                'tab': 'Tab',
                'untab': 'Untab',
                'bold': 'Set a bold style',
                'italic': 'Set a italic style',
                'underline': 'Set a underline style',
                'strikethrough': 'Set a strikethrough style',
                'removeFormat': 'Clean a style',
                'justifyLeft': 'Set left align',
                'justifyCenter': 'Set center align',
                'justifyRight': 'Set right align',
                'justifyFull': 'Set full align',
                'insertUnorderedList': 'Toggle unordered list',
                'insertOrderedList': 'Toggle ordered list',
                'outdent': 'Outdent on current paragraph',
                'indent': 'Indent on current paragraph',
                'formatPara': 'Change current block\'s format as a paragraph(P tag)',
                'formatH1': 'Change current block\'s format as H1',
                'formatH2': 'Change current block\'s format as H2',
                'formatH3': 'Change current block\'s format as H3',
                'formatH4': 'Change current block\'s format as H4',
                'formatH5': 'Change current block\'s format as H5',
                'formatH6': 'Change current block\'s format as H6',
                'insertHorizontalRule': 'Insert horizontal rule',
                'linkDialog.show': 'Show Link Dialog'
              },
              history: {
                undo: 'Undo',
                redo: 'Redo'
              },
              specialChar: {
                specialChar: 'SPECIAL CHARACTERS',
                select: 'Select Special characters'
              },
              output: {
                noSelection: 'No Selection Made!'
              }
            }
          });
          // CONCATENATED MODULE: ./src/js/base/core/env.js

          var isSupportAmd = typeof undefined === 'function' && __webpack_require__(2); // eslint-disable-line

          /**
           * returns whether font is installed or not.
           *
           * @param {String} fontName
           * @return {Boolean}
           */

          var genericFontFamilies = ['sans-serif', 'serif', 'monospace', 'cursive', 'fantasy'];

          function validFontName(fontName) {
            return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.inArray(fontName.toLowerCase(), genericFontFamilies) === -1 ? "'".concat(fontName, "'") : fontName;
          }

          function env_isFontInstalled(fontName) {
            var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
            var testText = 'mmmmmmmmmmwwwww';
            var testSize = '200px';
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            context.font = testSize + " '" + testFontName + "'";
            var originalWidth = context.measureText(testText).width;
            context.font = testSize + ' ' + validFontName(fontName) + ', "' + testFontName + '"';
            var width = context.measureText(testText).width;
            return originalWidth !== width;
          }

          var userAgent = navigator.userAgent;
          var isMSIE = /MSIE|Trident/i.test(userAgent);
          var browserVersion;

          if (isMSIE) {
            var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);

            if (matches) {
              browserVersion = parseFloat(matches[1]);
            }

            matches = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(userAgent);

            if (matches) {
              browserVersion = parseFloat(matches[1]);
            }
          }

          var isEdge = /Edge\/\d+/.test(userAgent);
          var hasCodeMirror = !!window.CodeMirror;
          var isSupportTouch = 'ontouchstart' in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0; // [workaround] IE doesn't have input events for contentEditable
          // - see: https://goo.gl/4bfIvA

          var inputEventName = isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';
          /**
           * @class core.env
           *
           * Object which check platform and agent
           *
           * @singleton
           * @alternateClassName env
           */

          /* harmony default export */var env = {
            isMac: navigator.appVersion.indexOf('Mac') > -1,
            isMSIE: isMSIE,
            isEdge: isEdge,
            isFF: !isEdge && /firefox/i.test(userAgent),
            isPhantom: /PhantomJS/i.test(userAgent),
            isWebkit: !isEdge && /webkit/i.test(userAgent),
            isChrome: !isEdge && /chrome/i.test(userAgent),
            isSafari: !isEdge && /safari/i.test(userAgent) && !/chrome/i.test(userAgent),
            browserVersion: browserVersion,
            jqueryVersion: parseFloat(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.fn.jquery),
            isSupportAmd: isSupportAmd,
            isSupportTouch: isSupportTouch,
            hasCodeMirror: hasCodeMirror,
            isFontInstalled: env_isFontInstalled,
            isW3CRangeSupport: !!document.createRange,
            inputEventName: inputEventName,
            genericFontFamilies: genericFontFamilies,
            validFontName: validFontName
          };
          // CONCATENATED MODULE: ./src/js/base/core/func.js

          /**
           * @class core.func
           *
           * func utils (for high-order func's arg)
           *
           * @singleton
           * @alternateClassName func
           */

          function eq(itemA) {
            return function (itemB) {
              return itemA === itemB;
            };
          }

          function eq2(itemA, itemB) {
            return itemA === itemB;
          }

          function peq2(propName) {
            return function (itemA, itemB) {
              return itemA[propName] === itemB[propName];
            };
          }

          function ok() {
            return true;
          }

          function fail() {
            return false;
          }

          function not(f) {
            return function () {
              return !f.apply(f, arguments);
            };
          }

          function and(fA, fB) {
            return function (item) {
              return fA(item) && fB(item);
            };
          }

          function func_self(a) {
            return a;
          }

          function func_invoke(obj, method) {
            return function () {
              return obj[method].apply(obj, arguments);
            };
          }

          var idCounter = 0;
          /**
           * reset globally-unique id
           *
           */

          function resetUniqueId() {
            idCounter = 0;
          }
          /**
           * generate a globally-unique id
           *
           * @param {String} [prefix]
           */

          function uniqueId(prefix) {
            var id = ++idCounter + '';
            return prefix ? prefix + id : id;
          }
          /**
           * returns bnd (bounds) from rect
           *
           * - IE Compatibility Issue: http://goo.gl/sRLOAo
           * - Scroll Issue: http://goo.gl/sNjUc
           *
           * @param {Rect} rect
           * @return {Object} bounds
           * @return {Number} bounds.top
           * @return {Number} bounds.left
           * @return {Number} bounds.width
           * @return {Number} bounds.height
           */

          function rect2bnd(rect) {
            var $document = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
            return {
              top: rect.top + $document.scrollTop(),
              left: rect.left + $document.scrollLeft(),
              width: rect.right - rect.left,
              height: rect.bottom - rect.top
            };
          }
          /**
           * returns a copy of the object where the keys have become the values and the values the keys.
           * @param {Object} obj
           * @return {Object}
           */

          function invertObject(obj) {
            var inverted = {};

            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                inverted[obj[key]] = key;
              }
            }

            return inverted;
          }
          /**
           * @param {String} namespace
           * @param {String} [prefix]
           * @return {String}
           */

          function namespaceToCamel(namespace, prefix) {
            prefix = prefix || '';
            return prefix + namespace.split('.').map(function (name) {
              return name.substring(0, 1).toUpperCase() + name.substring(1);
            }).join('');
          }
          /**
           * Returns a function, that, as long as it continues to be invoked, will not
           * be triggered. The function will be called after it stops being called for
           * N milliseconds. If `immediate` is passed, trigger the function on the
           * leading edge, instead of the trailing.
           * @param {Function} func
           * @param {Number} wait
           * @param {Boolean} immediate
           * @return {Function}
           */

          function debounce(func, wait, immediate) {
            var timeout;
            return function () {
              var context = this;
              var args = arguments;

              var later = function later() {
                timeout = null;

                if (!immediate) {
                  func.apply(context, args);
                }
              };

              var callNow = immediate && !timeout;
              clearTimeout(timeout);
              timeout = setTimeout(later, wait);

              if (callNow) {
                func.apply(context, args);
              }
            };
          }
          /**
           *
           * @param {String} url
           * @return {Boolean}
           */

          function isValidUrl(url) {
            var expression = /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi;
            return expression.test(url);
          }

          /* harmony default export */var func = {
            eq: eq,
            eq2: eq2,
            peq2: peq2,
            ok: ok,
            fail: fail,
            self: func_self,
            not: not,
            and: and,
            invoke: func_invoke,
            resetUniqueId: resetUniqueId,
            uniqueId: uniqueId,
            rect2bnd: rect2bnd,
            invertObject: invertObject,
            namespaceToCamel: namespaceToCamel,
            debounce: debounce,
            isValidUrl: isValidUrl
          };
          // CONCATENATED MODULE: ./src/js/base/core/lists.js

          /**
           * returns the first item of an array.
           *
           * @param {Array} array
           */

          function lists_head(array) {
            return array[0];
          }
          /**
           * returns the last item of an array.
           *
           * @param {Array} array
           */

          function lists_last(array) {
            return array[array.length - 1];
          }
          /**
           * returns everything but the last entry of the array.
           *
           * @param {Array} array
           */

          function initial(array) {
            return array.slice(0, array.length - 1);
          }
          /**
           * returns the rest of the items in an array.
           *
           * @param {Array} array
           */

          function tail(array) {
            return array.slice(1);
          }
          /**
           * returns item of array
           */

          function find(array, pred) {
            for (var idx = 0, len = array.length; idx < len; idx++) {
              var item = array[idx];

              if (pred(item)) {
                return item;
              }
            }
          }
          /**
           * returns true if all of the values in the array pass the predicate truth test.
           */

          function lists_all(array, pred) {
            for (var idx = 0, len = array.length; idx < len; idx++) {
              if (!pred(array[idx])) {
                return false;
              }
            }

            return true;
          }
          /**
           * returns true if the value is present in the list.
           */

          function contains(array, item) {
            if (array && array.length && item) {
              if (array.indexOf) {
                return array.indexOf(item) !== -1;
              } else if (array.contains) {
                // `DOMTokenList` doesn't implement `.indexOf`, but it implements `.contains`
                return array.contains(item);
              }
            }

            return false;
          }
          /**
           * get sum from a list
           *
           * @param {Array} array - array
           * @param {Function} fn - iterator
           */

          function sum(array, fn) {
            fn = fn || func.self;
            return array.reduce(function (memo, v) {
              return memo + fn(v);
            }, 0);
          }
          /**
           * returns a copy of the collection with array type.
           * @param {Collection} collection - collection eg) node.childNodes, ...
           */

          function from(collection) {
            var result = [];
            var length = collection.length;
            var idx = -1;

            while (++idx < length) {
              result[idx] = collection[idx];
            }

            return result;
          }
          /**
           * returns whether list is empty or not
           */

          function lists_isEmpty(array) {
            return !array || !array.length;
          }
          /**
           * cluster elements by predicate function.
           *
           * @param {Array} array - array
           * @param {Function} fn - predicate function for cluster rule
           * @param {Array[]}
           */

          function clusterBy(array, fn) {
            if (!array.length) {
              return [];
            }

            var aTail = tail(array);
            return aTail.reduce(function (memo, v) {
              var aLast = lists_last(memo);

              if (fn(lists_last(aLast), v)) {
                aLast[aLast.length] = v;
              } else {
                memo[memo.length] = [v];
              }

              return memo;
            }, [[lists_head(array)]]);
          }
          /**
           * returns a copy of the array with all false values removed
           *
           * @param {Array} array - array
           * @param {Function} fn - predicate function for cluster rule
           */

          function compact(array) {
            var aResult = [];

            for (var idx = 0, len = array.length; idx < len; idx++) {
              if (array[idx]) {
                aResult.push(array[idx]);
              }
            }

            return aResult;
          }
          /**
           * produces a duplicate-free version of the array
           *
           * @param {Array} array
           */

          function unique(array) {
            var results = [];

            for (var idx = 0, len = array.length; idx < len; idx++) {
              if (!contains(results, array[idx])) {
                results.push(array[idx]);
              }
            }

            return results;
          }
          /**
           * returns next item.
           * @param {Array} array
           */

          function lists_next(array, item) {
            if (array && array.length && item) {
              var idx = array.indexOf(item);
              return idx === -1 ? null : array[idx + 1];
            }

            return null;
          }
          /**
           * returns prev item.
           * @param {Array} array
           */

          function prev(array, item) {
            if (array && array.length && item) {
              var idx = array.indexOf(item);
              return idx === -1 ? null : array[idx - 1];
            }

            return null;
          }
          /**
           * @class core.list
           *
           * list utils
           *
           * @singleton
           * @alternateClassName list
           */

          /* harmony default export */var lists = {
            head: lists_head,
            last: lists_last,
            initial: initial,
            tail: tail,
            prev: prev,
            next: lists_next,
            find: find,
            contains: contains,
            all: lists_all,
            sum: sum,
            from: from,
            isEmpty: lists_isEmpty,
            clusterBy: clusterBy,
            compact: compact,
            unique: unique
          };
          // CONCATENATED MODULE: ./src/js/base/core/dom.js


          var NBSP_CHAR = String.fromCharCode(160);
          var ZERO_WIDTH_NBSP_CHAR = "\uFEFF";
          /**
           * @method isEditable
           *
           * returns whether node is `note-editable` or not.
           *
           * @param {Node} node
           * @return {Boolean}
           */

          function isEditable(node) {
            return node && external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).hasClass('note-editable');
          }
          /**
           * @method isControlSizing
           *
           * returns whether node is `note-control-sizing` or not.
           *
           * @param {Node} node
           * @return {Boolean}
           */

          function isControlSizing(node) {
            return node && external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).hasClass('note-control-sizing');
          }
          /**
           * @method makePredByNodeName
           *
           * returns predicate which judge whether nodeName is same
           *
           * @param {String} nodeName
           * @return {Function}
           */

          function makePredByNodeName(nodeName) {
            nodeName = nodeName.toUpperCase();
            return function (node) {
              return node && node.nodeName.toUpperCase() === nodeName;
            };
          }
          /**
           * @method isText
           *
           *
           *
           * @param {Node} node
           * @return {Boolean} true if node's type is text(3)
           */

          function isText(node) {
            return node && node.nodeType === 3;
          }
          /**
           * @method isElement
           *
           *
           *
           * @param {Node} node
           * @return {Boolean} true if node's type is element(1)
           */

          function isElement(node) {
            return node && node.nodeType === 1;
          }
          /**
           * ex) br, col, embed, hr, img, input, ...
           * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
           */

          function isVoid(node) {
            return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT|^AUDIO|^VIDEO|^EMBED/.test(node.nodeName.toUpperCase());
          }

          function isPara(node) {
            if (isEditable(node)) {
              return false;
            } // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph


            return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
          }

          function isHeading(node) {
            return node && /^H[1-7]/.test(node.nodeName.toUpperCase());
          }

          var isPre = makePredByNodeName('PRE');
          var isLi = makePredByNodeName('LI');

          function isPurePara(node) {
            return isPara(node) && !isLi(node);
          }

          var isTable = makePredByNodeName('TABLE');
          var isData = makePredByNodeName('DATA');

          function dom_isInline(node) {
            return !isBodyContainer(node) && !isList(node) && !isHr(node) && !isPara(node) && !isTable(node) && !isBlockquote(node) && !isData(node);
          }

          function isList(node) {
            return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
          }

          var isHr = makePredByNodeName('HR');

          function dom_isCell(node) {
            return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
          }

          var isBlockquote = makePredByNodeName('BLOCKQUOTE');

          function isBodyContainer(node) {
            return dom_isCell(node) || isBlockquote(node) || isEditable(node);
          }

          var isAnchor = makePredByNodeName('A');

          function isParaInline(node) {
            return dom_isInline(node) && !!dom_ancestor(node, isPara);
          }

          function isBodyInline(node) {
            return dom_isInline(node) && !dom_ancestor(node, isPara);
          }

          var isBody = makePredByNodeName('BODY');
          /**
           * returns whether nodeB is closest sibling of nodeA
           *
           * @param {Node} nodeA
           * @param {Node} nodeB
           * @return {Boolean}
           */

          function isClosestSibling(nodeA, nodeB) {
            return nodeA.nextSibling === nodeB || nodeA.previousSibling === nodeB;
          }
          /**
           * returns array of closest siblings with node
           *
           * @param {Node} node
           * @param {function} [pred] - predicate function
           * @return {Node[]}
           */

          function withClosestSiblings(node, pred) {
            pred = pred || func.ok;
            var siblings = [];

            if (node.previousSibling && pred(node.previousSibling)) {
              siblings.push(node.previousSibling);
            }

            siblings.push(node);

            if (node.nextSibling && pred(node.nextSibling)) {
              siblings.push(node.nextSibling);
            }

            return siblings;
          }
          /**
           * blank HTML for cursor position
           * - [workaround] old IE only works with &nbsp;
           * - [workaround] IE11 and other browser works with bogus br
           */

          var blankHTML = env.isMSIE && env.browserVersion < 11 ? '&nbsp;' : '<br>';
          /**
           * @method nodeLength
           *
           * returns #text's text size or element's childNodes size
           *
           * @param {Node} node
           */

          function nodeLength(node) {
            if (isText(node)) {
              return node.nodeValue.length;
            }

            if (node) {
              return node.childNodes.length;
            }

            return 0;
          }
          /**
           * returns whether deepest child node is empty or not.
           *
           * @param {Node} node
           * @return {Boolean}
           */

          function deepestChildIsEmpty(node) {
            do {
              if (node.firstElementChild === null || node.firstElementChild.innerHTML === '') break;
            } while (node = node.firstElementChild);

            return dom_isEmpty(node);
          }
          /**
           * returns whether node is empty or not.
           *
           * @param {Node} node
           * @return {Boolean}
           */

          function dom_isEmpty(node) {
            var len = nodeLength(node);

            if (len === 0) {
              return true;
            } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
              // ex) <p><br></p>, <span><br></span>
              return true;
            } else if (lists.all(node.childNodes, isText) && node.innerHTML === '') {
              // ex) <p></p>, <span></span>
              return true;
            }

            return false;
          }
          /**
           * padding blankHTML if node is empty (for cursor position)
           */

          function paddingBlankHTML(node) {
            if (!isVoid(node) && !nodeLength(node)) {
              node.innerHTML = blankHTML;
            }
          }
          /**
           * find nearest ancestor predicate hit
           *
           * @param {Node} node
           * @param {Function} pred - predicate function
           */

          function dom_ancestor(node, pred) {
            while (node) {
              if (pred(node)) {
                return node;
              }

              if (isEditable(node)) {
                break;
              }

              node = node.parentNode;
            }

            return null;
          }
          /**
           * find nearest ancestor only single child blood line and predicate hit
           *
           * @param {Node} node
           * @param {Function} pred - predicate function
           */

          function singleChildAncestor(node, pred) {
            node = node.parentNode;

            while (node) {
              if (nodeLength(node) !== 1) {
                break;
              }

              if (pred(node)) {
                return node;
              }

              if (isEditable(node)) {
                break;
              }

              node = node.parentNode;
            }

            return null;
          }
          /**
           * returns new array of ancestor nodes (until predicate hit).
           *
           * @param {Node} node
           * @param {Function} [optional] pred - predicate function
           */

          function listAncestor(node, pred) {
            pred = pred || func.fail;
            var ancestors = [];
            dom_ancestor(node, function (el) {
              if (!isEditable(el)) {
                ancestors.push(el);
              }

              return pred(el);
            });
            return ancestors;
          }
          /**
           * find farthest ancestor predicate hit
           */

          function lastAncestor(node, pred) {
            var ancestors = listAncestor(node);
            return lists.last(ancestors.filter(pred));
          }
          /**
           * returns common ancestor node between two nodes.
           *
           * @param {Node} nodeA
           * @param {Node} nodeB
           */

          function dom_commonAncestor(nodeA, nodeB) {
            var ancestors = listAncestor(nodeA);

            for (var n = nodeB; n; n = n.parentNode) {
              if (ancestors.indexOf(n) > -1) return n;
            }

            return null; // difference document area
          }
          /**
           * listing all previous siblings (until predicate hit).
           *
           * @param {Node} node
           * @param {Function} [optional] pred - predicate function
           */

          function listPrev(node, pred) {
            pred = pred || func.fail;
            var nodes = [];

            while (node) {
              if (pred(node)) {
                break;
              }

              nodes.push(node);
              node = node.previousSibling;
            }

            return nodes;
          }
          /**
           * listing next siblings (until predicate hit).
           *
           * @param {Node} node
           * @param {Function} [pred] - predicate function
           */

          function listNext(node, pred) {
            pred = pred || func.fail;
            var nodes = [];

            while (node) {
              if (pred(node)) {
                break;
              }

              nodes.push(node);
              node = node.nextSibling;
            }

            return nodes;
          }
          /**
           * listing descendant nodes
           *
           * @param {Node} node
           * @param {Function} [pred] - predicate function
           */

          function listDescendant(node, pred) {
            var descendants = [];
            pred = pred || func.ok; // start DFS(depth first search) with node

            (function fnWalk(current) {
              if (node !== current && pred(current)) {
                descendants.push(current);
              }

              for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
                fnWalk(current.childNodes[idx]);
              }
            })(node);

            return descendants;
          }
          /**
           * wrap node with new tag.
           *
           * @param {Node} node
           * @param {Node} tagName of wrapper
           * @return {Node} - wrapper
           */

          function wrap(node, wrapperName) {
            var parent = node.parentNode;
            var wrapper = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<' + wrapperName + '>')[0];
            parent.insertBefore(wrapper, node);
            wrapper.appendChild(node);
            return wrapper;
          }
          /**
           * insert node after preceding
           *
           * @param {Node} node
           * @param {Node} preceding - predicate function
           */

          function insertAfter(node, preceding) {
            var next = preceding.nextSibling;
            var parent = preceding.parentNode;

            if (next) {
              parent.insertBefore(node, next);
            } else {
              parent.appendChild(node);
            }

            return node;
          }
          /**
           * append elements.
           *
           * @param {Node} node
           * @param {Collection} aChild
           */

          function appendChildNodes(node, aChild) {
            external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(aChild, function (idx, child) {
              node.appendChild(child);
            });
            return node;
          }
          /**
           * returns whether boundaryPoint is left edge or not.
           *
           * @param {BoundaryPoint} point
           * @return {Boolean}
           */

          function isLeftEdgePoint(point) {
            return point.offset === 0;
          }
          /**
           * returns whether boundaryPoint is right edge or not.
           *
           * @param {BoundaryPoint} point
           * @return {Boolean}
           */

          function isRightEdgePoint(point) {
            return point.offset === nodeLength(point.node);
          }
          /**
           * returns whether boundaryPoint is edge or not.
           *
           * @param {BoundaryPoint} point
           * @return {Boolean}
           */

          function isEdgePoint(point) {
            return isLeftEdgePoint(point) || isRightEdgePoint(point);
          }
          /**
           * returns whether node is left edge of ancestor or not.
           *
           * @param {Node} node
           * @param {Node} ancestor
           * @return {Boolean}
           */

          function dom_isLeftEdgeOf(node, ancestor) {
            while (node && node !== ancestor) {
              if (dom_position(node) !== 0) {
                return false;
              }

              node = node.parentNode;
            }

            return true;
          }
          /**
           * returns whether node is right edge of ancestor or not.
           *
           * @param {Node} node
           * @param {Node} ancestor
           * @return {Boolean}
           */

          function isRightEdgeOf(node, ancestor) {
            if (!ancestor) {
              return false;
            }

            while (node && node !== ancestor) {
              if (dom_position(node) !== nodeLength(node.parentNode) - 1) {
                return false;
              }

              node = node.parentNode;
            }

            return true;
          }
          /**
           * returns whether point is left edge of ancestor or not.
           * @param {BoundaryPoint} point
           * @param {Node} ancestor
           * @return {Boolean}
           */

          function isLeftEdgePointOf(point, ancestor) {
            return isLeftEdgePoint(point) && dom_isLeftEdgeOf(point.node, ancestor);
          }
          /**
           * returns whether point is right edge of ancestor or not.
           * @param {BoundaryPoint} point
           * @param {Node} ancestor
           * @return {Boolean}
           */

          function isRightEdgePointOf(point, ancestor) {
            return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);
          }
          /**
           * returns offset from parent.
           *
           * @param {Node} node
           */

          function dom_position(node) {
            var offset = 0;

            while (node = node.previousSibling) {
              offset += 1;
            }

            return offset;
          }

          function hasChildren(node) {
            return !!(node && node.childNodes && node.childNodes.length);
          }
          /**
           * returns previous boundaryPoint
           *
           * @param {BoundaryPoint} point
           * @param {Boolean} isSkipInnerOffset
           * @return {BoundaryPoint}
           */

          function dom_prevPoint(point, isSkipInnerOffset) {
            var node;
            var offset;

            if (point.offset === 0) {
              if (isEditable(point.node)) {
                return null;
              }

              node = point.node.parentNode;
              offset = dom_position(point.node);
            } else if (hasChildren(point.node)) {
              node = point.node.childNodes[point.offset - 1];
              offset = nodeLength(node);
            } else {
              node = point.node;
              offset = isSkipInnerOffset ? 0 : point.offset - 1;
            }

            return {
              node: node,
              offset: offset
            };
          }
          /**
           * returns next boundaryPoint
           *
           * @param {BoundaryPoint} point
           * @param {Boolean} isSkipInnerOffset
           * @return {BoundaryPoint}
           */

          function dom_nextPoint(point, isSkipInnerOffset) {
            var node, offset;

            if (dom_isEmpty(point.node)) {
              return null;
            }

            if (nodeLength(point.node) === point.offset) {
              if (isEditable(point.node)) {
                return null;
              }

              node = point.node.parentNode;
              offset = dom_position(point.node) + 1;
            } else if (hasChildren(point.node)) {
              node = point.node.childNodes[point.offset];
              offset = 0;

              if (dom_isEmpty(node)) {
                return null;
              }
            } else {
              node = point.node;
              offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;

              if (dom_isEmpty(node)) {
                return null;
              }
            }

            return {
              node: node,
              offset: offset
            };
          }
          /**
           * returns whether pointA and pointB is same or not.
           *
           * @param {BoundaryPoint} pointA
           * @param {BoundaryPoint} pointB
           * @return {Boolean}
           */

          function isSamePoint(pointA, pointB) {
            return pointA.node === pointB.node && pointA.offset === pointB.offset;
          }
          /**
           * returns whether point is visible (can set cursor) or not.
           *
           * @param {BoundaryPoint} point
           * @return {Boolean}
           */

          function isVisiblePoint(point) {
            if (isText(point.node) || !hasChildren(point.node) || dom_isEmpty(point.node)) {
              return true;
            }

            var leftNode = point.node.childNodes[point.offset - 1];
            var rightNode = point.node.childNodes[point.offset];

            if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {
              return true;
            }

            return false;
          }
          /**
           * @method prevPointUtil
           *
           * @param {BoundaryPoint} point
           * @param {Function} pred
           * @return {BoundaryPoint}
           */

          function prevPointUntil(point, pred) {
            while (point) {
              if (pred(point)) {
                return point;
              }

              point = dom_prevPoint(point);
            }

            return null;
          }
          /**
           * @method nextPointUntil
           *
           * @param {BoundaryPoint} point
           * @param {Function} pred
           * @return {BoundaryPoint}
           */

          function nextPointUntil(point, pred) {
            while (point) {
              if (pred(point)) {
                return point;
              }

              point = dom_nextPoint(point);
            }

            return null;
          }
          /**
           * returns whether point has character or not.
           *
           * @param {Point} point
           * @return {Boolean}
           */

          function isCharPoint(point) {
            if (!isText(point.node)) {
              return false;
            }

            var ch = point.node.nodeValue.charAt(point.offset - 1);
            return ch && ch !== ' ' && ch !== NBSP_CHAR;
          }
          /**
           * returns whether point has space or not.
           *
           * @param {Point} point
           * @return {Boolean}
           */

          function isSpacePoint(point) {
            if (!isText(point.node)) {
              return false;
            }

            var ch = point.node.nodeValue.charAt(point.offset - 1);
            return ch === ' ' || ch === NBSP_CHAR;
          }
          /**
           * @method walkPoint
           *
           * @param {BoundaryPoint} startPoint
           * @param {BoundaryPoint} endPoint
           * @param {Function} handler
           * @param {Boolean} isSkipInnerOffset
           */

          function walkPoint(startPoint, endPoint, handler, isSkipInnerOffset) {
            var point = startPoint;

            while (point) {
              handler(point);

              if (isSamePoint(point, endPoint)) {
                break;
              }

              var isSkipOffset = isSkipInnerOffset && startPoint.node !== point.node && endPoint.node !== point.node;
              point = dom_nextPoint(point, isSkipOffset);
            }
          }
          /**
           * @method makeOffsetPath
           *
           * return offsetPath(array of offset) from ancestor
           *
           * @param {Node} ancestor - ancestor node
           * @param {Node} node
           */

          function makeOffsetPath(ancestor, node) {
            var ancestors = listAncestor(node, func.eq(ancestor));
            return ancestors.map(dom_position).reverse();
          }
          /**
           * @method fromOffsetPath
           *
           * return element from offsetPath(array of offset)
           *
           * @param {Node} ancestor - ancestor node
           * @param {array} offsets - offsetPath
           */

          function fromOffsetPath(ancestor, offsets) {
            var current = ancestor;

            for (var i = 0, len = offsets.length; i < len; i++) {
              if (current.childNodes.length <= offsets[i]) {
                current = current.childNodes[current.childNodes.length - 1];
              } else {
                current = current.childNodes[offsets[i]];
              }
            }

            return current;
          }
          /**
           * @method splitNode
           *
           * split element or #text
           *
           * @param {BoundaryPoint} point
           * @param {Object} [options]
           * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
           * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
           * @param {Boolean} [options.isDiscardEmptySplits] - default: false
           * @return {Node} right node of boundaryPoint
           */

          function splitNode(point, options) {
            var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
            var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;
            var isDiscardEmptySplits = options && options.isDiscardEmptySplits;

            if (isDiscardEmptySplits) {
              isSkipPaddingBlankHTML = true;
            } // edge case


            if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
              if (isLeftEdgePoint(point)) {
                return point.node;
              } else if (isRightEdgePoint(point)) {
                return point.node.nextSibling;
              }
            } // split #text


            if (isText(point.node)) {
              return point.node.splitText(point.offset);
            } else {
              var childNode = point.node.childNodes[point.offset];
              var clone = insertAfter(point.node.cloneNode(false), point.node);
              appendChildNodes(clone, listNext(childNode));

              if (!isSkipPaddingBlankHTML) {
                paddingBlankHTML(point.node);
                paddingBlankHTML(clone);
              }

              if (isDiscardEmptySplits) {
                if (dom_isEmpty(point.node)) {
                  remove(point.node);
                }

                if (dom_isEmpty(clone)) {
                  remove(clone);
                  return point.node.nextSibling;
                }
              }

              return clone;
            }
          }
          /**
           * @method splitTree
           *
           * split tree by point
           *
           * @param {Node} root - split root
           * @param {BoundaryPoint} point
           * @param {Object} [options]
           * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
           * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
           * @return {Node} right node of boundaryPoint
           */

          function splitTree(root, point, options) {
            // ex) [#text, <span>, <p>]
            var ancestors = listAncestor(point.node, func.eq(root));

            if (!ancestors.length) {
              return null;
            } else if (ancestors.length === 1) {
              return splitNode(point, options);
            }

            return ancestors.reduce(function (node, parent) {
              if (node === point.node) {
                node = splitNode(point, options);
              }

              return splitNode({
                node: parent,
                offset: node ? dom_position(node) : nodeLength(parent)
              }, options);
            });
          }
          /**
           * split point
           *
           * @param {Point} point
           * @param {Boolean} isInline
           * @return {Object}
           */

          function splitPoint(point, isInline) {
            // find splitRoot, container
            //  - inline: splitRoot is a child of paragraph
            //  - block: splitRoot is a child of bodyContainer
            var pred = isInline ? isPara : isBodyContainer;
            var ancestors = listAncestor(point.node, pred);
            var topAncestor = lists.last(ancestors) || point.node;
            var splitRoot, container;

            if (pred(topAncestor)) {
              splitRoot = ancestors[ancestors.length - 2];
              container = topAncestor;
            } else {
              splitRoot = topAncestor;
              container = splitRoot.parentNode;
            } // if splitRoot is exists, split with splitTree


            var pivot = splitRoot && splitTree(splitRoot, point, {
              isSkipPaddingBlankHTML: isInline,
              isNotSplitEdgePoint: isInline
            }); // if container is point.node, find pivot with point.offset

            if (!pivot && container === point.node) {
              pivot = point.node.childNodes[point.offset];
            }

            return {
              rightNode: pivot,
              container: container
            };
          }

          function dom_create(nodeName) {
            return document.createElement(nodeName);
          }

          function createText(text) {
            return document.createTextNode(text);
          }
          /**
           * @method remove
           *
           * remove node, (isRemoveChild: remove child or not)
           *
           * @param {Node} node
           * @param {Boolean} isRemoveChild
           */

          function remove(node, isRemoveChild) {
            if (!node || !node.parentNode) {
              return;
            }

            if (node.removeNode) {
              return node.removeNode(isRemoveChild);
            }

            var parent = node.parentNode;

            if (!isRemoveChild) {
              var nodes = [];

              for (var i = 0, len = node.childNodes.length; i < len; i++) {
                nodes.push(node.childNodes[i]);
              }

              for (var _i = 0, _len = nodes.length; _i < _len; _i++) {
                parent.insertBefore(nodes[_i], node);
              }
            }

            parent.removeChild(node);
          }
          /**
           * @method removeWhile
           *
           * @param {Node} node
           * @param {Function} pred
           */

          function removeWhile(node, pred) {
            while (node) {
              if (isEditable(node) || !pred(node)) {
                break;
              }

              var parent = node.parentNode;
              remove(node);
              node = parent;
            }
          }
          /**
           * @method replace
           *
           * replace node with provided nodeName
           *
           * @param {Node} node
           * @param {String} nodeName
           * @return {Node} - new node
           */

          function dom_replace(node, nodeName) {
            if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
              return node;
            }

            var newNode = dom_create(nodeName);

            if (node.style.cssText) {
              newNode.style.cssText = node.style.cssText;
            }

            appendChildNodes(newNode, lists.from(node.childNodes));
            insertAfter(newNode, node);
            remove(node);
            return newNode;
          }

          var isTextarea = makePredByNodeName('TEXTAREA');
          /**
           * @param {jQuery} $node
           * @param {Boolean} [stripLinebreaks] - default: false
           */

          function dom_value($node, stripLinebreaks) {
            var val = isTextarea($node[0]) ? $node.val() : $node.html();

            if (stripLinebreaks) {
              return val.replace(/[\n\r]/g, '');
            }

            return val;
          }
          /**
           * @method html
           *
           * get the HTML contents of node
           *
           * @param {jQuery} $node
           * @param {Boolean} [isNewlineOnBlock]
           */

          function dom_html($node, isNewlineOnBlock) {
            var markup = dom_value($node);

            if (isNewlineOnBlock) {
              var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
              markup = markup.replace(regexTag, function (match, endSlash, name) {
                name = name.toUpperCase();
                var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) && !!endSlash;
                var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);
                return match + (isEndOfInlineContainer || isBlockNode ? '\n' : '');
              });
              markup = markup.trim();
            }

            return markup;
          }

          function posFromPlaceholder(placeholder) {
            var $placeholder = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(placeholder);
            var pos = $placeholder.offset();
            var height = $placeholder.outerHeight(true); // include margin

            return {
              left: pos.left,
              top: pos.top + height
            };
          }

          function attachEvents($node, events) {
            Object.keys(events).forEach(function (key) {
              $node.on(key, events[key]);
            });
          }

          function detachEvents($node, events) {
            Object.keys(events).forEach(function (key) {
              $node.off(key, events[key]);
            });
          }
          /**
           * @method isCustomStyleTag
           *
           * assert if a node contains a "note-styletag" class,
           * which implies that's a custom-made style tag node
           *
           * @param {Node} an HTML DOM node
           */

          function isCustomStyleTag(node) {
            return node && !isText(node) && lists.contains(node.classList, 'note-styletag');
          }

          /* harmony default export */var dom = {
            /** @property {String} NBSP_CHAR */
            NBSP_CHAR: NBSP_CHAR,

            /** @property {String} ZERO_WIDTH_NBSP_CHAR */
            ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,

            /** @property {String} blank */
            blank: blankHTML,

            /** @property {String} emptyPara */
            emptyPara: "<p>".concat(blankHTML, "</p>"),
            makePredByNodeName: makePredByNodeName,
            isEditable: isEditable,
            isControlSizing: isControlSizing,
            isText: isText,
            isElement: isElement,
            isVoid: isVoid,
            isPara: isPara,
            isPurePara: isPurePara,
            isHeading: isHeading,
            isInline: dom_isInline,
            isBlock: func.not(dom_isInline),
            isBodyInline: isBodyInline,
            isBody: isBody,
            isParaInline: isParaInline,
            isPre: isPre,
            isList: isList,
            isTable: isTable,
            isData: isData,
            isCell: dom_isCell,
            isBlockquote: isBlockquote,
            isBodyContainer: isBodyContainer,
            isAnchor: isAnchor,
            isDiv: makePredByNodeName('DIV'),
            isLi: isLi,
            isBR: makePredByNodeName('BR'),
            isSpan: makePredByNodeName('SPAN'),
            isB: makePredByNodeName('B'),
            isU: makePredByNodeName('U'),
            isS: makePredByNodeName('S'),
            isI: makePredByNodeName('I'),
            isImg: makePredByNodeName('IMG'),
            isTextarea: isTextarea,
            deepestChildIsEmpty: deepestChildIsEmpty,
            isEmpty: dom_isEmpty,
            isEmptyAnchor: func.and(isAnchor, dom_isEmpty),
            isClosestSibling: isClosestSibling,
            withClosestSiblings: withClosestSiblings,
            nodeLength: nodeLength,
            isLeftEdgePoint: isLeftEdgePoint,
            isRightEdgePoint: isRightEdgePoint,
            isEdgePoint: isEdgePoint,
            isLeftEdgeOf: dom_isLeftEdgeOf,
            isRightEdgeOf: isRightEdgeOf,
            isLeftEdgePointOf: isLeftEdgePointOf,
            isRightEdgePointOf: isRightEdgePointOf,
            prevPoint: dom_prevPoint,
            nextPoint: dom_nextPoint,
            isSamePoint: isSamePoint,
            isVisiblePoint: isVisiblePoint,
            prevPointUntil: prevPointUntil,
            nextPointUntil: nextPointUntil,
            isCharPoint: isCharPoint,
            isSpacePoint: isSpacePoint,
            walkPoint: walkPoint,
            ancestor: dom_ancestor,
            singleChildAncestor: singleChildAncestor,
            listAncestor: listAncestor,
            lastAncestor: lastAncestor,
            listNext: listNext,
            listPrev: listPrev,
            listDescendant: listDescendant,
            commonAncestor: dom_commonAncestor,
            wrap: wrap,
            insertAfter: insertAfter,
            appendChildNodes: appendChildNodes,
            position: dom_position,
            hasChildren: hasChildren,
            makeOffsetPath: makeOffsetPath,
            fromOffsetPath: fromOffsetPath,
            splitTree: splitTree,
            splitPoint: splitPoint,
            create: dom_create,
            createText: createText,
            remove: remove,
            removeWhile: removeWhile,
            replace: dom_replace,
            html: dom_html,
            value: dom_value,
            posFromPlaceholder: posFromPlaceholder,
            attachEvents: attachEvents,
            detachEvents: detachEvents,
            isCustomStyleTag: isCustomStyleTag
          };
          // CONCATENATED MODULE: ./src/js/base/Context.js
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          var Context_Context =
          /*#__PURE__*/
          function () {
            /**
             * @param {jQuery} $note
             * @param {Object} options
             */
            function Context($note, options) {
              _classCallCheck(this, Context);

              this.$note = $note;
              this.memos = {};
              this.modules = {};
              this.layoutInfo = {};
              this.options = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(true, {}, options); // init ui with options

              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui_template(this.options);
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.initialize();
            }
            /**
             * create layout and initialize modules and other resources
             */

            _createClass(Context, [{
              key: "initialize",
              value: function initialize() {
                this.layoutInfo = this.ui.createLayout(this.$note);

                this._initialize();

                this.$note.hide();
                return this;
              }
              /**
               * destroy modules and other resources and remove layout
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this._destroy();

                this.$note.removeData('summernote');
                this.ui.removeLayout(this.$note, this.layoutInfo);
              }
              /**
               * destory modules and other resources and initialize it again
               */

            }, {
              key: "reset",
              value: function reset() {
                var disabled = this.isDisabled();
                this.code(dom.emptyPara);

                this._destroy();

                this._initialize();

                if (disabled) {
                  this.disable();
                }
              }
            }, {
              key: "_initialize",
              value: function _initialize() {
                var _this = this;

                // set own id
                this.options.id = func.uniqueId(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.now()); // set default container for tooltips, popovers, and dialogs

                this.options.container = this.options.container || this.layoutInfo.editor; // add optional buttons

                var buttons = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend({}, this.options.buttons);
                Object.keys(buttons).forEach(function (key) {
                  _this.memo('button.' + key, buttons[key]);
                });
                var modules = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend({}, this.options.modules, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.plugins || {}); // add and initialize modules

                Object.keys(modules).forEach(function (key) {
                  _this.module(key, modules[key], true);
                });
                Object.keys(this.modules).forEach(function (key) {
                  _this.initializeModule(key);
                });
              }
            }, {
              key: "_destroy",
              value: function _destroy() {
                var _this2 = this;

                // destroy modules with reversed order
                Object.keys(this.modules).reverse().forEach(function (key) {
                  _this2.removeModule(key);
                });
                Object.keys(this.memos).forEach(function (key) {
                  _this2.removeMemo(key);
                }); // trigger custom onDestroy callback

                this.triggerEvent('destroy', this);
              }
            }, {
              key: "code",
              value: function code(html) {
                var isActivated = this.invoke('codeview.isActivated');

                if (html === undefined) {
                  this.invoke('codeview.sync');
                  return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
                } else {
                  if (isActivated) {
                    this.layoutInfo.codable.val(html);
                  } else {
                    this.layoutInfo.editable.html(html);
                  }

                  this.$note.val(html);
                  this.triggerEvent('change', html, this.layoutInfo.editable);
                }
              }
            }, {
              key: "isDisabled",
              value: function isDisabled() {
                return this.layoutInfo.editable.attr('contenteditable') === 'false';
              }
            }, {
              key: "enable",
              value: function enable() {
                this.layoutInfo.editable.attr('contenteditable', true);
                this.invoke('toolbar.activate', true);
                this.triggerEvent('disable', false);
                this.options.editing = true;
              }
            }, {
              key: "disable",
              value: function disable() {
                // close codeview if codeview is opend
                if (this.invoke('codeview.isActivated')) {
                  this.invoke('codeview.deactivate');
                }

                this.layoutInfo.editable.attr('contenteditable', false);
                this.options.editing = false;
                this.invoke('toolbar.deactivate', true);
                this.triggerEvent('disable', true);
              }
            }, {
              key: "triggerEvent",
              value: function triggerEvent() {
                var namespace = lists.head(arguments);
                var args = lists.tail(lists.from(arguments));
                var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];

                if (callback) {
                  callback.apply(this.$note[0], args);
                }

                this.$note.trigger('summernote.' + namespace, args);
              }
            }, {
              key: "initializeModule",
              value: function initializeModule(key) {
                var module = this.modules[key];
                module.shouldInitialize = module.shouldInitialize || func.ok;

                if (!module.shouldInitialize()) {
                  return;
                } // initialize module


                if (module.initialize) {
                  module.initialize();
                } // attach events


                if (module.events) {
                  dom.attachEvents(this.$note, module.events);
                }
              }
            }, {
              key: "module",
              value: function module(key, ModuleClass, withoutIntialize) {
                if (arguments.length === 1) {
                  return this.modules[key];
                }

                this.modules[key] = new ModuleClass(this);

                if (!withoutIntialize) {
                  this.initializeModule(key);
                }
              }
            }, {
              key: "removeModule",
              value: function removeModule(key) {
                var module = this.modules[key];

                if (module.shouldInitialize()) {
                  if (module.events) {
                    dom.detachEvents(this.$note, module.events);
                  }

                  if (module.destroy) {
                    module.destroy();
                  }
                }

                delete this.modules[key];
              }
            }, {
              key: "memo",
              value: function memo(key, obj) {
                if (arguments.length === 1) {
                  return this.memos[key];
                }

                this.memos[key] = obj;
              }
            }, {
              key: "removeMemo",
              value: function removeMemo(key) {
                if (this.memos[key] && this.memos[key].destroy) {
                  this.memos[key].destroy();
                }

                delete this.memos[key];
              }
              /**
               * Some buttons need to change their visual style immediately once they get pressed
               */

            }, {
              key: "createInvokeHandlerAndUpdateState",
              value: function createInvokeHandlerAndUpdateState(namespace, value) {
                var _this3 = this;

                return function (event) {
                  _this3.createInvokeHandler(namespace, value)(event);

                  _this3.invoke('buttons.updateCurrentStyle');
                };
              }
            }, {
              key: "createInvokeHandler",
              value: function createInvokeHandler(namespace, value) {
                var _this4 = this;

                return function (event) {
                  event.preventDefault();
                  var $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(event.target);

                  _this4.invoke(namespace, value || $target.closest('[data-value]').data('value'), $target);
                };
              }
            }, {
              key: "invoke",
              value: function invoke() {
                var namespace = lists.head(arguments);
                var args = lists.tail(lists.from(arguments));
                var splits = namespace.split('.');
                var hasSeparator = splits.length > 1;
                var moduleName = hasSeparator && lists.head(splits);
                var methodName = hasSeparator ? lists.last(splits) : lists.head(splits);
                var module = this.modules[moduleName || 'editor'];

                if (!moduleName && this[methodName]) {
                  return this[methodName].apply(this, args);
                } else if (module && module[methodName] && module.shouldInitialize()) {
                  return module[methodName].apply(module, args);
                }
              }
            }]);

            return Context;
          }();

          // CONCATENATED MODULE: ./src/js/summernote.js


          external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.fn.extend({
            /**
             * Summernote API
             *
             * @param {Object|String}
             * @return {this}
             */
            summernote: function summernote() {
              var type = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.type(lists.head(arguments));
              var isExternalAPICalled = type === 'string';
              var hasInitOptions = type === 'object';
              var options = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend({}, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.options, hasInitOptions ? lists.head(arguments) : {}); // Update options

              options.langInfo = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(true, {}, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.lang['en-US'], external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.lang[options.lang]);
              options.icons = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(true, {}, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.options.icons, options.icons);
              options.tooltip = options.tooltip === 'auto' ? !env.isSupportTouch : options.tooltip;
              this.each(function (idx, note) {
                var $note = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(note);

                if (!$note.data('summernote')) {
                  var context = new Context_Context($note, options);
                  $note.data('summernote', context);
                  $note.data('summernote').triggerEvent('init', context.layoutInfo);
                }
              });
              var $note = this.first();

              if ($note.length) {
                var context = $note.data('summernote');

                if (isExternalAPICalled) {
                  return context.invoke.apply(context, lists.from(arguments));
                } else if (options.focus) {
                  context.invoke('editor.focus');
                }
              }

              return this;
            }
          });
          // CONCATENATED MODULE: ./src/js/base/core/range.js
          function range_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function range_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function range_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) range_defineProperties(Constructor.prototype, protoProps);if (staticProps) range_defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js
           *
           * @param {TextRange} textRange
           * @param {Boolean} isStart
           * @return {BoundaryPoint}
           *
           * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx
           */

          function textRangeToPoint(textRange, isStart) {
            var container = textRange.parentElement();
            var offset;
            var tester = document.body.createTextRange();
            var prevContainer;
            var childNodes = lists.from(container.childNodes);

            for (offset = 0; offset < childNodes.length; offset++) {
              if (dom.isText(childNodes[offset])) {
                continue;
              }

              tester.moveToElementText(childNodes[offset]);

              if (tester.compareEndPoints('StartToStart', textRange) >= 0) {
                break;
              }

              prevContainer = childNodes[offset];
            }

            if (offset !== 0 && dom.isText(childNodes[offset - 1])) {
              var textRangeStart = document.body.createTextRange();
              var curTextNode = null;
              textRangeStart.moveToElementText(prevContainer || container);
              textRangeStart.collapse(!prevContainer);
              curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;
              var pointTester = textRange.duplicate();
              pointTester.setEndPoint('StartToStart', textRangeStart);
              var textCount = pointTester.text.replace(/[\r\n]/g, '').length;

              while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
                textCount -= curTextNode.nodeValue.length;
                curTextNode = curTextNode.nextSibling;
              } // [workaround] enforce IE to re-reference curTextNode, hack


              var dummy = curTextNode.nodeValue; // eslint-disable-line

              if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) && textCount === curTextNode.nodeValue.length) {
                textCount -= curTextNode.nodeValue.length;
                curTextNode = curTextNode.nextSibling;
              }

              container = curTextNode;
              offset = textCount;
            }

            return {
              cont: container,
              offset: offset
            };
          }
          /**
           * return TextRange from boundary point (inspired by google closure-library)
           * @param {BoundaryPoint} point
           * @return {TextRange}
           */

          function pointToTextRange(point) {
            var textRangeInfo = function textRangeInfo(container, offset) {
              var node, isCollapseToStart;

              if (dom.isText(container)) {
                var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
                var prevContainer = lists.last(prevTextNodes).previousSibling;
                node = prevContainer || container.parentNode;
                offset += lists.sum(lists.tail(prevTextNodes), dom.nodeLength);
                isCollapseToStart = !prevContainer;
              } else {
                node = container.childNodes[offset] || container;

                if (dom.isText(node)) {
                  return textRangeInfo(node, 0);
                }

                offset = 0;
                isCollapseToStart = false;
              }

              return {
                node: node,
                collapseToStart: isCollapseToStart,
                offset: offset
              };
            };

            var textRange = document.body.createTextRange();
            var info = textRangeInfo(point.node, point.offset);
            textRange.moveToElementText(info.node);
            textRange.collapse(info.collapseToStart);
            textRange.moveStart('character', info.offset);
            return textRange;
          }
          /**
             * Wrapped Range
             *
             * @constructor
             * @param {Node} sc - start container
             * @param {Number} so - start offset
             * @param {Node} ec - end container
             * @param {Number} eo - end offset
             */

          var range_WrappedRange =
          /*#__PURE__*/
          function () {
            function WrappedRange(sc, so, ec, eo) {
              range_classCallCheck(this, WrappedRange);

              this.sc = sc;
              this.so = so;
              this.ec = ec;
              this.eo = eo; // isOnEditable: judge whether range is on editable or not

              this.isOnEditable = this.makeIsOn(dom.isEditable); // isOnList: judge whether range is on list node or not

              this.isOnList = this.makeIsOn(dom.isList); // isOnAnchor: judge whether range is on anchor node or not

              this.isOnAnchor = this.makeIsOn(dom.isAnchor); // isOnCell: judge whether range is on cell node or not

              this.isOnCell = this.makeIsOn(dom.isCell); // isOnData: judge whether range is on data node or not

              this.isOnData = this.makeIsOn(dom.isData);
            } // nativeRange: get nativeRange from sc, so, ec, eo


            range_createClass(WrappedRange, [{
              key: "nativeRange",
              value: function nativeRange() {
                if (env.isW3CRangeSupport) {
                  var w3cRange = document.createRange();
                  w3cRange.setStart(this.sc, this.sc.data && this.so > this.sc.data.length ? 0 : this.so);
                  w3cRange.setEnd(this.ec, this.sc.data ? Math.min(this.eo, this.sc.data.length) : this.eo);
                  return w3cRange;
                } else {
                  var textRange = pointToTextRange({
                    node: this.sc,
                    offset: this.so
                  });
                  textRange.setEndPoint('EndToEnd', pointToTextRange({
                    node: this.ec,
                    offset: this.eo
                  }));
                  return textRange;
                }
              }
            }, {
              key: "getPoints",
              value: function getPoints() {
                return {
                  sc: this.sc,
                  so: this.so,
                  ec: this.ec,
                  eo: this.eo
                };
              }
            }, {
              key: "getStartPoint",
              value: function getStartPoint() {
                return {
                  node: this.sc,
                  offset: this.so
                };
              }
            }, {
              key: "getEndPoint",
              value: function getEndPoint() {
                return {
                  node: this.ec,
                  offset: this.eo
                };
              }
              /**
               * select update visible range
               */

            }, {
              key: "select",
              value: function select() {
                var nativeRng = this.nativeRange();

                if (env.isW3CRangeSupport) {
                  var selection = document.getSelection();

                  if (selection.rangeCount > 0) {
                    selection.removeAllRanges();
                  }

                  selection.addRange(nativeRng);
                } else {
                  nativeRng.select();
                }

                return this;
              }
              /**
               * Moves the scrollbar to start container(sc) of current range
               *
               * @return {WrappedRange}
               */

            }, {
              key: "scrollIntoView",
              value: function scrollIntoView(container) {
                var height = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(container).height();

                if (container.scrollTop + height < this.sc.offsetTop) {
                  container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);
                }

                return this;
              }
              /**
               * @return {WrappedRange}
               */

            }, {
              key: "normalize",
              value: function normalize() {
                /**
                 * @param {BoundaryPoint} point
                 * @param {Boolean} isLeftToRight - true: prefer to choose right node
                 *                                - false: prefer to choose left node
                 * @return {BoundaryPoint}
                 */
                var getVisiblePoint = function getVisiblePoint(point, isLeftToRight) {
                  if (!point) {
                    return point;
                  } // Just use the given point [XXX:Adhoc]
                  //  - case 01. if the point is on the middle of the node
                  //  - case 02. if the point is on the right edge and prefer to choose left node
                  //  - case 03. if the point is on the left edge and prefer to choose right node
                  //  - case 04. if the point is on the right edge and prefer to choose right node but the node is void
                  //  - case 05. if the point is on the left edge and prefer to choose left node but the node is void
                  //  - case 06. if the point is on the block node and there is no children


                  if (dom.isVisiblePoint(point)) {
                    if (!dom.isEdgePoint(point) || dom.isRightEdgePoint(point) && !isLeftToRight || dom.isLeftEdgePoint(point) && isLeftToRight || dom.isRightEdgePoint(point) && isLeftToRight && dom.isVoid(point.node.nextSibling) || dom.isLeftEdgePoint(point) && !isLeftToRight && dom.isVoid(point.node.previousSibling) || dom.isBlock(point.node) && dom.isEmpty(point.node)) {
                      return point;
                    }
                  } // point on block's edge


                  var block = dom.ancestor(point.node, dom.isBlock);
                  var hasRightNode = false;

                  if (!hasRightNode) {
                    var prevPoint = dom.prevPoint(point) || {
                      node: null
                    };
                    hasRightNode = (dom.isLeftEdgePointOf(point, block) || dom.isVoid(prevPoint.node)) && !isLeftToRight;
                  }

                  var hasLeftNode = false;

                  if (!hasLeftNode) {
                    var _nextPoint = dom.nextPoint(point) || {
                      node: null
                    };

                    hasLeftNode = (dom.isRightEdgePointOf(point, block) || dom.isVoid(_nextPoint.node)) && isLeftToRight;
                  }

                  if (hasRightNode || hasLeftNode) {
                    // returns point already on visible point
                    if (dom.isVisiblePoint(point)) {
                      return point;
                    } // reverse direction


                    isLeftToRight = !isLeftToRight;
                  }

                  var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) : dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
                  return nextPoint || point;
                };

                var endPoint = getVisiblePoint(this.getEndPoint(), false);
                var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);
                return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
              }
              /**
               * returns matched nodes on range
               *
               * @param {Function} [pred] - predicate function
               * @param {Object} [options]
               * @param {Boolean} [options.includeAncestor]
               * @param {Boolean} [options.fullyContains]
               * @return {Node[]}
               */

            }, {
              key: "nodes",
              value: function nodes(pred, options) {
                pred = pred || func.ok;
                var includeAncestor = options && options.includeAncestor;
                var fullyContains = options && options.fullyContains; // TODO compare points and sort

                var startPoint = this.getStartPoint();
                var endPoint = this.getEndPoint();
                var nodes = [];
                var leftEdgeNodes = [];
                dom.walkPoint(startPoint, endPoint, function (point) {
                  if (dom.isEditable(point.node)) {
                    return;
                  }

                  var node;

                  if (fullyContains) {
                    if (dom.isLeftEdgePoint(point)) {
                      leftEdgeNodes.push(point.node);
                    }

                    if (dom.isRightEdgePoint(point) && lists.contains(leftEdgeNodes, point.node)) {
                      node = point.node;
                    }
                  } else if (includeAncestor) {
                    node = dom.ancestor(point.node, pred);
                  } else {
                    node = point.node;
                  }

                  if (node && pred(node)) {
                    nodes.push(node);
                  }
                }, true);
                return lists.unique(nodes);
              }
              /**
               * returns commonAncestor of range
               * @return {Element} - commonAncestor
               */

            }, {
              key: "commonAncestor",
              value: function commonAncestor() {
                return dom.commonAncestor(this.sc, this.ec);
              }
              /**
               * returns expanded range by pred
               *
               * @param {Function} pred - predicate function
               * @return {WrappedRange}
               */

            }, {
              key: "expand",
              value: function expand(pred) {
                var startAncestor = dom.ancestor(this.sc, pred);
                var endAncestor = dom.ancestor(this.ec, pred);

                if (!startAncestor && !endAncestor) {
                  return new WrappedRange(this.sc, this.so, this.ec, this.eo);
                }

                var boundaryPoints = this.getPoints();

                if (startAncestor) {
                  boundaryPoints.sc = startAncestor;
                  boundaryPoints.so = 0;
                }

                if (endAncestor) {
                  boundaryPoints.ec = endAncestor;
                  boundaryPoints.eo = dom.nodeLength(endAncestor);
                }

                return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
              }
              /**
               * @param {Boolean} isCollapseToStart
               * @return {WrappedRange}
               */

            }, {
              key: "collapse",
              value: function collapse(isCollapseToStart) {
                if (isCollapseToStart) {
                  return new WrappedRange(this.sc, this.so, this.sc, this.so);
                } else {
                  return new WrappedRange(this.ec, this.eo, this.ec, this.eo);
                }
              }
              /**
               * splitText on range
               */

            }, {
              key: "splitText",
              value: function splitText() {
                var isSameContainer = this.sc === this.ec;
                var boundaryPoints = this.getPoints();

                if (dom.isText(this.ec) && !dom.isEdgePoint(this.getEndPoint())) {
                  this.ec.splitText(this.eo);
                }

                if (dom.isText(this.sc) && !dom.isEdgePoint(this.getStartPoint())) {
                  boundaryPoints.sc = this.sc.splitText(this.so);
                  boundaryPoints.so = 0;

                  if (isSameContainer) {
                    boundaryPoints.ec = boundaryPoints.sc;
                    boundaryPoints.eo = this.eo - this.so;
                  }
                }

                return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
              }
              /**
               * delete contents on range
               * @return {WrappedRange}
               */

            }, {
              key: "deleteContents",
              value: function deleteContents() {
                if (this.isCollapsed()) {
                  return this;
                }

                var rng = this.splitText();
                var nodes = rng.nodes(null, {
                  fullyContains: true
                }); // find new cursor point

                var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {
                  return !lists.contains(nodes, point.node);
                });
                var emptyParents = [];
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(nodes, function (idx, node) {
                  // find empty parents
                  var parent = node.parentNode;

                  if (point.node !== parent && dom.nodeLength(parent) === 1) {
                    emptyParents.push(parent);
                  }

                  dom.remove(node, false);
                }); // remove empty parents

                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(emptyParents, function (idx, node) {
                  dom.remove(node, false);
                });
                return new WrappedRange(point.node, point.offset, point.node, point.offset).normalize();
              }
              /**
               * makeIsOn: return isOn(pred) function
               */

            }, {
              key: "makeIsOn",
              value: function makeIsOn(pred) {
                return function () {
                  var ancestor = dom.ancestor(this.sc, pred);
                  return !!ancestor && ancestor === dom.ancestor(this.ec, pred);
                };
              }
              /**
               * @param {Function} pred
               * @return {Boolean}
               */

            }, {
              key: "isLeftEdgeOf",
              value: function isLeftEdgeOf(pred) {
                if (!dom.isLeftEdgePoint(this.getStartPoint())) {
                  return false;
                }

                var node = dom.ancestor(this.sc, pred);
                return node && dom.isLeftEdgeOf(this.sc, node);
              }
              /**
               * returns whether range was collapsed or not
               */

            }, {
              key: "isCollapsed",
              value: function isCollapsed() {
                return this.sc === this.ec && this.so === this.eo;
              }
              /**
               * wrap inline nodes which children of body with paragraph
               *
               * @return {WrappedRange}
               */

            }, {
              key: "wrapBodyInlineWithPara",
              value: function wrapBodyInlineWithPara() {
                if (dom.isBodyContainer(this.sc) && dom.isEmpty(this.sc)) {
                  this.sc.innerHTML = dom.emptyPara;
                  return new WrappedRange(this.sc.firstChild, 0, this.sc.firstChild, 0);
                }
                /**
                 * [workaround] firefox often create range on not visible point. so normalize here.
                 *  - firefox: |<p>text</p>|
                 *  - chrome: <p>|text|</p>
                 */

                var rng = this.normalize();

                if (dom.isParaInline(this.sc) || dom.isPara(this.sc)) {
                  return rng;
                } // find inline top ancestor


                var topAncestor;

                if (dom.isInline(rng.sc)) {
                  var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
                  topAncestor = lists.last(ancestors);

                  if (!dom.isInline(topAncestor)) {
                    topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
                  }
                } else {
                  topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
                }

                if (topAncestor) {
                  // siblings not in paragraph
                  var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
                  inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline)); // wrap with paragraph

                  if (inlineSiblings.length) {
                    var para = dom.wrap(lists.head(inlineSiblings), 'p');
                    dom.appendChildNodes(para, lists.tail(inlineSiblings));
                  }
                }

                return this.normalize();
              }
              /**
               * insert node at current cursor
               *
               * @param {Node} node
               * @return {Node}
               */

            }, {
              key: "insertNode",
              value: function insertNode(node) {
                var rng = this;

                if (dom.isText(node) || dom.isInline(node)) {
                  rng = this.wrapBodyInlineWithPara().deleteContents();
                }

                var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));

                if (info.rightNode) {
                  info.rightNode.parentNode.insertBefore(node, info.rightNode);
                } else {
                  info.container.appendChild(node);
                }

                return node;
              }
              /**
               * insert html at current cursor
               */

            }, {
              key: "pasteHTML",
              value: function pasteHTML(markup) {
                markup = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.trim(markup);
                var contentsContainer = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div></div>').html(markup)[0];
                var childNodes = lists.from(contentsContainer.childNodes); // const rng = this.wrapBodyInlineWithPara().deleteContents();

                var rng = this;

                if (rng.so >= 0) {
                  childNodes = childNodes.reverse();
                }

                childNodes = childNodes.map(function (childNode) {
                  return rng.insertNode(childNode);
                });

                if (rng.so > 0) {
                  childNodes = childNodes.reverse();
                }

                return childNodes;
              }
              /**
               * returns text in range
               *
               * @return {String}
               */

            }, {
              key: "toString",
              value: function toString() {
                var nativeRng = this.nativeRange();
                return env.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
              }
              /**
               * returns range for word before cursor
               *
               * @param {Boolean} [findAfter] - find after cursor, default: false
               * @return {WrappedRange}
               */

            }, {
              key: "getWordRange",
              value: function getWordRange(findAfter) {
                var endPoint = this.getEndPoint();

                if (!dom.isCharPoint(endPoint)) {
                  return this;
                }

                var startPoint = dom.prevPointUntil(endPoint, function (point) {
                  return !dom.isCharPoint(point);
                });

                if (findAfter) {
                  endPoint = dom.nextPointUntil(endPoint, function (point) {
                    return !dom.isCharPoint(point);
                  });
                }

                return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
              }
              /**
               * returns range for words before cursor
               *
               * @param {Boolean} [findAfter] - find after cursor, default: false
               * @return {WrappedRange}
               */

            }, {
              key: "getWordsRange",
              value: function getWordsRange(findAfter) {
                var endPoint = this.getEndPoint();

                var isNotTextPoint = function isNotTextPoint(point) {
                  return !dom.isCharPoint(point) && !dom.isSpacePoint(point);
                };

                if (isNotTextPoint(endPoint)) {
                  return this;
                }

                var startPoint = dom.prevPointUntil(endPoint, isNotTextPoint);

                if (findAfter) {
                  endPoint = dom.nextPointUntil(endPoint, isNotTextPoint);
                }

                return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
              }
              /**
               * returns range for words before cursor that match with a Regex
               *
               * example:
               *  range: 'hi @Peter Pan'
               *  regex: '/@[a-z ]+/i'
               *  return range: '@Peter Pan'
               *
               * @param {RegExp} [regex]
               * @return {WrappedRange|null}
               */

            }, {
              key: "getWordsMatchRange",
              value: function getWordsMatchRange(regex) {
                var endPoint = this.getEndPoint();
                var startPoint = dom.prevPointUntil(endPoint, function (point) {
                  if (!dom.isCharPoint(point) && !dom.isSpacePoint(point)) {
                    return true;
                  }

                  var rng = new WrappedRange(point.node, point.offset, endPoint.node, endPoint.offset);
                  var result = regex.exec(rng.toString());
                  return result && result.index === 0;
                });
                var rng = new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
                var text = rng.toString();
                var result = regex.exec(text);

                if (result && result[0].length === text.length) {
                  return rng;
                } else {
                  return null;
                }
              }
              /**
               * create offsetPath bookmark
               *
               * @param {Node} editable
               */

            }, {
              key: "bookmark",
              value: function bookmark(editable) {
                return {
                  s: {
                    path: dom.makeOffsetPath(editable, this.sc),
                    offset: this.so
                  },
                  e: {
                    path: dom.makeOffsetPath(editable, this.ec),
                    offset: this.eo
                  }
                };
              }
              /**
               * create offsetPath bookmark base on paragraph
               *
               * @param {Node[]} paras
               */

            }, {
              key: "paraBookmark",
              value: function paraBookmark(paras) {
                return {
                  s: {
                    path: lists.tail(dom.makeOffsetPath(lists.head(paras), this.sc)),
                    offset: this.so
                  },
                  e: {
                    path: lists.tail(dom.makeOffsetPath(lists.last(paras), this.ec)),
                    offset: this.eo
                  }
                };
              }
              /**
               * getClientRects
               * @return {Rect[]}
               */

            }, {
              key: "getClientRects",
              value: function getClientRects() {
                var nativeRng = this.nativeRange();
                return nativeRng.getClientRects();
              }
            }]);

            return WrappedRange;
          }();
          /**
           * Data structure
           *  * BoundaryPoint: a point of dom tree
           *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range
           *
           * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position
           */

          /* harmony default export */var range = {
            /**
             * create Range Object From arguments or Browser Selection
             *
             * @param {Node} sc - start container
             * @param {Number} so - start offset
             * @param {Node} ec - end container
             * @param {Number} eo - end offset
             * @return {WrappedRange}
             */
            create: function create(sc, so, ec, eo) {
              if (arguments.length === 4) {
                return new range_WrappedRange(sc, so, ec, eo);
              } else if (arguments.length === 2) {
                // collapsed
                ec = sc;
                eo = so;
                return new range_WrappedRange(sc, so, ec, eo);
              } else {
                var wrappedRange = this.createFromSelection();

                if (!wrappedRange && arguments.length === 1) {
                  var bodyElement = arguments[0];

                  if (dom.isEditable(bodyElement)) {
                    bodyElement = bodyElement.lastChild;
                  }

                  return this.createFromBodyElement(bodyElement, dom.emptyPara === arguments[0].innerHTML);
                }

                return wrappedRange;
              }
            },
            createFromBodyElement: function createFromBodyElement(bodyElement) {
              var isCollapseToStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var wrappedRange = this.createFromNode(bodyElement);
              return wrappedRange.collapse(isCollapseToStart);
            },
            createFromSelection: function createFromSelection() {
              var sc, so, ec, eo;

              if (env.isW3CRangeSupport) {
                var selection = document.getSelection();

                if (!selection || selection.rangeCount === 0) {
                  return null;
                } else if (dom.isBody(selection.anchorNode)) {
                  // Firefox: returns entire body as range on initialization.
                  // We won't never need it.
                  return null;
                }

                var nativeRng = selection.getRangeAt(0);
                sc = nativeRng.startContainer;
                so = nativeRng.startOffset;
                ec = nativeRng.endContainer;
                eo = nativeRng.endOffset;
              } else {
                // IE8: TextRange
                var textRange = document.selection.createRange();
                var textRangeEnd = textRange.duplicate();
                textRangeEnd.collapse(false);
                var textRangeStart = textRange;
                textRangeStart.collapse(true);
                var startPoint = textRangeToPoint(textRangeStart, true);
                var endPoint = textRangeToPoint(textRangeEnd, false); // same visible point case: range was collapsed.

                if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) && dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) && endPoint.node.nextSibling === startPoint.node) {
                  startPoint = endPoint;
                }

                sc = startPoint.cont;
                so = startPoint.offset;
                ec = endPoint.cont;
                eo = endPoint.offset;
              }

              return new range_WrappedRange(sc, so, ec, eo);
            },

            /**
             * @method
             *
             * create WrappedRange from node
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNode: function createFromNode(node) {
              var sc = node;
              var so = 0;
              var ec = node;
              var eo = dom.nodeLength(ec); // browsers can't target a picture or void node

              if (dom.isVoid(sc)) {
                so = dom.listPrev(sc).length - 1;
                sc = sc.parentNode;
              }

              if (dom.isBR(ec)) {
                eo = dom.listPrev(ec).length - 1;
                ec = ec.parentNode;
              } else if (dom.isVoid(ec)) {
                eo = dom.listPrev(ec).length;
                ec = ec.parentNode;
              }

              return this.create(sc, so, ec, eo);
            },

            /**
             * create WrappedRange from node after position
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNodeBefore: function createFromNodeBefore(node) {
              return this.createFromNode(node).collapse(true);
            },

            /**
             * create WrappedRange from node after position
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNodeAfter: function createFromNodeAfter(node) {
              return this.createFromNode(node).collapse();
            },

            /**
             * @method
             *
             * create WrappedRange from bookmark
             *
             * @param {Node} editable
             * @param {Object} bookmark
             * @return {WrappedRange}
             */
            createFromBookmark: function createFromBookmark(editable, bookmark) {
              var sc = dom.fromOffsetPath(editable, bookmark.s.path);
              var so = bookmark.s.offset;
              var ec = dom.fromOffsetPath(editable, bookmark.e.path);
              var eo = bookmark.e.offset;
              return new range_WrappedRange(sc, so, ec, eo);
            },

            /**
             * @method
             *
             * create WrappedRange from paraBookmark
             *
             * @param {Object} bookmark
             * @param {Node[]} paras
             * @return {WrappedRange}
             */
            createFromParaBookmark: function createFromParaBookmark(bookmark, paras) {
              var so = bookmark.s.offset;
              var eo = bookmark.e.offset;
              var sc = dom.fromOffsetPath(lists.head(paras), bookmark.s.path);
              var ec = dom.fromOffsetPath(lists.last(paras), bookmark.e.path);
              return new range_WrappedRange(sc, so, ec, eo);
            }
          };
          // CONCATENATED MODULE: ./src/js/base/core/key.js


          var KEY_MAP = {
            'BACKSPACE': 8,
            'TAB': 9,
            'ENTER': 13,
            'SPACE': 32,
            'DELETE': 46,
            // Arrow
            'LEFT': 37,
            'UP': 38,
            'RIGHT': 39,
            'DOWN': 40,
            // Number: 0-9
            'NUM0': 48,
            'NUM1': 49,
            'NUM2': 50,
            'NUM3': 51,
            'NUM4': 52,
            'NUM5': 53,
            'NUM6': 54,
            'NUM7': 55,
            'NUM8': 56,
            // Alphabet: a-z
            'B': 66,
            'E': 69,
            'I': 73,
            'J': 74,
            'K': 75,
            'L': 76,
            'R': 82,
            'S': 83,
            'U': 85,
            'V': 86,
            'Y': 89,
            'Z': 90,
            'SLASH': 191,
            'LEFTBRACKET': 219,
            'BACKSLASH': 220,
            'RIGHTBRACKET': 221,
            // Navigation
            'HOME': 36,
            'END': 35,
            'PAGEUP': 33,
            'PAGEDOWN': 34
          };
          /**
           * @class core.key
           *
           * Object for keycodes.
           *
           * @singleton
           * @alternateClassName key
           */

          /* harmony default export */var core_key = {
            /**
             * @method isEdit
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isEdit: function isEdit(keyCode) {
              return lists.contains([KEY_MAP.BACKSPACE, KEY_MAP.TAB, KEY_MAP.ENTER, KEY_MAP.SPACE, KEY_MAP.DELETE], keyCode);
            },

            /**
             * @method isMove
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isMove: function isMove(keyCode) {
              return lists.contains([KEY_MAP.LEFT, KEY_MAP.UP, KEY_MAP.RIGHT, KEY_MAP.DOWN], keyCode);
            },

            /**
             * @method isNavigation
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isNavigation: function isNavigation(keyCode) {
              return lists.contains([KEY_MAP.HOME, KEY_MAP.END, KEY_MAP.PAGEUP, KEY_MAP.PAGEDOWN], keyCode);
            },

            /**
             * @property {Object} nameFromCode
             * @property {String} nameFromCode.8 "BACKSPACE"
             */
            nameFromCode: func.invertObject(KEY_MAP),
            code: KEY_MAP
          };
          // CONCATENATED MODULE: ./src/js/base/core/async.js

          /**
           * @method readFileAsDataURL
           *
           * read contents of file as representing URL
           *
           * @param {File} file
           * @return {Promise} - then: dataUrl
           */

          function readFileAsDataURL(file) {
            return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(new FileReader(), {
                onload: function onload(e) {
                  var dataURL = e.target.result;
                  deferred.resolve(dataURL);
                },
                onerror: function onerror(err) {
                  deferred.reject(err);
                }
              }).readAsDataURL(file);
            }).promise();
          }
          /**
           * @method createImage
           *
           * create `<image>` from url string
           *
           * @param {String} url
           * @return {Promise} - then: $image
           */

          function createImage(url) {
            return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
              var $img = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<img>');
              $img.one('load', function () {
                $img.off('error abort');
                deferred.resolve($img);
              }).one('error abort', function () {
                $img.off('load').detach();
                deferred.reject($img);
              }).css({
                display: 'none'
              }).appendTo(document.body).attr('src', url);
            }).promise();
          }
          // CONCATENATED MODULE: ./src/js/base/editing/History.js
          function History_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function History_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function History_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) History_defineProperties(Constructor.prototype, protoProps);if (staticProps) History_defineProperties(Constructor, staticProps);return Constructor;
          }

          var History_History =
          /*#__PURE__*/
          function () {
            function History(context) {
              History_classCallCheck(this, History);

              this.stack = [];
              this.stackOffset = -1;
              this.context = context;
              this.$editable = context.layoutInfo.editable;
              this.editable = this.$editable[0];
            }

            History_createClass(History, [{
              key: "makeSnapshot",
              value: function makeSnapshot() {
                var rng = range.create(this.editable);
                var emptyBookmark = {
                  s: {
                    path: [],
                    offset: 0
                  },
                  e: {
                    path: [],
                    offset: 0
                  }
                };
                return {
                  contents: this.$editable.html(),
                  bookmark: rng && rng.isOnEditable() ? rng.bookmark(this.editable) : emptyBookmark
                };
              }
            }, {
              key: "applySnapshot",
              value: function applySnapshot(snapshot) {
                if (snapshot.contents !== null) {
                  this.$editable.html(snapshot.contents);
                }

                if (snapshot.bookmark !== null) {
                  range.createFromBookmark(this.editable, snapshot.bookmark).select();
                }
              }
              /**
              * @method rewind
              * Rewinds the history stack back to the first snapshot taken.
              * Leaves the stack intact, so that "Redo" can still be used.
              */

            }, {
              key: "rewind",
              value: function rewind() {
                // Create snap shot if not yet recorded
                if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                  this.recordUndo();
                } // Return to the first available snapshot.


                this.stackOffset = 0; // Apply that snapshot.

                this.applySnapshot(this.stack[this.stackOffset]);
              }
              /**
              *  @method commit
              *  Resets history stack, but keeps current editor's content.
              */

            }, {
              key: "commit",
              value: function commit() {
                // Clear the stack.
                this.stack = []; // Restore stackOffset to its original value.

                this.stackOffset = -1; // Record our first snapshot (of nothing).

                this.recordUndo();
              }
              /**
              * @method reset
              * Resets the history stack completely; reverting to an empty editor.
              */

            }, {
              key: "reset",
              value: function reset() {
                // Clear the stack.
                this.stack = []; // Restore stackOffset to its original value.

                this.stackOffset = -1; // Clear the editable area.

                this.$editable.html(''); // Record our first snapshot (of nothing).

                this.recordUndo();
              }
              /**
               * undo
               */

            }, {
              key: "undo",
              value: function undo() {
                // Create snap shot if not yet recorded
                if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                  this.recordUndo();
                }

                if (this.stackOffset > 0) {
                  this.stackOffset--;
                  this.applySnapshot(this.stack[this.stackOffset]);
                }
              }
              /**
               * redo
               */

            }, {
              key: "redo",
              value: function redo() {
                if (this.stack.length - 1 > this.stackOffset) {
                  this.stackOffset++;
                  this.applySnapshot(this.stack[this.stackOffset]);
                }
              }
              /**
               * recorded undo
               */

            }, {
              key: "recordUndo",
              value: function recordUndo() {
                this.stackOffset++; // Wash out stack after stackOffset

                if (this.stack.length > this.stackOffset) {
                  this.stack = this.stack.slice(0, this.stackOffset);
                } // Create new snapshot and push it to the end


                this.stack.push(this.makeSnapshot()); // If the stack size reachs to the limit, then slice it

                if (this.stack.length > this.context.options.historyLimit) {
                  this.stack.shift();
                  this.stackOffset -= 1;
                }
              }
            }]);

            return History;
          }();

          // CONCATENATED MODULE: ./src/js/base/editing/Style.js
          function Style_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Style_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Style_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Style_defineProperties(Constructor.prototype, protoProps);if (staticProps) Style_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Style_Style =
          /*#__PURE__*/
          function () {
            function Style() {
              Style_classCallCheck(this, Style);
            }

            Style_createClass(Style, [{
              key: "jQueryCSS",

              /**
               * @method jQueryCSS
               *
               * [workaround] for old jQuery
               * passing an array of style properties to .css()
               * will result in an object of property-value pairs.
               * (compability with version < 1.9)
               *
               * @private
               * @param  {jQuery} $obj
               * @param  {Array} propertyNames - An array of one or more CSS properties.
               * @return {Object}
               */
              value: function jQueryCSS($obj, propertyNames) {
                if (env.jqueryVersion < 1.9) {
                  var result = {};
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(propertyNames, function (idx, propertyName) {
                    result[propertyName] = $obj.css(propertyName);
                  });
                  return result;
                }

                return $obj.css(propertyNames);
              }
              /**
               * returns style object from node
               *
               * @param {jQuery} $node
               * @return {Object}
               */

            }, {
              key: "fromNode",
              value: function fromNode($node) {
                var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];
                var styleInfo = this.jQueryCSS($node, properties) || {};
                var fontSize = $node[0].style.fontSize || styleInfo['font-size'];
                styleInfo['font-size'] = parseInt(fontSize, 10);
                styleInfo['font-size-unit'] = fontSize.match(/[a-z%]+$/);
                return styleInfo;
              }
              /**
               * paragraph level style
               *
               * @param {WrappedRange} rng
               * @param {Object} styleInfo
               */

            }, {
              key: "stylePara",
              value: function stylePara(rng, styleInfo) {
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(rng.nodes(dom.isPara, {
                  includeAncestor: true
                }), function (idx, para) {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(para).css(styleInfo);
                });
              }
              /**
               * insert and returns styleNodes on range.
               *
               * @param {WrappedRange} rng
               * @param {Object} [options] - options for styleNodes
               * @param {String} [options.nodeName] - default: `SPAN`
               * @param {Boolean} [options.expandClosestSibling] - default: `false`
               * @param {Boolean} [options.onlyPartialContains] - default: `false`
               * @return {Node[]}
               */

            }, {
              key: "styleNodes",
              value: function styleNodes(rng, options) {
                rng = rng.splitText();
                var nodeName = options && options.nodeName || 'SPAN';
                var expandClosestSibling = !!(options && options.expandClosestSibling);
                var onlyPartialContains = !!(options && options.onlyPartialContains);

                if (rng.isCollapsed()) {
                  return [rng.insertNode(dom.create(nodeName))];
                }

                var pred = dom.makePredByNodeName(nodeName);
                var nodes = rng.nodes(dom.isText, {
                  fullyContains: true
                }).map(function (text) {
                  return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);
                });

                if (expandClosestSibling) {
                  if (onlyPartialContains) {
                    var nodesInRange = rng.nodes(); // compose with partial contains predication

                    pred = func.and(pred, function (node) {
                      return lists.contains(nodesInRange, node);
                    });
                  }

                  return nodes.map(function (node) {
                    var siblings = dom.withClosestSiblings(node, pred);
                    var head = lists.head(siblings);
                    var tails = lists.tail(siblings);
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(tails, function (idx, elem) {
                      dom.appendChildNodes(head, elem.childNodes);
                      dom.remove(elem);
                    });
                    return lists.head(siblings);
                  });
                } else {
                  return nodes;
                }
              }
              /**
               * get current style on cursor
               *
               * @param {WrappedRange} rng
               * @return {Object} - object contains style properties.
               */

            }, {
              key: "current",
              value: function current(rng) {
                var $cont = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);
                var styleInfo = this.fromNode($cont); // document.queryCommandState for toggle state
                // [workaround] prevent Firefox nsresult: "0x80004005 (NS_ERROR_FAILURE)"

                try {
                  styleInfo = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(styleInfo, {
                    'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',
                    'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',
                    'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',
                    'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',
                    'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',
                    'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal',
                    'font-family': document.queryCommandValue('fontname') || styleInfo['font-family']
                  });
                } catch (e) {} // eslint-disable-next-line
                // list-style-type to list-style(unordered, ordered)


                if (!rng.isOnList()) {
                  styleInfo['list-style'] = 'none';
                } else {
                  var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];
                  var isUnordered = orderedTypes.indexOf(styleInfo['list-style-type']) > -1;
                  styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';
                }

                var para = dom.ancestor(rng.sc, dom.isPara);

                if (para && para.style['line-height']) {
                  styleInfo['line-height'] = para.style.lineHeight;
                } else {
                  var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);
                  styleInfo['line-height'] = lineHeight.toFixed(1);
                }

                styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
                styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
                styleInfo.range = rng;
                return styleInfo;
              }
            }]);

            return Style;
          }();

          // CONCATENATED MODULE: ./src/js/base/editing/Bullet.js
          function Bullet_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Bullet_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Bullet_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Bullet_defineProperties(Constructor.prototype, protoProps);if (staticProps) Bullet_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Bullet_Bullet =
          /*#__PURE__*/
          function () {
            function Bullet() {
              Bullet_classCallCheck(this, Bullet);
            }

            Bullet_createClass(Bullet, [{
              key: "insertOrderedList",

              /**
               * toggle ordered list
               */
              value: function insertOrderedList(editable) {
                this.toggleList('OL', editable);
              }
              /**
               * toggle unordered list
               */

            }, {
              key: "insertUnorderedList",
              value: function insertUnorderedList(editable) {
                this.toggleList('UL', editable);
              }
              /**
               * indent
               */

            }, {
              key: "indent",
              value: function indent(editable) {
                var _this = this;

                var rng = range.create(editable).wrapBodyInlineWithPara();
                var paras = rng.nodes(dom.isPara, {
                  includeAncestor: true
                });
                var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(clustereds, function (idx, paras) {
                  var head = lists.head(paras);

                  if (dom.isLi(head)) {
                    var previousList = _this.findList(head.previousSibling);

                    if (previousList) {
                      paras.map(function (para) {
                        return previousList.appendChild(para);
                      });
                    } else {
                      _this.wrapList(paras, head.parentNode.nodeName);

                      paras.map(function (para) {
                        return para.parentNode;
                      }).map(function (para) {
                        return _this.appendToPrevious(para);
                      });
                    }
                  } else {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(paras, function (idx, para) {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(para).css('marginLeft', function (idx, val) {
                        return (parseInt(val, 10) || 0) + 25;
                      });
                    });
                  }
                });
                rng.select();
              }
              /**
               * outdent
               */

            }, {
              key: "outdent",
              value: function outdent(editable) {
                var _this2 = this;

                var rng = range.create(editable).wrapBodyInlineWithPara();
                var paras = rng.nodes(dom.isPara, {
                  includeAncestor: true
                });
                var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(clustereds, function (idx, paras) {
                  var head = lists.head(paras);

                  if (dom.isLi(head)) {
                    _this2.releaseList([paras]);
                  } else {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(paras, function (idx, para) {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(para).css('marginLeft', function (idx, val) {
                        val = parseInt(val, 10) || 0;
                        return val > 25 ? val - 25 : '';
                      });
                    });
                  }
                });
                rng.select();
              }
              /**
               * toggle list
               *
               * @param {String} listName - OL or UL
               */

            }, {
              key: "toggleList",
              value: function toggleList(listName, editable) {
                var _this3 = this;

                var rng = range.create(editable).wrapBodyInlineWithPara();
                var paras = rng.nodes(dom.isPara, {
                  includeAncestor: true
                });
                var bookmark = rng.paraBookmark(paras);
                var clustereds = lists.clusterBy(paras, func.peq2('parentNode')); // paragraph to list

                if (lists.find(paras, dom.isPurePara)) {
                  var wrappedParas = [];
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(clustereds, function (idx, paras) {
                    wrappedParas = wrappedParas.concat(_this3.wrapList(paras, listName));
                  });
                  paras = wrappedParas; // list to paragraph or change list style
                } else {
                  var diffLists = rng.nodes(dom.isList, {
                    includeAncestor: true
                  }).filter(function (listNode) {
                    return !external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.nodeName(listNode, listName);
                  });

                  if (diffLists.length) {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(diffLists, function (idx, listNode) {
                      dom.replace(listNode, listName);
                    });
                  } else {
                    paras = this.releaseList(clustereds, true);
                  }
                }

                range.createFromParaBookmark(bookmark, paras).select();
              }
              /**
               * @param {Node[]} paras
               * @param {String} listName
               * @return {Node[]}
               */

            }, {
              key: "wrapList",
              value: function wrapList(paras, listName) {
                var head = lists.head(paras);
                var last = lists.last(paras);
                var prevList = dom.isList(head.previousSibling) && head.previousSibling;
                var nextList = dom.isList(last.nextSibling) && last.nextSibling;
                var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last); // P to LI

                paras = paras.map(function (para) {
                  return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;
                }); // append to list(<ul>, <ol>)

                dom.appendChildNodes(listNode, paras);

                if (nextList) {
                  dom.appendChildNodes(listNode, lists.from(nextList.childNodes));
                  dom.remove(nextList);
                }

                return paras;
              }
              /**
               * @method releaseList
               *
               * @param {Array[]} clustereds
               * @param {Boolean} isEscapseToBody
               * @return {Node[]}
               */

            }, {
              key: "releaseList",
              value: function releaseList(clustereds, isEscapseToBody) {
                var _this4 = this;

                var releasedParas = [];
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(clustereds, function (idx, paras) {
                  var head = lists.head(paras);
                  var last = lists.last(paras);
                  var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) : head.parentNode;
                  var parentItem = headList.parentNode;

                  if (headList.parentNode.nodeName === 'LI') {
                    paras.map(function (para) {
                      var newList = _this4.findNextSiblings(para);

                      if (parentItem.nextSibling) {
                        parentItem.parentNode.insertBefore(para, parentItem.nextSibling);
                      } else {
                        parentItem.parentNode.appendChild(para);
                      }

                      if (newList.length) {
                        _this4.wrapList(newList, headList.nodeName);

                        para.appendChild(newList[0].parentNode);
                      }
                    });

                    if (headList.children.length === 0) {
                      parentItem.removeChild(headList);
                    }

                    if (parentItem.childNodes.length === 0) {
                      parentItem.parentNode.removeChild(parentItem);
                    }
                  } else {
                    var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
                      node: last.parentNode,
                      offset: dom.position(last) + 1
                    }, {
                      isSkipPaddingBlankHTML: true
                    }) : null;
                    var middleList = dom.splitTree(headList, {
                      node: head.parentNode,
                      offset: dom.position(head)
                    }, {
                      isSkipPaddingBlankHTML: true
                    });
                    paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) : lists.from(middleList.childNodes).filter(dom.isLi); // LI to P

                    if (isEscapseToBody || !dom.isList(headList.parentNode)) {
                      paras = paras.map(function (para) {
                        return dom.replace(para, 'P');
                      });
                    }

                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(lists.from(paras).reverse(), function (idx, para) {
                      dom.insertAfter(para, headList);
                    }); // remove empty lists

                    var rootLists = lists.compact([headList, middleList, lastList]);
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(rootLists, function (idx, rootList) {
                      var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(listNodes.reverse(), function (idx, listNode) {
                        if (!dom.nodeLength(listNode)) {
                          dom.remove(listNode, true);
                        }
                      });
                    });
                  }

                  releasedParas = releasedParas.concat(paras);
                });
                return releasedParas;
              }
              /**
               * @method appendToPrevious
               *
               * Appends list to previous list item, if
               * none exist it wraps the list in a new list item.
               *
               * @param {HTMLNode} ListItem
               * @return {HTMLNode}
               */

            }, {
              key: "appendToPrevious",
              value: function appendToPrevious(node) {
                return node.previousSibling ? dom.appendChildNodes(node.previousSibling, [node]) : this.wrapList([node], 'LI');
              }
              /**
               * @method findList
               *
               * Finds an existing list in list item
               *
               * @param {HTMLNode} ListItem
               * @return {Array[]}
               */

            }, {
              key: "findList",
              value: function findList(node) {
                return node ? lists.find(node.children, function (child) {
                  return ['OL', 'UL'].indexOf(child.nodeName) > -1;
                }) : null;
              }
              /**
               * @method findNextSiblings
               *
               * Finds all list item siblings that follow it
               *
               * @param {HTMLNode} ListItem
               * @return {HTMLNode}
               */

            }, {
              key: "findNextSiblings",
              value: function findNextSiblings(node) {
                var siblings = [];

                while (node.nextSibling) {
                  siblings.push(node.nextSibling);
                  node = node.nextSibling;
                }

                return siblings;
              }
            }]);

            return Bullet;
          }();

          // CONCATENATED MODULE: ./src/js/base/editing/Typing.js
          function Typing_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Typing_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Typing_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Typing_defineProperties(Constructor.prototype, protoProps);if (staticProps) Typing_defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * @class editing.Typing
           *
           * Typing
           *
           */

          var Typing_Typing =
          /*#__PURE__*/
          function () {
            function Typing(context) {
              Typing_classCallCheck(this, Typing);

              // a Bullet instance to toggle lists off
              this.bullet = new Bullet_Bullet();
              this.options = context.options;
            }
            /**
             * insert tab
             *
             * @param {WrappedRange} rng
             * @param {Number} tabsize
             */

            Typing_createClass(Typing, [{
              key: "insertTab",
              value: function insertTab(rng, tabsize) {
                var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
                rng = rng.deleteContents();
                rng.insertNode(tab, true);
                rng = range.create(tab, tabsize);
                rng.select();
              }
              /**
               * insert paragraph
               *
               * @param {jQuery} $editable
               * @param {WrappedRange} rng Can be used in unit tests to "mock" the range
               *
               * blockquoteBreakingLevel
               *   0 - No break, the new paragraph remains inside the quote
               *   1 - Break the first blockquote in the ancestors list
               *   2 - Break all blockquotes, so that the new paragraph is not quoted (this is the default)
               */

            }, {
              key: "insertParagraph",
              value: function insertParagraph(editable, rng) {
                rng = rng || range.create(editable); // deleteContents on range.

                rng = rng.deleteContents(); // Wrap range if it needs to be wrapped by paragraph

                rng = rng.wrapBodyInlineWithPara(); // finding paragraph

                var splitRoot = dom.ancestor(rng.sc, dom.isPara);
                var nextPara; // on paragraph: split paragraph

                if (splitRoot) {
                  // if it is an empty line with li
                  if (dom.isLi(splitRoot) && (dom.isEmpty(splitRoot) || dom.deepestChildIsEmpty(splitRoot))) {
                    // toogle UL/OL and escape
                    this.bullet.toggleList(splitRoot.parentNode.nodeName);
                    return;
                  } else {
                    var blockquote = null;

                    if (this.options.blockquoteBreakingLevel === 1) {
                      blockquote = dom.ancestor(splitRoot, dom.isBlockquote);
                    } else if (this.options.blockquoteBreakingLevel === 2) {
                      blockquote = dom.lastAncestor(splitRoot, dom.isBlockquote);
                    }

                    if (blockquote) {
                      // We're inside a blockquote and options ask us to break it
                      nextPara = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(dom.emptyPara)[0]; // If the split is right before a <br>, remove it so that there's no "empty line"
                      // after the split in the new blockquote created

                      if (dom.isRightEdgePoint(rng.getStartPoint()) && dom.isBR(rng.sc.nextSibling)) {
                        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(rng.sc.nextSibling).remove();
                      }

                      var split = dom.splitTree(blockquote, rng.getStartPoint(), {
                        isDiscardEmptySplits: true
                      });

                      if (split) {
                        split.parentNode.insertBefore(nextPara, split);
                      } else {
                        dom.insertAfter(nextPara, blockquote); // There's no split if we were at the end of the blockquote
                      }
                    } else {
                      nextPara = dom.splitTree(splitRoot, rng.getStartPoint()); // not a blockquote, just insert the paragraph

                      var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
                      emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(emptyAnchors, function (idx, anchor) {
                        dom.remove(anchor);
                      }); // replace empty heading, pre or custom-made styleTag with P tag

                      if ((dom.isHeading(nextPara) || dom.isPre(nextPara) || dom.isCustomStyleTag(nextPara)) && dom.isEmpty(nextPara)) {
                        nextPara = dom.replace(nextPara, 'p');
                      }
                    }
                  } // no paragraph: insert empty paragraph
                } else {
                  var next = rng.sc.childNodes[rng.so];
                  nextPara = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(dom.emptyPara)[0];

                  if (next) {
                    rng.sc.insertBefore(nextPara, next);
                  } else {
                    rng.sc.appendChild(nextPara);
                  }
                }

                range.create(nextPara, 0).normalize().select().scrollIntoView(editable);
              }
            }]);

            return Typing;
          }();

          // CONCATENATED MODULE: ./src/js/base/editing/Table.js
          function Table_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Table_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Table_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Table_defineProperties(Constructor.prototype, protoProps);if (staticProps) Table_defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * @class Create a virtual table to create what actions to do in change.
           * @param {object} startPoint Cell selected to apply change.
           * @param {enum} where  Where change will be applied Row or Col. Use enum: TableResultAction.where
           * @param {enum} action Action to be applied. Use enum: TableResultAction.requestAction
           * @param {object} domTable Dom element of table to make changes.
           */

          var TableResultAction = function TableResultAction(startPoint, where, action, domTable) {
            var _startPoint = {
              'colPos': 0,
              'rowPos': 0
            };
            var _virtualTable = [];
            var _actionCellList = []; /// ///////////////////////////////////////////
            // Private functions
            /// ///////////////////////////////////////////

            /**
             * Set the startPoint of action.
             */

            function setStartPoint() {
              if (!startPoint || !startPoint.tagName || startPoint.tagName.toLowerCase() !== 'td' && startPoint.tagName.toLowerCase() !== 'th') {
                // Impossible to identify start Cell point
                return;
              }

              _startPoint.colPos = startPoint.cellIndex;

              if (!startPoint.parentElement || !startPoint.parentElement.tagName || startPoint.parentElement.tagName.toLowerCase() !== 'tr') {
                // Impossible to identify start Row point
                return;
              }

              _startPoint.rowPos = startPoint.parentElement.rowIndex;
            }
            /**
             * Define virtual table position info object.
             *
             * @param {int} rowIndex Index position in line of virtual table.
             * @param {int} cellIndex Index position in column of virtual table.
             * @param {object} baseRow Row affected by this position.
             * @param {object} baseCell Cell affected by this position.
             * @param {bool} isSpan Inform if it is an span cell/row.
             */

            function setVirtualTablePosition(rowIndex, cellIndex, baseRow, baseCell, isRowSpan, isColSpan, isVirtualCell) {
              var objPosition = {
                'baseRow': baseRow,
                'baseCell': baseCell,
                'isRowSpan': isRowSpan,
                'isColSpan': isColSpan,
                'isVirtual': isVirtualCell
              };

              if (!_virtualTable[rowIndex]) {
                _virtualTable[rowIndex] = [];
              }

              _virtualTable[rowIndex][cellIndex] = objPosition;
            }
            /**
             * Create action cell object.
             *
             * @param {object} virtualTableCellObj Object of specific position on virtual table.
             * @param {enum} resultAction Action to be applied in that item.
             */

            function getActionCell(virtualTableCellObj, resultAction, virtualRowPosition, virtualColPosition) {
              return {
                'baseCell': virtualTableCellObj.baseCell,
                'action': resultAction,
                'virtualTable': {
                  'rowIndex': virtualRowPosition,
                  'cellIndex': virtualColPosition
                }
              };
            }
            /**
             * Recover free index of row to append Cell.
             *
             * @param {int} rowIndex Index of row to find free space.
             * @param {int} cellIndex Index of cell to find free space in table.
             */

            function recoverCellIndex(rowIndex, cellIndex) {
              if (!_virtualTable[rowIndex]) {
                return cellIndex;
              }

              if (!_virtualTable[rowIndex][cellIndex]) {
                return cellIndex;
              }

              var newCellIndex = cellIndex;

              while (_virtualTable[rowIndex][newCellIndex]) {
                newCellIndex++;

                if (!_virtualTable[rowIndex][newCellIndex]) {
                  return newCellIndex;
                }
              }
            }
            /**
             * Recover info about row and cell and add information to virtual table.
             *
             * @param {object} row Row to recover information.
             * @param {object} cell Cell to recover information.
             */

            function addCellInfoToVirtual(row, cell) {
              var cellIndex = recoverCellIndex(row.rowIndex, cell.cellIndex);
              var cellHasColspan = cell.colSpan > 1;
              var cellHasRowspan = cell.rowSpan > 1;
              var isThisSelectedCell = row.rowIndex === _startPoint.rowPos && cell.cellIndex === _startPoint.colPos;
              setVirtualTablePosition(row.rowIndex, cellIndex, row, cell, cellHasRowspan, cellHasColspan, false); // Add span rows to virtual Table.

              var rowspanNumber = cell.attributes.rowSpan ? parseInt(cell.attributes.rowSpan.value, 10) : 0;

              if (rowspanNumber > 1) {
                for (var rp = 1; rp < rowspanNumber; rp++) {
                  var rowspanIndex = row.rowIndex + rp;
                  adjustStartPoint(rowspanIndex, cellIndex, cell, isThisSelectedCell);
                  setVirtualTablePosition(rowspanIndex, cellIndex, row, cell, true, cellHasColspan, true);
                }
              } // Add span cols to virtual table.


              var colspanNumber = cell.attributes.colSpan ? parseInt(cell.attributes.colSpan.value, 10) : 0;

              if (colspanNumber > 1) {
                for (var cp = 1; cp < colspanNumber; cp++) {
                  var cellspanIndex = recoverCellIndex(row.rowIndex, cellIndex + cp);
                  adjustStartPoint(row.rowIndex, cellspanIndex, cell, isThisSelectedCell);
                  setVirtualTablePosition(row.rowIndex, cellspanIndex, row, cell, cellHasRowspan, true, true);
                }
              }
            }
            /**
             * Process validation and adjust of start point if needed
             *
             * @param {int} rowIndex
             * @param {int} cellIndex
             * @param {object} cell
             * @param {bool} isSelectedCell
             */

            function adjustStartPoint(rowIndex, cellIndex, cell, isSelectedCell) {
              if (rowIndex === _startPoint.rowPos && _startPoint.colPos >= cell.cellIndex && cell.cellIndex <= cellIndex && !isSelectedCell) {
                _startPoint.colPos++;
              }
            }
            /**
             * Create virtual table of cells with all cells, including span cells.
             */

            function createVirtualTable() {
              var rows = domTable.rows;

              for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                var cells = rows[rowIndex].cells;

                for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                  addCellInfoToVirtual(rows[rowIndex], cells[cellIndex]);
                }
              }
            }
            /**
             * Get action to be applied on the cell.
             *
             * @param {object} cell virtual table cell to apply action
             */

            function getDeleteResultActionToCell(cell) {
              switch (where) {
                case TableResultAction.where.Column:
                  if (cell.isColSpan) {
                    return TableResultAction.resultAction.SubtractSpanCount;
                  }

                  break;

                case TableResultAction.where.Row:
                  if (!cell.isVirtual && cell.isRowSpan) {
                    return TableResultAction.resultAction.AddCell;
                  } else if (cell.isRowSpan) {
                    return TableResultAction.resultAction.SubtractSpanCount;
                  }

                  break;
              }

              return TableResultAction.resultAction.RemoveCell;
            }
            /**
             * Get action to be applied on the cell.
             *
             * @param {object} cell virtual table cell to apply action
             */

            function getAddResultActionToCell(cell) {
              switch (where) {
                case TableResultAction.where.Column:
                  if (cell.isColSpan) {
                    return TableResultAction.resultAction.SumSpanCount;
                  } else if (cell.isRowSpan && cell.isVirtual) {
                    return TableResultAction.resultAction.Ignore;
                  }

                  break;

                case TableResultAction.where.Row:
                  if (cell.isRowSpan) {
                    return TableResultAction.resultAction.SumSpanCount;
                  } else if (cell.isColSpan && cell.isVirtual) {
                    return TableResultAction.resultAction.Ignore;
                  }

                  break;
              }

              return TableResultAction.resultAction.AddCell;
            }

            function init() {
              setStartPoint();
              createVirtualTable();
            } /// ///////////////////////////////////////////
            // Public functions
            /// ///////////////////////////////////////////

            /**
             * Recover array os what to do in table.
             */

            this.getActionList = function () {
              var fixedRow = where === TableResultAction.where.Row ? _startPoint.rowPos : -1;
              var fixedCol = where === TableResultAction.where.Column ? _startPoint.colPos : -1;
              var actualPosition = 0;
              var canContinue = true;

              while (canContinue) {
                var rowPosition = fixedRow >= 0 ? fixedRow : actualPosition;
                var colPosition = fixedCol >= 0 ? fixedCol : actualPosition;
                var row = _virtualTable[rowPosition];

                if (!row) {
                  canContinue = false;
                  return _actionCellList;
                }

                var cell = row[colPosition];

                if (!cell) {
                  canContinue = false;
                  return _actionCellList;
                } // Define action to be applied in this cell


                var resultAction = TableResultAction.resultAction.Ignore;

                switch (action) {
                  case TableResultAction.requestAction.Add:
                    resultAction = getAddResultActionToCell(cell);
                    break;

                  case TableResultAction.requestAction.Delete:
                    resultAction = getDeleteResultActionToCell(cell);
                    break;
                }

                _actionCellList.push(getActionCell(cell, resultAction, rowPosition, colPosition));

                actualPosition++;
              }

              return _actionCellList;
            };

            init();
          };
          /**
          *
          * Where action occours enum.
          */

          TableResultAction.where = {
            'Row': 0,
            'Column': 1
          };
          /**
          *
          * Requested action to apply enum.
          */

          TableResultAction.requestAction = {
            'Add': 0,
            'Delete': 1
          };
          /**
          *
          * Result action to be executed enum.
          */

          TableResultAction.resultAction = {
            'Ignore': 0,
            'SubtractSpanCount': 1,
            'RemoveCell': 2,
            'AddCell': 3,
            'SumSpanCount': 4
          };
          /**
           *
           * @class editing.Table
           *
           * Table
           *
           */

          var Table_Table =
          /*#__PURE__*/
          function () {
            function Table() {
              Table_classCallCheck(this, Table);
            }

            Table_createClass(Table, [{
              key: "tab",

              /**
               * handle tab key
               *
               * @param {WrappedRange} rng
               * @param {Boolean} isShift
               */
              value: function tab(rng, isShift) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var table = dom.ancestor(cell, dom.isTable);
                var cells = dom.listDescendant(table, dom.isCell);
                var nextCell = lists[isShift ? 'prev' : 'next'](cells, cell);

                if (nextCell) {
                  range.create(nextCell, 0).select();
                }
              }
              /**
               * Add a new row
               *
               * @param {WrappedRange} rng
               * @param {String} position (top/bottom)
               * @return {Node}
               */

            }, {
              key: "addRow",
              value: function addRow(rng, position) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var currentTr = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('tr');
                var trAttributes = this.recoverAttributes(currentTr);
                var html = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<tr' + trAttributes + '></tr>');
                var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Add, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentTr).closest('table')[0]);
                var actions = vTable.getActionList();

                for (var idCell = 0; idCell < actions.length; idCell++) {
                  var currentCell = actions[idCell];
                  var tdAttributes = this.recoverAttributes(currentCell.baseCell);

                  switch (currentCell.action) {
                    case TableResultAction.resultAction.AddCell:
                      html.append('<td' + tdAttributes + '>' + dom.blank + '</td>');
                      break;

                    case TableResultAction.resultAction.SumSpanCount:
                      {
                        if (position === 'top') {
                          var baseCellTr = currentCell.baseCell.parent;
                          var isTopFromRowSpan = (!baseCellTr ? 0 : currentCell.baseCell.closest('tr').rowIndex) <= currentTr[0].rowIndex;

                          if (isTopFromRowSpan) {
                            var newTd = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div></div>').append(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<td' + tdAttributes + '>' + dom.blank + '</td>').removeAttr('rowspan')).html();
                            html.append(newTd);
                            break;
                          }
                        }

                        var rowspanNumber = parseInt(currentCell.baseCell.rowSpan, 10);
                        rowspanNumber++;
                        currentCell.baseCell.setAttribute('rowSpan', rowspanNumber);
                      }
                      break;
                  }
                }

                if (position === 'top') {
                  currentTr.before(html);
                } else {
                  var cellHasRowspan = cell.rowSpan > 1;

                  if (cellHasRowspan) {
                    var lastTrIndex = currentTr[0].rowIndex + (cell.rowSpan - 2);
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentTr).parent().find('tr')[lastTrIndex]).after(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(html));
                    return;
                  }

                  currentTr.after(html);
                }
              }
              /**
               * Add a new col
               *
               * @param {WrappedRange} rng
               * @param {String} position (left/right)
               * @return {Node}
               */

            }, {
              key: "addCol",
              value: function addCol(rng, position) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var row = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('tr');
                var rowsGroup = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(row).siblings();
                rowsGroup.push(row);
                var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Add, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(row).closest('table')[0]);
                var actions = vTable.getActionList();

                for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                  var currentCell = actions[actionIndex];
                  var tdAttributes = this.recoverAttributes(currentCell.baseCell);

                  switch (currentCell.action) {
                    case TableResultAction.resultAction.AddCell:
                      if (position === 'right') {
                        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentCell.baseCell).after('<td' + tdAttributes + '>' + dom.blank + '</td>');
                      } else {
                        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
                      }

                      break;

                    case TableResultAction.resultAction.SumSpanCount:
                      if (position === 'right') {
                        var colspanNumber = parseInt(currentCell.baseCell.colSpan, 10);
                        colspanNumber++;
                        currentCell.baseCell.setAttribute('colSpan', colspanNumber);
                      } else {
                        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
                      }

                      break;
                  }
                }
              }
              /*
              * Copy attributes from element.
              *
              * @param {object} Element to recover attributes.
              * @return {string} Copied string elements.
              */

            }, {
              key: "recoverAttributes",
              value: function recoverAttributes(el) {
                var resultStr = '';

                if (!el) {
                  return resultStr;
                }

                var attrList = el.attributes || [];

                for (var i = 0; i < attrList.length; i++) {
                  if (attrList[i].name.toLowerCase() === 'id') {
                    continue;
                  }

                  if (attrList[i].specified) {
                    resultStr += ' ' + attrList[i].name + '=\'' + attrList[i].value + '\'';
                  }
                }

                return resultStr;
              }
              /**
               * Delete current row
               *
               * @param {WrappedRange} rng
               * @return {Node}
               */

            }, {
              key: "deleteRow",
              value: function deleteRow(rng) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var row = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('tr');
                var cellPos = row.children('td, th').index(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell));
                var rowPos = row[0].rowIndex;
                var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Delete, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(row).closest('table')[0]);
                var actions = vTable.getActionList();

                for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                  if (!actions[actionIndex]) {
                    continue;
                  }

                  var baseCell = actions[actionIndex].baseCell;
                  var virtualPosition = actions[actionIndex].virtualTable;
                  var hasRowspan = baseCell.rowSpan && baseCell.rowSpan > 1;
                  var rowspanNumber = hasRowspan ? parseInt(baseCell.rowSpan, 10) : 0;

                  switch (actions[actionIndex].action) {
                    case TableResultAction.resultAction.Ignore:
                      continue;

                    case TableResultAction.resultAction.AddCell:
                      {
                        var nextRow = row.next('tr')[0];

                        if (!nextRow) {
                          continue;
                        }

                        var cloneRow = row[0].cells[cellPos];

                        if (hasRowspan) {
                          if (rowspanNumber > 2) {
                            rowspanNumber--;
                            nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                            nextRow.cells[cellPos].setAttribute('rowSpan', rowspanNumber);
                            nextRow.cells[cellPos].innerHTML = '';
                          } else if (rowspanNumber === 2) {
                            nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                            nextRow.cells[cellPos].removeAttribute('rowSpan');
                            nextRow.cells[cellPos].innerHTML = '';
                          }
                        }
                      }
                      continue;

                    case TableResultAction.resultAction.SubtractSpanCount:
                      if (hasRowspan) {
                        if (rowspanNumber > 2) {
                          rowspanNumber--;
                          baseCell.setAttribute('rowSpan', rowspanNumber);

                          if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                            baseCell.innerHTML = '';
                          }
                        } else if (rowspanNumber === 2) {
                          baseCell.removeAttribute('rowSpan');

                          if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                            baseCell.innerHTML = '';
                          }
                        }
                      }

                      continue;

                    case TableResultAction.resultAction.RemoveCell:
                      // Do not need remove cell because row will be deleted.
                      continue;
                  }
                }

                row.remove();
              }
              /**
               * Delete current col
               *
               * @param {WrappedRange} rng
               * @return {Node}
               */

            }, {
              key: "deleteCol",
              value: function deleteCol(rng) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var row = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('tr');
                var cellPos = row.children('td, th').index(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell));
                var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Delete, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(row).closest('table')[0]);
                var actions = vTable.getActionList();

                for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                  if (!actions[actionIndex]) {
                    continue;
                  }

                  switch (actions[actionIndex].action) {
                    case TableResultAction.resultAction.Ignore:
                      continue;

                    case TableResultAction.resultAction.SubtractSpanCount:
                      {
                        var baseCell = actions[actionIndex].baseCell;
                        var hasColspan = baseCell.colSpan && baseCell.colSpan > 1;

                        if (hasColspan) {
                          var colspanNumber = baseCell.colSpan ? parseInt(baseCell.colSpan, 10) : 0;

                          if (colspanNumber > 2) {
                            colspanNumber--;
                            baseCell.setAttribute('colSpan', colspanNumber);

                            if (baseCell.cellIndex === cellPos) {
                              baseCell.innerHTML = '';
                            }
                          } else if (colspanNumber === 2) {
                            baseCell.removeAttribute('colSpan');

                            if (baseCell.cellIndex === cellPos) {
                              baseCell.innerHTML = '';
                            }
                          }
                        }
                      }
                      continue;

                    case TableResultAction.resultAction.RemoveCell:
                      dom.remove(actions[actionIndex].baseCell, true);
                      continue;
                  }
                }
              }
              /**
               * create empty table element
               *
               * @param {Number} rowCount
               * @param {Number} colCount
               * @return {Node}
               */

            }, {
              key: "createTable",
              value: function createTable(colCount, rowCount, options) {
                var tds = [];
                var tdHTML;

                for (var idxCol = 0; idxCol < colCount; idxCol++) {
                  tds.push('<td>' + dom.blank + '</td>');
                }

                tdHTML = tds.join('');
                var trs = [];
                var trHTML;

                for (var idxRow = 0; idxRow < rowCount; idxRow++) {
                  trs.push('<tr>' + tdHTML + '</tr>');
                }

                trHTML = trs.join('');
                var $table = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<table>' + trHTML + '</table>');

                if (options && options.tableClassName) {
                  $table.addClass(options.tableClassName);
                }

                return $table[0];
              }
              /**
               * Delete current table
               *
               * @param {WrappedRange} rng
               * @return {Node}
               */

            }, {
              key: "deleteTable",
              value: function deleteTable(rng) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('table').remove();
              }
            }]);

            return Table;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Editor.js
          function Editor_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Editor_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Editor_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Editor_defineProperties(Constructor.prototype, protoProps);if (staticProps) Editor_defineProperties(Constructor, staticProps);return Constructor;
          }

          var KEY_BOGUS = 'bogus';
          /**
           * @class Editor
           */

          var Editor_Editor =
          /*#__PURE__*/
          function () {
            function Editor(context) {
              var _this = this;

              Editor_classCallCheck(this, Editor);

              this.context = context;
              this.$note = context.layoutInfo.note;
              this.$editor = context.layoutInfo.editor;
              this.$editable = context.layoutInfo.editable;
              this.options = context.options;
              this.lang = this.options.langInfo;
              this.editable = this.$editable[0];
              this.lastRange = null;
              this.snapshot = null;
              this.style = new Style_Style();
              this.table = new Table_Table();
              this.typing = new Typing_Typing(context);
              this.bullet = new Bullet_Bullet();
              this.history = new History_History(context);
              this.context.memo('help.undo', this.lang.help.undo);
              this.context.memo('help.redo', this.lang.help.redo);
              this.context.memo('help.tab', this.lang.help.tab);
              this.context.memo('help.untab', this.lang.help.untab);
              this.context.memo('help.insertParagraph', this.lang.help.insertParagraph);
              this.context.memo('help.insertOrderedList', this.lang.help.insertOrderedList);
              this.context.memo('help.insertUnorderedList', this.lang.help.insertUnorderedList);
              this.context.memo('help.indent', this.lang.help.indent);
              this.context.memo('help.outdent', this.lang.help.outdent);
              this.context.memo('help.formatPara', this.lang.help.formatPara);
              this.context.memo('help.insertHorizontalRule', this.lang.help.insertHorizontalRule);
              this.context.memo('help.fontName', this.lang.help.fontName); // native commands(with execCommand), generate function for execCommand

              var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull', 'formatBlock', 'removeFormat', 'backColor'];

              for (var idx = 0, len = commands.length; idx < len; idx++) {
                this[commands[idx]] = function (sCmd) {
                  return function (value) {
                    _this.beforeCommand();

                    document.execCommand(sCmd, false, value);

                    _this.afterCommand(true);
                  };
                }(commands[idx]);

                this.context.memo('help.' + commands[idx], this.lang.help[commands[idx]]);
              }

              this.fontName = this.wrapCommand(function (value) {
                return _this.fontStyling('font-family', env.validFontName(value));
              });
              this.fontSize = this.wrapCommand(function (value) {
                var unit = _this.currentStyle()['font-size-unit'];

                return _this.fontStyling('font-size', value + unit);
              });
              this.fontSizeUnit = this.wrapCommand(function (value) {
                var size = _this.currentStyle()['font-size'];

                return _this.fontStyling('font-size', size + value);
              });

              for (var _idx = 1; _idx <= 6; _idx++) {
                this['formatH' + _idx] = function (idx) {
                  return function () {
                    _this.formatBlock('H' + idx);
                  };
                }(_idx);

                this.context.memo('help.formatH' + _idx, this.lang.help['formatH' + _idx]);
              }

              this.insertParagraph = this.wrapCommand(function () {
                _this.typing.insertParagraph(_this.editable);
              });
              this.insertOrderedList = this.wrapCommand(function () {
                _this.bullet.insertOrderedList(_this.editable);
              });
              this.insertUnorderedList = this.wrapCommand(function () {
                _this.bullet.insertUnorderedList(_this.editable);
              });
              this.indent = this.wrapCommand(function () {
                _this.bullet.indent(_this.editable);
              });
              this.outdent = this.wrapCommand(function () {
                _this.bullet.outdent(_this.editable);
              });
              /**
               * insertNode
               * insert node
               * @param {Node} node
               */

              this.insertNode = this.wrapCommand(function (node) {
                if (_this.isLimited(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).text().length)) {
                  return;
                }

                var rng = _this.getLastRange();

                rng.insertNode(node);

                _this.setLastRange(range.createFromNodeAfter(node).select());
              });
              /**
               * insert text
               * @param {String} text
               */

              this.insertText = this.wrapCommand(function (text) {
                if (_this.isLimited(text.length)) {
                  return;
                }

                var rng = _this.getLastRange();

                var textNode = rng.insertNode(dom.createText(text));

                _this.setLastRange(range.create(textNode, dom.nodeLength(textNode)).select());
              });
              /**
               * paste HTML
               * @param {String} markup
               */

              this.pasteHTML = this.wrapCommand(function (markup) {
                if (_this.isLimited(markup.length)) {
                  return;
                }

                markup = _this.context.invoke('codeview.purify', markup);

                var contents = _this.getLastRange().pasteHTML(markup);

                _this.setLastRange(range.createFromNodeAfter(lists.last(contents)).select());
              });
              /**
               * formatBlock
               *
               * @param {String} tagName
               */

              this.formatBlock = this.wrapCommand(function (tagName, $target) {
                var onApplyCustomStyle = _this.options.callbacks.onApplyCustomStyle;

                if (onApplyCustomStyle) {
                  onApplyCustomStyle.call(_this, $target, _this.context, _this.onFormatBlock);
                } else {
                  _this.onFormatBlock(tagName, $target);
                }
              });
              /**
               * insert horizontal rule
               */

              this.insertHorizontalRule = this.wrapCommand(function () {
                var hrNode = _this.getLastRange().insertNode(dom.create('HR'));

                if (hrNode.nextSibling) {
                  _this.setLastRange(range.create(hrNode.nextSibling, 0).normalize().select());
                }
              });
              /**
               * lineHeight
               * @param {String} value
               */

              this.lineHeight = this.wrapCommand(function (value) {
                _this.style.stylePara(_this.getLastRange(), {
                  lineHeight: value
                });
              });
              /**
               * create link (command)
               *
               * @param {Object} linkInfo
               */

              this.createLink = this.wrapCommand(function (linkInfo) {
                var linkUrl = linkInfo.url;
                var linkText = linkInfo.text;
                var isNewWindow = linkInfo.isNewWindow;
                var checkProtocol = linkInfo.checkProtocol;

                var rng = linkInfo.range || _this.getLastRange();

                var additionalTextLength = linkText.length - rng.toString().length;

                if (additionalTextLength > 0 && _this.isLimited(additionalTextLength)) {
                  return;
                }

                var isTextChanged = rng.toString() !== linkText; // handle spaced urls from input

                if (typeof linkUrl === 'string') {
                  linkUrl = linkUrl.trim();
                }

                if (_this.options.onCreateLink) {
                  linkUrl = _this.options.onCreateLink(linkUrl);
                } else if (checkProtocol) {
                  // if url doesn't have any protocol and not even a relative or a label, use http:// as default
                  linkUrl = /^([A-Za-z][A-Za-z0-9+-.]*\:|#|\/)/.test(linkUrl) ? linkUrl : _this.options.defaultProtocol + linkUrl;
                }

                var anchors = [];

                if (isTextChanged) {
                  rng = rng.deleteContents();
                  var anchor = rng.insertNode(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<A>' + linkText + '</A>')[0]);
                  anchors.push(anchor);
                } else {
                  anchors = _this.style.styleNodes(rng, {
                    nodeName: 'A',
                    expandClosestSibling: true,
                    onlyPartialContains: true
                  });
                }

                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(anchors, function (idx, anchor) {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(anchor).attr('href', linkUrl);

                  if (isNewWindow) {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(anchor).attr('target', '_blank');
                  } else {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(anchor).removeAttr('target');
                  }
                });
                var startRange = range.createFromNodeBefore(lists.head(anchors));
                var startPoint = startRange.getStartPoint();
                var endRange = range.createFromNodeAfter(lists.last(anchors));
                var endPoint = endRange.getEndPoint();

                _this.setLastRange(range.create(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset).select());
              });
              /**
               * setting color
               *
               * @param {Object} sObjColor  color code
               * @param {String} sObjColor.foreColor foreground color
               * @param {String} sObjColor.backColor background color
               */

              this.color = this.wrapCommand(function (colorInfo) {
                var foreColor = colorInfo.foreColor;
                var backColor = colorInfo.backColor;

                if (foreColor) {
                  document.execCommand('foreColor', false, foreColor);
                }

                if (backColor) {
                  document.execCommand('backColor', false, backColor);
                }
              });
              /**
               * Set foreground color
               *
               * @param {String} colorCode foreground color code
               */

              this.foreColor = this.wrapCommand(function (colorInfo) {
                document.execCommand('foreColor', false, colorInfo);
              });
              /**
               * insert Table
               *
               * @param {String} dimension of table (ex : "5x5")
               */

              this.insertTable = this.wrapCommand(function (dim) {
                var dimension = dim.split('x');

                var rng = _this.getLastRange().deleteContents();

                rng.insertNode(_this.table.createTable(dimension[0], dimension[1], _this.options));
              });
              /**
               * remove media object and Figure Elements if media object is img with Figure.
               */

              this.removeMedia = this.wrapCommand(function () {
                var $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(_this.restoreTarget()).parent();

                if ($target.closest('figure').length) {
                  $target.closest('figure').remove();
                } else {
                  $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(_this.restoreTarget()).detach();
                }

                _this.context.triggerEvent('media.delete', $target, _this.$editable);
              });
              /**
               * float me
               *
               * @param {String} value
               */

              this.floatMe = this.wrapCommand(function (value) {
                var $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(_this.restoreTarget());
                $target.toggleClass('note-float-left', value === 'left');
                $target.toggleClass('note-float-right', value === 'right');
                $target.css('float', value === 'none' ? '' : value);
              });
              /**
               * resize overlay element
               * @param {String} value
               */

              this.resize = this.wrapCommand(function (value) {
                var $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(_this.restoreTarget());
                value = parseFloat(value);

                if (value === 0) {
                  $target.css('width', '');
                } else {
                  $target.css({
                    width: value * 100 + '%',
                    height: ''
                  });
                }
              });
            }

            Editor_createClass(Editor, [{
              key: "initialize",
              value: function initialize() {
                var _this2 = this;

                // bind custom events
                this.$editable.on('keydown', function (event) {
                  if (event.keyCode === core_key.code.ENTER) {
                    _this2.context.triggerEvent('enter', event);
                  }

                  _this2.context.triggerEvent('keydown', event); // keep a snapshot to limit text on input event


                  _this2.snapshot = _this2.history.makeSnapshot();
                  _this2.hasKeyShortCut = false;

                  if (!event.isDefaultPrevented()) {
                    if (_this2.options.shortcuts) {
                      _this2.hasKeyShortCut = _this2.handleKeyMap(event);
                    } else {
                      _this2.preventDefaultEditableShortCuts(event);
                    }
                  }

                  if (_this2.isLimited(1, event)) {
                    var lastRange = _this2.getLastRange();

                    if (lastRange.eo - lastRange.so === 0) {
                      return false;
                    }
                  }

                  _this2.setLastRange(); // record undo in the key event except keyMap.


                  if (_this2.options.recordEveryKeystroke) {
                    if (_this2.hasKeyShortCut === false) {
                      _this2.history.recordUndo();
                    }
                  }
                }).on('keyup', function (event) {
                  _this2.setLastRange();

                  _this2.context.triggerEvent('keyup', event);
                }).on('focus', function (event) {
                  _this2.setLastRange();

                  _this2.context.triggerEvent('focus', event);
                }).on('blur', function (event) {
                  _this2.context.triggerEvent('blur', event);
                }).on('mousedown', function (event) {
                  _this2.context.triggerEvent('mousedown', event);
                }).on('mouseup', function (event) {
                  _this2.setLastRange();

                  _this2.history.recordUndo();

                  _this2.context.triggerEvent('mouseup', event);
                }).on('scroll', function (event) {
                  _this2.context.triggerEvent('scroll', event);
                }).on('paste', function (event) {
                  _this2.setLastRange();

                  _this2.context.triggerEvent('paste', event);
                }).on('input', function () {
                  // To limit composition characters (e.g. Korean)
                  if (_this2.isLimited(0) && _this2.snapshot) {
                    _this2.history.applySnapshot(_this2.snapshot);
                  }
                });
                this.$editable.attr('spellcheck', this.options.spellCheck);
                this.$editable.attr('autocorrect', this.options.spellCheck);

                if (this.options.disableGrammar) {
                  this.$editable.attr('data-gramm', false);
                } // init content before set event


                this.$editable.html(dom.html(this.$note) || dom.emptyPara);
                this.$editable.on(env.inputEventName, func.debounce(function () {
                  _this2.context.triggerEvent('change', _this2.$editable.html(), _this2.$editable);
                }, 10));
                this.$editable.on('focusin', function (event) {
                  _this2.context.triggerEvent('focusin', event);
                }).on('focusout', function (event) {
                  _this2.context.triggerEvent('focusout', event);
                });

                if (this.options.airMode) {
                  if (this.options.overrideContextMenu) {
                    this.$editor.on('contextmenu', function (event) {
                      _this2.context.triggerEvent('contextmenu', event);

                      return false;
                    });
                  }
                } else {
                  if (this.options.width) {
                    this.$editor.outerWidth(this.options.width);
                  }

                  if (this.options.height) {
                    this.$editable.outerHeight(this.options.height);
                  }

                  if (this.options.maxHeight) {
                    this.$editable.css('max-height', this.options.maxHeight);
                  }

                  if (this.options.minHeight) {
                    this.$editable.css('min-height', this.options.minHeight);
                  }
                }

                this.history.recordUndo();
                this.setLastRange();
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$editable.off();
              }
            }, {
              key: "handleKeyMap",
              value: function handleKeyMap(event) {
                var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
                var keys = [];

                if (event.metaKey) {
                  keys.push('CMD');
                }

                if (event.ctrlKey && !event.altKey) {
                  keys.push('CTRL');
                }

                if (event.shiftKey) {
                  keys.push('SHIFT');
                }

                var keyName = core_key.nameFromCode[event.keyCode];

                if (keyName) {
                  keys.push(keyName);
                }

                var eventName = keyMap[keys.join('+')];

                if (keyName === 'TAB' && !this.options.tabDisable) {
                  this.afterCommand();
                } else if (eventName) {
                  if (this.context.invoke(eventName) !== false) {
                    event.preventDefault(); // if keyMap action was invoked

                    return true;
                  }
                } else if (core_key.isEdit(event.keyCode)) {
                  this.afterCommand();
                }

                return false;
              }
            }, {
              key: "preventDefaultEditableShortCuts",
              value: function preventDefaultEditableShortCuts(event) {
                // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)
                if ((event.ctrlKey || event.metaKey) && lists.contains([66, 73, 85], event.keyCode)) {
                  event.preventDefault();
                }
              }
            }, {
              key: "isLimited",
              value: function isLimited(pad, event) {
                pad = pad || 0;

                if (typeof event !== 'undefined') {
                  if (core_key.isMove(event.keyCode) || core_key.isNavigation(event.keyCode) || event.ctrlKey || event.metaKey || lists.contains([core_key.code.BACKSPACE, core_key.code.DELETE], event.keyCode)) {
                    return false;
                  }
                }

                if (this.options.maxTextLength > 0) {
                  if (this.$editable.text().length + pad > this.options.maxTextLength) {
                    return true;
                  }
                }

                return false;
              }
              /**
               * create range
               * @return {WrappedRange}
               */

            }, {
              key: "createRange",
              value: function createRange() {
                this.focus();
                this.setLastRange();
                return this.getLastRange();
              }
            }, {
              key: "setLastRange",
              value: function setLastRange(rng) {
                if (rng) {
                  this.lastRange = rng;
                } else {
                  this.lastRange = range.create(this.editable);

                  if (external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.lastRange.sc).closest('.note-editable').length === 0) {
                    this.lastRange = range.createFromBodyElement(this.editable);
                  }
                }
              }
            }, {
              key: "getLastRange",
              value: function getLastRange() {
                if (!this.lastRange) {
                  this.setLastRange();
                }

                return this.lastRange;
              }
              /**
               * saveRange
               *
               * save current range
               *
               * @param {Boolean} [thenCollapse=false]
               */

            }, {
              key: "saveRange",
              value: function saveRange(thenCollapse) {
                if (thenCollapse) {
                  this.getLastRange().collapse().select();
                }
              }
              /**
               * restoreRange
               *
               * restore lately range
               */

            }, {
              key: "restoreRange",
              value: function restoreRange() {
                if (this.lastRange) {
                  this.lastRange.select();
                  this.focus();
                }
              }
            }, {
              key: "saveTarget",
              value: function saveTarget(node) {
                this.$editable.data('target', node);
              }
            }, {
              key: "clearTarget",
              value: function clearTarget() {
                this.$editable.removeData('target');
              }
            }, {
              key: "restoreTarget",
              value: function restoreTarget() {
                return this.$editable.data('target');
              }
              /**
               * currentStyle
               *
               * current style
               * @return {Object|Boolean} unfocus
               */

            }, {
              key: "currentStyle",
              value: function currentStyle() {
                var rng = range.create();

                if (rng) {
                  rng = rng.normalize();
                }

                return rng ? this.style.current(rng) : this.style.fromNode(this.$editable);
              }
              /**
               * style from node
               *
               * @param {jQuery} $node
               * @return {Object}
               */

            }, {
              key: "styleFromNode",
              value: function styleFromNode($node) {
                return this.style.fromNode($node);
              }
              /**
               * undo
               */

            }, {
              key: "undo",
              value: function undo() {
                this.context.triggerEvent('before.command', this.$editable.html());
                this.history.undo();
                this.context.triggerEvent('change', this.$editable.html(), this.$editable);
              }
              /*
              * commit
              */

            }, {
              key: "commit",
              value: function commit() {
                this.context.triggerEvent('before.command', this.$editable.html());
                this.history.commit();
                this.context.triggerEvent('change', this.$editable.html(), this.$editable);
              }
              /**
               * redo
               */

            }, {
              key: "redo",
              value: function redo() {
                this.context.triggerEvent('before.command', this.$editable.html());
                this.history.redo();
                this.context.triggerEvent('change', this.$editable.html(), this.$editable);
              }
              /**
               * before command
               */

            }, {
              key: "beforeCommand",
              value: function beforeCommand() {
                this.context.triggerEvent('before.command', this.$editable.html()); // Set styleWithCSS before run a command

                document.execCommand('styleWithCSS', false, this.options.styleWithCSS); // keep focus on editable before command execution

                this.focus();
              }
              /**
               * after command
               * @param {Boolean} isPreventTrigger
               */

            }, {
              key: "afterCommand",
              value: function afterCommand(isPreventTrigger) {
                this.normalizeContent();
                this.history.recordUndo();

                if (!isPreventTrigger) {
                  this.context.triggerEvent('change', this.$editable.html(), this.$editable);
                }
              }
              /**
               * handle tab key
               */

            }, {
              key: "tab",
              value: function tab() {
                var rng = this.getLastRange();

                if (rng.isCollapsed() && rng.isOnCell()) {
                  this.table.tab(rng);
                } else {
                  if (this.options.tabSize === 0) {
                    return false;
                  }

                  if (!this.isLimited(this.options.tabSize)) {
                    this.beforeCommand();
                    this.typing.insertTab(rng, this.options.tabSize);
                    this.afterCommand();
                  }
                }
              }
              /**
               * handle shift+tab key
               */

            }, {
              key: "untab",
              value: function untab() {
                var rng = this.getLastRange();

                if (rng.isCollapsed() && rng.isOnCell()) {
                  this.table.tab(rng, true);
                } else {
                  if (this.options.tabSize === 0) {
                    return false;
                  }
                }
              }
              /**
               * run given function between beforeCommand and afterCommand
               */

            }, {
              key: "wrapCommand",
              value: function wrapCommand(fn) {
                return function () {
                  this.beforeCommand();
                  fn.apply(this, arguments);
                  this.afterCommand();
                };
              }
              /**
               * insert image
               *
               * @param {String} src
               * @param {String|Function} param
               * @return {Promise}
               */

            }, {
              key: "insertImage",
              value: function insertImage(src, param) {
                var _this3 = this;

                return createImage(src, param).then(function ($image) {
                  _this3.beforeCommand();

                  if (typeof param === 'function') {
                    param($image);
                  } else {
                    if (typeof param === 'string') {
                      $image.attr('data-filename', param);
                    }

                    $image.css('width', Math.min(_this3.$editable.width(), $image.width()));
                  }

                  $image.show();

                  _this3.getLastRange().insertNode($image[0]);

                  _this3.setLastRange(range.createFromNodeAfter($image[0]).select());

                  _this3.afterCommand();
                }).fail(function (e) {
                  _this3.context.triggerEvent('image.upload.error', e);
                });
              }
              /**
               * insertImages
               * @param {File[]} files
               */

            }, {
              key: "insertImagesAsDataURL",
              value: function insertImagesAsDataURL(files) {
                var _this4 = this;

                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(files, function (idx, file) {
                  var filename = file.name;

                  if (_this4.options.maximumImageFileSize && _this4.options.maximumImageFileSize < file.size) {
                    _this4.context.triggerEvent('image.upload.error', _this4.lang.image.maximumFileSizeError);
                  } else {
                    readFileAsDataURL(file).then(function (dataURL) {
                      return _this4.insertImage(dataURL, filename);
                    }).fail(function () {
                      _this4.context.triggerEvent('image.upload.error');
                    });
                  }
                });
              }
              /**
               * insertImagesOrCallback
               * @param {File[]} files
               */

            }, {
              key: "insertImagesOrCallback",
              value: function insertImagesOrCallback(files) {
                var callbacks = this.options.callbacks; // If onImageUpload set,

                if (callbacks.onImageUpload) {
                  this.context.triggerEvent('image.upload', files); // else insert Image as dataURL
                } else {
                  this.insertImagesAsDataURL(files);
                }
              }
              /**
               * return selected plain text
               * @return {String} text
               */

            }, {
              key: "getSelectedText",
              value: function getSelectedText() {
                var rng = this.getLastRange(); // if range on anchor, expand range with anchor

                if (rng.isOnAnchor()) {
                  rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));
                }

                return rng.toString();
              }
            }, {
              key: "onFormatBlock",
              value: function onFormatBlock(tagName, $target) {
                // [workaround] for MSIE, IE need `<`
                document.execCommand('FormatBlock', false, env.isMSIE ? '<' + tagName + '>' : tagName); // support custom class

                if ($target && $target.length) {
                  // find the exact element has given tagName
                  if ($target[0].tagName.toUpperCase() !== tagName.toUpperCase()) {
                    $target = $target.find(tagName);
                  }

                  if ($target && $target.length) {
                    var className = $target[0].className || '';

                    if (className) {
                      var currentRange = this.createRange();
                      var $parent = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()([currentRange.sc, currentRange.ec]).closest(tagName);
                      $parent.addClass(className);
                    }
                  }
                }
              }
            }, {
              key: "formatPara",
              value: function formatPara() {
                this.formatBlock('P');
              }
            }, {
              key: "fontStyling",
              value: function fontStyling(target, value) {
                var rng = this.getLastRange();

                if (rng !== '') {
                  var spans = this.style.styleNodes(rng);
                  this.$editor.find('.note-status-output').html('');
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(spans).css(target, value); // [workaround] added styled bogus span for style
                  //  - also bogus character needed for cursor position

                  if (rng.isCollapsed()) {
                    var firstSpan = lists.head(spans);

                    if (firstSpan && !dom.nodeLength(firstSpan)) {
                      firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
                      range.createFromNodeAfter(firstSpan.firstChild).select();
                      this.setLastRange();
                      this.$editable.data(KEY_BOGUS, firstSpan);
                    }
                  }
                } else {
                  var noteStatusOutput = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.now();
                  this.$editor.find('.note-status-output').html('<div id="note-status-output-' + noteStatusOutput + '" class="alert alert-info">' + this.lang.output.noSelection + '</div>');
                  setTimeout(function () {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('#note-status-output-' + noteStatusOutput).remove();
                  }, 5000);
                }
              }
              /**
               * unlink
               *
               * @type command
               */

            }, {
              key: "unlink",
              value: function unlink() {
                var rng = this.getLastRange();

                if (rng.isOnAnchor()) {
                  var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                  rng = range.createFromNode(anchor);
                  rng.select();
                  this.setLastRange();
                  this.beforeCommand();
                  document.execCommand('unlink');
                  this.afterCommand();
                }
              }
              /**
               * returns link info
               *
               * @return {Object}
               * @return {WrappedRange} return.range
               * @return {String} return.text
               * @return {Boolean} [return.isNewWindow=true]
               * @return {String} [return.url=""]
               */

            }, {
              key: "getLinkInfo",
              value: function getLinkInfo() {
                var rng = this.getLastRange().expand(dom.isAnchor); // Get the first anchor on range(for edit).

                var $anchor = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(lists.head(rng.nodes(dom.isAnchor)));
                var linkInfo = {
                  range: rng,
                  text: rng.toString(),
                  url: $anchor.length ? $anchor.attr('href') : ''
                }; // When anchor exists,

                if ($anchor.length) {
                  // Set isNewWindow by checking its target.
                  linkInfo.isNewWindow = $anchor.attr('target') === '_blank';
                }

                return linkInfo;
              }
            }, {
              key: "addRow",
              value: function addRow(position) {
                var rng = this.getLastRange(this.$editable);

                if (rng.isCollapsed() && rng.isOnCell()) {
                  this.beforeCommand();
                  this.table.addRow(rng, position);
                  this.afterCommand();
                }
              }
            }, {
              key: "addCol",
              value: function addCol(position) {
                var rng = this.getLastRange(this.$editable);

                if (rng.isCollapsed() && rng.isOnCell()) {
                  this.beforeCommand();
                  this.table.addCol(rng, position);
                  this.afterCommand();
                }
              }
            }, {
              key: "deleteRow",
              value: function deleteRow() {
                var rng = this.getLastRange(this.$editable);

                if (rng.isCollapsed() && rng.isOnCell()) {
                  this.beforeCommand();
                  this.table.deleteRow(rng);
                  this.afterCommand();
                }
              }
            }, {
              key: "deleteCol",
              value: function deleteCol() {
                var rng = this.getLastRange(this.$editable);

                if (rng.isCollapsed() && rng.isOnCell()) {
                  this.beforeCommand();
                  this.table.deleteCol(rng);
                  this.afterCommand();
                }
              }
            }, {
              key: "deleteTable",
              value: function deleteTable() {
                var rng = this.getLastRange(this.$editable);

                if (rng.isCollapsed() && rng.isOnCell()) {
                  this.beforeCommand();
                  this.table.deleteTable(rng);
                  this.afterCommand();
                }
              }
              /**
               * @param {Position} pos
               * @param {jQuery} $target - target element
               * @param {Boolean} [bKeepRatio] - keep ratio
               */

            }, {
              key: "resizeTo",
              value: function resizeTo(pos, $target, bKeepRatio) {
                var imageSize;

                if (bKeepRatio) {
                  var newRatio = pos.y / pos.x;
                  var ratio = $target.data('ratio');
                  imageSize = {
                    width: ratio > newRatio ? pos.x : pos.y / ratio,
                    height: ratio > newRatio ? pos.x * ratio : pos.y
                  };
                } else {
                  imageSize = {
                    width: pos.x,
                    height: pos.y
                  };
                }

                $target.css(imageSize);
              }
              /**
               * returns whether editable area has focus or not.
               */

            }, {
              key: "hasFocus",
              value: function hasFocus() {
                return this.$editable.is(':focus');
              }
              /**
               * set focus
               */

            }, {
              key: "focus",
              value: function focus() {
                // [workaround] Screen will move when page is scolled in IE.
                //  - do focus when not focused
                if (!this.hasFocus()) {
                  this.$editable.focus();
                }
              }
              /**
               * returns whether contents is empty or not.
               * @return {Boolean}
               */

            }, {
              key: "isEmpty",
              value: function isEmpty() {
                return dom.isEmpty(this.$editable[0]) || dom.emptyPara === this.$editable.html();
              }
              /**
               * Removes all contents and restores the editable instance to an _emptyPara_.
               */

            }, {
              key: "empty",
              value: function empty() {
                this.context.invoke('code', dom.emptyPara);
              }
              /**
               * normalize content
               */

            }, {
              key: "normalizeContent",
              value: function normalizeContent() {
                this.$editable[0].normalize();
              }
            }]);

            return Editor;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Clipboard.js
          function Clipboard_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Clipboard_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Clipboard_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Clipboard_defineProperties(Constructor.prototype, protoProps);if (staticProps) Clipboard_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Clipboard_Clipboard =
          /*#__PURE__*/
          function () {
            function Clipboard(context) {
              Clipboard_classCallCheck(this, Clipboard);

              this.context = context;
              this.$editable = context.layoutInfo.editable;
            }

            Clipboard_createClass(Clipboard, [{
              key: "initialize",
              value: function initialize() {
                this.$editable.on('paste', this.pasteByEvent.bind(this));
              }
              /**
               * paste by clipboard event
               *
               * @param {Event} event
               */

            }, {
              key: "pasteByEvent",
              value: function pasteByEvent(event) {
                var _this = this;

                var clipboardData = event.originalEvent.clipboardData;

                if (clipboardData && clipboardData.items && clipboardData.items.length) {
                  var item = clipboardData.items.length > 1 ? clipboardData.items[1] : lists.head(clipboardData.items);

                  if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {
                    // paste img file
                    this.context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);
                    event.preventDefault();
                  } else if (item.kind === 'string') {
                    // paste text with maxTextLength check
                    if (this.context.invoke('editor.isLimited', clipboardData.getData('Text').length)) {
                      event.preventDefault();
                    }
                  }
                } else if (window.clipboardData) {
                  // for IE
                  var text = window.clipboardData.getData('text');

                  if (this.context.invoke('editor.isLimited', text.length)) {
                    event.preventDefault();
                  }
                } // Call editor.afterCommand after proceeding default event handler


                setTimeout(function () {
                  _this.context.invoke('editor.afterCommand');
                }, 10);
              }
            }]);

            return Clipboard;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Dropzone.js
          function Dropzone_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Dropzone_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Dropzone_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Dropzone_defineProperties(Constructor.prototype, protoProps);if (staticProps) Dropzone_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Dropzone_Dropzone =
          /*#__PURE__*/
          function () {
            function Dropzone(context) {
              Dropzone_classCallCheck(this, Dropzone);

              this.context = context;
              this.$eventListener = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
              this.$editor = context.layoutInfo.editor;
              this.$editable = context.layoutInfo.editable;
              this.options = context.options;
              this.lang = this.options.langInfo;
              this.documentEventHandlers = {};
              this.$dropzone = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(['<div class="note-dropzone">', '<div class="note-dropzone-message"/>', '</div>'].join('')).prependTo(this.$editor);
            }
            /**
             * attach Drag and Drop Events
             */

            Dropzone_createClass(Dropzone, [{
              key: "initialize",
              value: function initialize() {
                if (this.options.disableDragAndDrop) {
                  // prevent default drop event
                  this.documentEventHandlers.onDrop = function (e) {
                    e.preventDefault();
                  }; // do not consider outside of dropzone


                  this.$eventListener = this.$dropzone;
                  this.$eventListener.on('drop', this.documentEventHandlers.onDrop);
                } else {
                  this.attachDragAndDropEvent();
                }
              }
              /**
               * attach Drag and Drop Events
               */

            }, {
              key: "attachDragAndDropEvent",
              value: function attachDragAndDropEvent() {
                var _this = this;

                var collection = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()();
                var $dropzoneMessage = this.$dropzone.find('.note-dropzone-message');

                this.documentEventHandlers.onDragenter = function (e) {
                  var isCodeview = _this.context.invoke('codeview.isActivated');

                  var hasEditorSize = _this.$editor.width() > 0 && _this.$editor.height() > 0;

                  if (!isCodeview && !collection.length && hasEditorSize) {
                    _this.$editor.addClass('dragover');

                    _this.$dropzone.width(_this.$editor.width());

                    _this.$dropzone.height(_this.$editor.height());

                    $dropzoneMessage.text(_this.lang.image.dragImageHere);
                  }

                  collection = collection.add(e.target);
                };

                this.documentEventHandlers.onDragleave = function (e) {
                  collection = collection.not(e.target); // If nodeName is BODY, then just make it over (fix for IE)

                  if (!collection.length || e.target.nodeName === 'BODY') {
                    collection = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()();

                    _this.$editor.removeClass('dragover');
                  }
                };

                this.documentEventHandlers.onDrop = function () {
                  collection = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()();

                  _this.$editor.removeClass('dragover');
                }; // show dropzone on dragenter when dragging a object to document
                // -but only if the editor is visible, i.e. has a positive width and height


                this.$eventListener.on('dragenter', this.documentEventHandlers.onDragenter).on('dragleave', this.documentEventHandlers.onDragleave).on('drop', this.documentEventHandlers.onDrop); // change dropzone's message on hover.

                this.$dropzone.on('dragenter', function () {
                  _this.$dropzone.addClass('hover');

                  $dropzoneMessage.text(_this.lang.image.dropImage);
                }).on('dragleave', function () {
                  _this.$dropzone.removeClass('hover');

                  $dropzoneMessage.text(_this.lang.image.dragImageHere);
                }); // attach dropImage

                this.$dropzone.on('drop', function (event) {
                  var dataTransfer = event.originalEvent.dataTransfer; // stop the browser from opening the dropped content

                  event.preventDefault();

                  if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                    _this.$editable.focus();

                    _this.context.invoke('editor.insertImagesOrCallback', dataTransfer.files);
                  } else {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(dataTransfer.types, function (idx, type) {
                      // skip moz-specific types
                      if (type.toLowerCase().indexOf('_moz_') > -1) {
                        return;
                      }

                      var content = dataTransfer.getData(type);

                      if (type.toLowerCase().indexOf('text') > -1) {
                        _this.context.invoke('editor.pasteHTML', content);
                      } else {
                        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(content).each(function (idx, item) {
                          _this.context.invoke('editor.insertNode', item);
                        });
                      }
                    });
                  }
                }).on('dragover', false); // prevent default dragover event
              }
            }, {
              key: "destroy",
              value: function destroy() {
                var _this2 = this;

                Object.keys(this.documentEventHandlers).forEach(function (key) {
                  _this2.$eventListener.off(key.substr(2).toLowerCase(), _this2.documentEventHandlers[key]);
                });
                this.documentEventHandlers = {};
              }
            }]);

            return Dropzone;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Codeview.js
          function Codeview_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Codeview_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Codeview_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Codeview_defineProperties(Constructor.prototype, protoProps);if (staticProps) Codeview_defineProperties(Constructor, staticProps);return Constructor;
          }

          var CodeMirror;

          if (env.hasCodeMirror) {
            CodeMirror = window.CodeMirror;
          }
          /**
           * @class Codeview
           */

          var Codeview_CodeView =
          /*#__PURE__*/
          function () {
            function CodeView(context) {
              Codeview_classCallCheck(this, CodeView);

              this.context = context;
              this.$editor = context.layoutInfo.editor;
              this.$editable = context.layoutInfo.editable;
              this.$codable = context.layoutInfo.codable;
              this.options = context.options;
            }

            Codeview_createClass(CodeView, [{
              key: "sync",
              value: function sync() {
                var isCodeview = this.isActivated();

                if (isCodeview && env.hasCodeMirror) {
                  this.$codable.data('cmEditor').save();
                }
              }
              /**
               * @return {Boolean}
               */

            }, {
              key: "isActivated",
              value: function isActivated() {
                return this.$editor.hasClass('codeview');
              }
              /**
               * toggle codeview
               */

            }, {
              key: "toggle",
              value: function toggle() {
                if (this.isActivated()) {
                  this.deactivate();
                } else {
                  this.activate();
                }

                this.context.triggerEvent('codeview.toggled');
              }
              /**
               * purify input value
               * @param value
               * @returns {*}
               */

            }, {
              key: "purify",
              value: function purify(value) {
                if (this.options.codeviewFilter) {
                  // filter code view regex
                  value = value.replace(this.options.codeviewFilterRegex, ''); // allow specific iframe tag

                  if (this.options.codeviewIframeFilter) {
                    var whitelist = this.options.codeviewIframeWhitelistSrc.concat(this.options.codeviewIframeWhitelistSrcBase);
                    value = value.replace(/(<iframe.*?>.*?(?:<\/iframe>)?)/gi, function (tag) {
                      // remove if src attribute is duplicated
                      if (/<.+src(?==?('|"|\s)?)[\s\S]+src(?=('|"|\s)?)[^>]*?>/i.test(tag)) {
                        return '';
                      }

                      var _iteratorNormalCompletion = true;
                      var _didIteratorError = false;
                      var _iteratorError = undefined;

                      try {
                        for (var _iterator = whitelist[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                          var src = _step.value;

                          // pass if src is trusted
                          if (new RegExp('src="(https?:)?\/\/' + src.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '\/(.+)"').test(tag)) {
                            return tag;
                          }
                        }
                      } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                            _iterator["return"]();
                          }
                        } finally {
                          if (_didIteratorError) {
                            throw _iteratorError;
                          }
                        }
                      }

                      return '';
                    });
                  }
                }

                return value;
              }
              /**
               * activate code view
               */

            }, {
              key: "activate",
              value: function activate() {
                var _this = this;

                this.$codable.val(dom.html(this.$editable, this.options.prettifyHtml));
                this.$codable.height(this.$editable.height());
                this.context.invoke('toolbar.updateCodeview', true);
                this.$editor.addClass('codeview');
                this.$codable.focus(); // activate CodeMirror as codable

                if (env.hasCodeMirror) {
                  var cmEditor = CodeMirror.fromTextArea(this.$codable[0], this.options.codemirror); // CodeMirror TernServer

                  if (this.options.codemirror.tern) {
                    var server = new CodeMirror.TernServer(this.options.codemirror.tern);
                    cmEditor.ternServer = server;
                    cmEditor.on('cursorActivity', function (cm) {
                      server.updateArgHints(cm);
                    });
                  }

                  cmEditor.on('blur', function (event) {
                    _this.context.triggerEvent('blur.codeview', cmEditor.getValue(), event);
                  });
                  cmEditor.on('change', function () {
                    _this.context.triggerEvent('change.codeview', cmEditor.getValue(), cmEditor);
                  }); // CodeMirror hasn't Padding.

                  cmEditor.setSize(null, this.$editable.outerHeight());
                  this.$codable.data('cmEditor', cmEditor);
                } else {
                  this.$codable.on('blur', function (event) {
                    _this.context.triggerEvent('blur.codeview', _this.$codable.val(), event);
                  });
                  this.$codable.on('input', function () {
                    _this.context.triggerEvent('change.codeview', _this.$codable.val(), _this.$codable);
                  });
                }
              }
              /**
               * deactivate code view
               */

            }, {
              key: "deactivate",
              value: function deactivate() {
                // deactivate CodeMirror as codable
                if (env.hasCodeMirror) {
                  var cmEditor = this.$codable.data('cmEditor');
                  this.$codable.val(cmEditor.getValue());
                  cmEditor.toTextArea();
                }

                var value = this.purify(dom.value(this.$codable, this.options.prettifyHtml) || dom.emptyPara);
                var isChange = this.$editable.html() !== value;
                this.$editable.html(value);
                this.$editable.height(this.options.height ? this.$codable.height() : 'auto');
                this.$editor.removeClass('codeview');

                if (isChange) {
                  this.context.triggerEvent('change', this.$editable.html(), this.$editable);
                }

                this.$editable.focus();
                this.context.invoke('toolbar.updateCodeview', false);
              }
            }, {
              key: "destroy",
              value: function destroy() {
                if (this.isActivated()) {
                  this.deactivate();
                }
              }
            }]);

            return CodeView;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Statusbar.js
          function Statusbar_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Statusbar_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Statusbar_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Statusbar_defineProperties(Constructor.prototype, protoProps);if (staticProps) Statusbar_defineProperties(Constructor, staticProps);return Constructor;
          }

          var EDITABLE_PADDING = 24;

          var Statusbar_Statusbar =
          /*#__PURE__*/
          function () {
            function Statusbar(context) {
              Statusbar_classCallCheck(this, Statusbar);

              this.$document = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
              this.$statusbar = context.layoutInfo.statusbar;
              this.$editable = context.layoutInfo.editable;
              this.options = context.options;
            }

            Statusbar_createClass(Statusbar, [{
              key: "initialize",
              value: function initialize() {
                var _this = this;

                if (this.options.airMode || this.options.disableResizeEditor) {
                  this.destroy();
                  return;
                }

                this.$statusbar.on('mousedown', function (event) {
                  event.preventDefault();
                  event.stopPropagation();

                  var editableTop = _this.$editable.offset().top - _this.$document.scrollTop();

                  var onMouseMove = function onMouseMove(event) {
                    var height = event.clientY - (editableTop + EDITABLE_PADDING);
                    height = _this.options.minheight > 0 ? Math.max(height, _this.options.minheight) : height;
                    height = _this.options.maxHeight > 0 ? Math.min(height, _this.options.maxHeight) : height;

                    _this.$editable.height(height);
                  };

                  _this.$document.on('mousemove', onMouseMove).one('mouseup', function () {
                    _this.$document.off('mousemove', onMouseMove);
                  });
                });
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$statusbar.off();
                this.$statusbar.addClass('locked');
              }
            }]);

            return Statusbar;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Fullscreen.js
          function Fullscreen_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Fullscreen_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Fullscreen_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Fullscreen_defineProperties(Constructor.prototype, protoProps);if (staticProps) Fullscreen_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Fullscreen_Fullscreen =
          /*#__PURE__*/
          function () {
            function Fullscreen(context) {
              var _this = this;

              Fullscreen_classCallCheck(this, Fullscreen);

              this.context = context;
              this.$editor = context.layoutInfo.editor;
              this.$toolbar = context.layoutInfo.toolbar;
              this.$editable = context.layoutInfo.editable;
              this.$codable = context.layoutInfo.codable;
              this.$window = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(window);
              this.$scrollbar = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('html, body');

              this.onResize = function () {
                _this.resizeTo({
                  h: _this.$window.height() - _this.$toolbar.outerHeight()
                });
              };
            }

            Fullscreen_createClass(Fullscreen, [{
              key: "resizeTo",
              value: function resizeTo(size) {
                this.$editable.css('height', size.h);
                this.$codable.css('height', size.h);

                if (this.$codable.data('cmeditor')) {
                  this.$codable.data('cmeditor').setsize(null, size.h);
                }
              }
              /**
               * toggle fullscreen
               */

            }, {
              key: "toggle",
              value: function toggle() {
                this.$editor.toggleClass('fullscreen');

                if (this.isFullscreen()) {
                  this.$editable.data('orgHeight', this.$editable.css('height'));
                  this.$editable.data('orgMaxHeight', this.$editable.css('maxHeight'));
                  this.$editable.css('maxHeight', '');
                  this.$window.on('resize', this.onResize).trigger('resize');
                  this.$scrollbar.css('overflow', 'hidden');
                } else {
                  this.$window.off('resize', this.onResize);
                  this.resizeTo({
                    h: this.$editable.data('orgHeight')
                  });
                  this.$editable.css('maxHeight', this.$editable.css('orgMaxHeight'));
                  this.$scrollbar.css('overflow', 'visible');
                }

                this.context.invoke('toolbar.updateFullscreen', this.isFullscreen());
              }
            }, {
              key: "isFullscreen",
              value: function isFullscreen() {
                return this.$editor.hasClass('fullscreen');
              }
            }]);

            return Fullscreen;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Handle.js
          function Handle_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Handle_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Handle_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Handle_defineProperties(Constructor.prototype, protoProps);if (staticProps) Handle_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Handle_Handle =
          /*#__PURE__*/
          function () {
            function Handle(context) {
              var _this = this;

              Handle_classCallCheck(this, Handle);

              this.context = context;
              this.$document = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
              this.$editingArea = context.layoutInfo.editingArea;
              this.options = context.options;
              this.lang = this.options.langInfo;
              this.events = {
                'summernote.mousedown': function summernoteMousedown(we, e) {
                  if (_this.update(e.target, e)) {
                    e.preventDefault();
                  }
                },
                'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function summernoteKeyupSummernoteScrollSummernoteChangeSummernoteDialogShown() {
                  _this.update();
                },
                'summernote.disable summernote.blur': function summernoteDisableSummernoteBlur() {
                  _this.hide();
                },
                'summernote.codeview.toggled': function summernoteCodeviewToggled() {
                  _this.update();
                }
              };
            }

            Handle_createClass(Handle, [{
              key: "initialize",
              value: function initialize() {
                var _this2 = this;

                this.$handle = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(['<div class="note-handle">', '<div class="note-control-selection">', '<div class="note-control-selection-bg"></div>', '<div class="note-control-holder note-control-nw"></div>', '<div class="note-control-holder note-control-ne"></div>', '<div class="note-control-holder note-control-sw"></div>', '<div class="', this.options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing', ' note-control-se"></div>', this.options.disableResizeImage ? '' : '<div class="note-control-selection-info"></div>', '</div>', '</div>'].join('')).prependTo(this.$editingArea);
                this.$handle.on('mousedown', function (event) {
                  if (dom.isControlSizing(event.target)) {
                    event.preventDefault();
                    event.stopPropagation();

                    var $target = _this2.$handle.find('.note-control-selection').data('target');

                    var posStart = $target.offset();

                    var scrollTop = _this2.$document.scrollTop();

                    var onMouseMove = function onMouseMove(event) {
                      _this2.context.invoke('editor.resizeTo', {
                        x: event.clientX - posStart.left,
                        y: event.clientY - (posStart.top - scrollTop)
                      }, $target, !event.shiftKey);

                      _this2.update($target[0], event);
                    };

                    _this2.$document.on('mousemove', onMouseMove).one('mouseup', function (e) {
                      e.preventDefault();

                      _this2.$document.off('mousemove', onMouseMove);

                      _this2.context.invoke('editor.afterCommand');
                    });

                    if (!$target.data('ratio')) {
                      // original ratio.
                      $target.data('ratio', $target.height() / $target.width());
                    }
                  }
                }); // Listen for scrolling on the handle overlay.

                this.$handle.on('wheel', function (e) {
                  e.preventDefault();

                  _this2.update();
                });
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$handle.remove();
              }
            }, {
              key: "update",
              value: function update(target, event) {
                if (this.context.isDisabled()) {
                  return false;
                }

                var isImage = dom.isImg(target);
                var $selection = this.$handle.find('.note-control-selection');
                this.context.invoke('imagePopover.update', target, event);

                if (isImage) {
                  var $image = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(target);
                  var position = $image.position();
                  var pos = {
                    left: position.left + parseInt($image.css('marginLeft'), 10),
                    top: position.top + parseInt($image.css('marginTop'), 10)
                  }; // exclude margin

                  var imageSize = {
                    w: $image.outerWidth(false),
                    h: $image.outerHeight(false)
                  };
                  $selection.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top,
                    width: imageSize.w,
                    height: imageSize.h
                  }).data('target', $image); // save current image element.

                  var origImageObj = new Image();
                  origImageObj.src = $image.attr('src');
                  var sizingText = imageSize.w + 'x' + imageSize.h + ' (' + this.lang.image.original + ': ' + origImageObj.width + 'x' + origImageObj.height + ')';
                  $selection.find('.note-control-selection-info').text(sizingText);
                  this.context.invoke('editor.saveTarget', target);
                } else {
                  this.hide();
                }

                return isImage;
              }
              /**
               * hide
               *
               * @param {jQuery} $handle
               */

            }, {
              key: "hide",
              value: function hide() {
                this.context.invoke('editor.clearTarget');
                this.$handle.children().hide();
              }
            }]);

            return Handle;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/AutoLink.js
          function AutoLink_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function AutoLink_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function AutoLink_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) AutoLink_defineProperties(Constructor.prototype, protoProps);if (staticProps) AutoLink_defineProperties(Constructor, staticProps);return Constructor;
          }

          var defaultScheme = 'http://';
          var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/]{2}|tel:|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;

          var AutoLink_AutoLink =
          /*#__PURE__*/
          function () {
            function AutoLink(context) {
              var _this = this;

              AutoLink_classCallCheck(this, AutoLink);

              this.context = context;
              this.events = {
                'summernote.keyup': function summernoteKeyup(we, e) {
                  if (!e.isDefaultPrevented()) {
                    _this.handleKeyup(e);
                  }
                },
                'summernote.keydown': function summernoteKeydown(we, e) {
                  _this.handleKeydown(e);
                }
              };
            }

            AutoLink_createClass(AutoLink, [{
              key: "initialize",
              value: function initialize() {
                this.lastWordRange = null;
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.lastWordRange = null;
              }
            }, {
              key: "replace",
              value: function replace() {
                if (!this.lastWordRange) {
                  return;
                }

                var keyword = this.lastWordRange.toString();
                var match = keyword.match(linkPattern);

                if (match && (match[1] || match[2])) {
                  var link = match[1] ? keyword : defaultScheme + keyword;
                  var urlText = keyword.replace(/^(?:https?:\/\/)?(?:tel?:?)?(?:mailto?:?)?(?:www\.)?/i, '').split('/')[0];
                  var node = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<a />').html(urlText).attr('href', link)[0];

                  if (this.context.options.linkTargetBlank) {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).attr('target', '_blank');
                  }

                  this.lastWordRange.insertNode(node);
                  this.lastWordRange = null;
                  this.context.invoke('editor.focus');
                }
              }
            }, {
              key: "handleKeydown",
              value: function handleKeydown(e) {
                if (lists.contains([core_key.code.ENTER, core_key.code.SPACE], e.keyCode)) {
                  var wordRange = this.context.invoke('editor.createRange').getWordRange();
                  this.lastWordRange = wordRange;
                }
              }
            }, {
              key: "handleKeyup",
              value: function handleKeyup(e) {
                if (lists.contains([core_key.code.ENTER, core_key.code.SPACE], e.keyCode)) {
                  this.replace();
                }
              }
            }]);

            return AutoLink;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/AutoSync.js
          function AutoSync_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function AutoSync_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function AutoSync_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) AutoSync_defineProperties(Constructor.prototype, protoProps);if (staticProps) AutoSync_defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * textarea auto sync.
           */

          var AutoSync_AutoSync =
          /*#__PURE__*/
          function () {
            function AutoSync(context) {
              var _this = this;

              AutoSync_classCallCheck(this, AutoSync);

              this.$note = context.layoutInfo.note;
              this.events = {
                'summernote.change': function summernoteChange() {
                  _this.$note.val(context.invoke('code'));
                }
              };
            }

            AutoSync_createClass(AutoSync, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return dom.isTextarea(this.$note[0]);
              }
            }]);

            return AutoSync;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/AutoReplace.js
          function AutoReplace_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function AutoReplace_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function AutoReplace_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) AutoReplace_defineProperties(Constructor.prototype, protoProps);if (staticProps) AutoReplace_defineProperties(Constructor, staticProps);return Constructor;
          }

          var AutoReplace_AutoReplace =
          /*#__PURE__*/
          function () {
            function AutoReplace(context) {
              var _this = this;

              AutoReplace_classCallCheck(this, AutoReplace);

              this.context = context;
              this.options = context.options.replace || {};
              this.keys = [core_key.code.ENTER, core_key.code.SPACE, core_key.code.PERIOD, core_key.code.COMMA, core_key.code.SEMICOLON, core_key.code.SLASH];
              this.previousKeydownCode = null;
              this.events = {
                'summernote.keyup': function summernoteKeyup(we, e) {
                  if (!e.isDefaultPrevented()) {
                    _this.handleKeyup(e);
                  }
                },
                'summernote.keydown': function summernoteKeydown(we, e) {
                  _this.handleKeydown(e);
                }
              };
            }

            AutoReplace_createClass(AutoReplace, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return !!this.options.match;
              }
            }, {
              key: "initialize",
              value: function initialize() {
                this.lastWord = null;
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.lastWord = null;
              }
            }, {
              key: "replace",
              value: function replace() {
                if (!this.lastWord) {
                  return;
                }

                var self = this;
                var keyword = this.lastWord.toString();
                this.options.match(keyword, function (match) {
                  if (match) {
                    var node = '';

                    if (typeof match === 'string') {
                      node = dom.createText(match);
                    } else if (match instanceof jQuery) {
                      node = match[0];
                    } else if (match instanceof Node) {
                      node = match;
                    }

                    if (!node) return;
                    self.lastWord.insertNode(node);
                    self.lastWord = null;
                    self.context.invoke('editor.focus');
                  }
                });
              }
            }, {
              key: "handleKeydown",
              value: function handleKeydown(e) {
                // this forces it to remember the last whole word, even if multiple termination keys are pressed
                // before the previous key is let go.
                if (this.previousKeydownCode && lists.contains(this.keys, this.previousKeydownCode)) {
                  this.previousKeydownCode = e.keyCode;
                  return;
                }

                if (lists.contains(this.keys, e.keyCode)) {
                  var wordRange = this.context.invoke('editor.createRange').getWordRange();
                  this.lastWord = wordRange;
                }

                this.previousKeydownCode = e.keyCode;
              }
            }, {
              key: "handleKeyup",
              value: function handleKeyup(e) {
                if (lists.contains(this.keys, e.keyCode)) {
                  this.replace();
                }
              }
            }]);

            return AutoReplace;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Placeholder.js
          function Placeholder_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Placeholder_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Placeholder_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Placeholder_defineProperties(Constructor.prototype, protoProps);if (staticProps) Placeholder_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Placeholder_Placeholder =
          /*#__PURE__*/
          function () {
            function Placeholder(context) {
              var _this = this;

              Placeholder_classCallCheck(this, Placeholder);

              this.context = context;
              this.$editingArea = context.layoutInfo.editingArea;
              this.options = context.options;

              if (this.options.inheritPlaceholder === true) {
                // get placeholder value from the original element
                this.options.placeholder = this.context.$note.attr('placeholder') || this.options.placeholder;
              }

              this.events = {
                'summernote.init summernote.change': function summernoteInitSummernoteChange() {
                  _this.update();
                },
                'summernote.codeview.toggled': function summernoteCodeviewToggled() {
                  _this.update();
                }
              };
            }

            Placeholder_createClass(Placeholder, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return !!this.options.placeholder;
              }
            }, {
              key: "initialize",
              value: function initialize() {
                var _this2 = this;

                this.$placeholder = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div class="note-placeholder">');
                this.$placeholder.on('click', function () {
                  _this2.context.invoke('focus');
                }).html(this.options.placeholder).prependTo(this.$editingArea);
                this.update();
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$placeholder.remove();
              }
            }, {
              key: "update",
              value: function update() {
                var isShow = !this.context.invoke('codeview.isActivated') && this.context.invoke('editor.isEmpty');
                this.$placeholder.toggle(isShow);
              }
            }]);

            return Placeholder;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Buttons.js
          function Buttons_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Buttons_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Buttons_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Buttons_defineProperties(Constructor.prototype, protoProps);if (staticProps) Buttons_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Buttons_Buttons =
          /*#__PURE__*/
          function () {
            function Buttons(context) {
              Buttons_classCallCheck(this, Buttons);

              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.context = context;
              this.$toolbar = context.layoutInfo.toolbar;
              this.options = context.options;
              this.lang = this.options.langInfo;
              this.invertedKeyMap = func.invertObject(this.options.keyMap[env.isMac ? 'mac' : 'pc']);
            }

            Buttons_createClass(Buttons, [{
              key: "representShortcut",
              value: function representShortcut(editorMethod) {
                var shortcut = this.invertedKeyMap[editorMethod];

                if (!this.options.shortcuts || !shortcut) {
                  return '';
                }

                if (env.isMac) {
                  shortcut = shortcut.replace('CMD', '').replace('SHIFT', '');
                }

                shortcut = shortcut.replace('BACKSLASH', '\\').replace('SLASH', '/').replace('LEFTBRACKET', '[').replace('RIGHTBRACKET', ']');
                return ' (' + shortcut + ')';
              }
            }, {
              key: "button",
              value: function button(o) {
                if (!this.options.tooltip && o.tooltip) {
                  delete o.tooltip;
                }

                o.container = this.options.container;
                return this.ui.button(o);
              }
            }, {
              key: "initialize",
              value: function initialize() {
                this.addToolbarButtons();
                this.addImagePopoverButtons();
                this.addLinkPopoverButtons();
                this.addTablePopoverButtons();
                this.fontInstalledMap = {};
              }
            }, {
              key: "destroy",
              value: function destroy() {
                delete this.fontInstalledMap;
              }
            }, {
              key: "isFontInstalled",
              value: function isFontInstalled(name) {
                if (!Object.prototype.hasOwnProperty.call(this.fontInstalledMap, name)) {
                  this.fontInstalledMap[name] = env.isFontInstalled(name) || lists.contains(this.options.fontNamesIgnoreCheck, name);
                }

                return this.fontInstalledMap[name];
              }
            }, {
              key: "isFontDeservedToAdd",
              value: function isFontDeservedToAdd(name) {
                name = name.toLowerCase();
                return name !== '' && this.isFontInstalled(name) && env.genericFontFamilies.indexOf(name) === -1;
              }
            }, {
              key: "colorPalette",
              value: function colorPalette(className, tooltip, backColor, foreColor) {
                var _this = this;

                return this.ui.buttonGroup({
                  className: 'note-color ' + className,
                  children: [this.button({
                    className: 'note-current-color-button',
                    contents: this.ui.icon(this.options.icons.font + ' note-recent-color'),
                    tooltip: tooltip,
                    click: function click(e) {
                      var $button = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(e.currentTarget);

                      if (backColor && foreColor) {
                        _this.context.invoke('editor.color', {
                          backColor: $button.attr('data-backColor'),
                          foreColor: $button.attr('data-foreColor')
                        });
                      } else if (backColor) {
                        _this.context.invoke('editor.color', {
                          backColor: $button.attr('data-backColor')
                        });
                      } else if (foreColor) {
                        _this.context.invoke('editor.color', {
                          foreColor: $button.attr('data-foreColor')
                        });
                      }
                    },
                    callback: function callback($button) {
                      var $recentColor = $button.find('.note-recent-color');

                      if (backColor) {
                        $recentColor.css('background-color', _this.options.colorButton.backColor);
                        $button.attr('data-backColor', _this.options.colorButton.backColor);
                      }

                      if (foreColor) {
                        $recentColor.css('color', _this.options.colorButton.foreColor);
                        $button.attr('data-foreColor', _this.options.colorButton.foreColor);
                      } else {
                        $recentColor.css('color', 'transparent');
                      }
                    }
                  }), this.button({
                    className: 'dropdown-toggle',
                    contents: this.ui.dropdownButtonContents('', this.options),
                    tooltip: this.lang.color.more,
                    data: {
                      toggle: 'dropdown'
                    }
                  }), this.ui.dropdown({
                    items: (backColor ? ['<div class="note-palette">', '<div class="note-palette-title">' + this.lang.color.background + '</div>', '<div>', '<button type="button" class="note-color-reset btn btn-light" data-event="backColor" data-value="inherit">', this.lang.color.transparent, '</button>', '</div>', '<div class="note-holder" data-event="backColor"/>', '<div>', '<button type="button" class="note-color-select btn btn-light" data-event="openPalette" data-value="backColorPicker">', this.lang.color.cpSelect, '</button>', '<input type="color" id="backColorPicker" class="note-btn note-color-select-btn" value="' + this.options.colorButton.backColor + '" data-event="backColorPalette">', '</div>', '<div class="note-holder-custom" id="backColorPalette" data-event="backColor"/>', '</div>'].join('') : '') + (foreColor ? ['<div class="note-palette">', '<div class="note-palette-title">' + this.lang.color.foreground + '</div>', '<div>', '<button type="button" class="note-color-reset btn btn-light" data-event="removeFormat" data-value="foreColor">', this.lang.color.resetToDefault, '</button>', '</div>', '<div class="note-holder" data-event="foreColor"/>', '<div>', '<button type="button" class="note-color-select btn btn-light" data-event="openPalette" data-value="foreColorPicker">', this.lang.color.cpSelect, '</button>', '<input type="color" id="foreColorPicker" class="note-btn note-color-select-btn" value="' + this.options.colorButton.foreColor + '" data-event="foreColorPalette">', '</div>', // Fix missing Div, Commented to find easily if it's wrong
                    '<div class="note-holder-custom" id="foreColorPalette" data-event="foreColor"/>', '</div>'].join('') : ''),
                    callback: function callback($dropdown) {
                      $dropdown.find('.note-holder').each(function (idx, item) {
                        var $holder = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item);
                        $holder.append(_this.ui.palette({
                          colors: _this.options.colors,
                          colorsName: _this.options.colorsName,
                          eventName: $holder.data('event'),
                          container: _this.options.container,
                          tooltip: _this.options.tooltip
                        }).render());
                      });
                      /* TODO: do we have to record recent custom colors within cookies? */

                      var customColors = [['#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF']];
                      $dropdown.find('.note-holder-custom').each(function (idx, item) {
                        var $holder = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item);
                        $holder.append(_this.ui.palette({
                          colors: customColors,
                          colorsName: customColors,
                          eventName: $holder.data('event'),
                          container: _this.options.container,
                          tooltip: _this.options.tooltip
                        }).render());
                      });
                      $dropdown.find('input[type=color]').each(function (idx, item) {
                        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item).change(function () {
                          var $chip = $dropdown.find('#' + external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this).data('event')).find('.note-color-btn').first();
                          var color = this.value.toUpperCase();
                          $chip.css('background-color', color).attr('aria-label', color).attr('data-value', color).attr('data-original-title', color);
                          $chip.click();
                        });
                      });
                    },
                    click: function click(event) {
                      event.stopPropagation();
                      var $parent = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('.' + className).find('.note-dropdown-menu');
                      var $button = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(event.target);
                      var eventName = $button.data('event');
                      var value = $button.attr('data-value');

                      if (eventName === 'openPalette') {
                        var $picker = $parent.find('#' + value);
                        var $palette = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()($parent.find('#' + $picker.data('event')).find('.note-color-row')[0]); // Shift palette chips

                        var $chip = $palette.find('.note-color-btn').last().detach(); // Set chip attributes

                        var color = $picker.val();
                        $chip.css('background-color', color).attr('aria-label', color).attr('data-value', color).attr('data-original-title', color);
                        $palette.prepend($chip);
                        $picker.click();
                      } else {
                        if (lists.contains(['backColor', 'foreColor'], eventName)) {
                          var key = eventName === 'backColor' ? 'background-color' : 'color';
                          var $color = $button.closest('.note-color').find('.note-recent-color');
                          var $currentButton = $button.closest('.note-color').find('.note-current-color-button');
                          $color.css(key, value);
                          $currentButton.attr('data-' + eventName, value);
                        }

                        _this.context.invoke('editor.' + eventName, value);
                      }
                    }
                  })]
                }).render();
              }
            }, {
              key: "addToolbarButtons",
              value: function addToolbarButtons() {
                var _this2 = this;

                this.context.memo('button.style', function () {
                  return _this2.ui.buttonGroup([_this2.button({
                    className: 'dropdown-toggle',
                    contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.magic), _this2.options),
                    tooltip: _this2.lang.style.style,
                    data: {
                      toggle: 'dropdown'
                    }
                  }), _this2.ui.dropdown({
                    className: 'dropdown-style',
                    items: _this2.options.styleTags,
                    title: _this2.lang.style.style,
                    template: function template(item) {
                      // TBD: need to be simplified
                      if (typeof item === 'string') {
                        item = {
                          tag: item,
                          title: Object.prototype.hasOwnProperty.call(_this2.lang.style, item) ? _this2.lang.style[item] : item
                        };
                      }

                      var tag = item.tag;
                      var title = item.title;
                      var style = item.style ? ' style="' + item.style + '" ' : '';
                      var className = item.className ? ' class="' + item.className + '"' : '';
                      return '<' + tag + style + className + '>' + title + '</' + tag + '>';
                    },
                    click: _this2.context.createInvokeHandler('editor.formatBlock')
                  })]).render();
                });

                var _loop = function _loop(styleIdx, styleLen) {
                  var item = _this2.options.styleTags[styleIdx];

                  _this2.context.memo('button.style.' + item, function () {
                    return _this2.button({
                      className: 'note-btn-style-' + item,
                      contents: '<div data-value="' + item + '">' + item.toUpperCase() + '</div>',
                      tooltip: _this2.lang.style[item],
                      click: _this2.context.createInvokeHandler('editor.formatBlock')
                    }).render();
                  });
                };

                for (var styleIdx = 0, styleLen = this.options.styleTags.length; styleIdx < styleLen; styleIdx++) {
                  _loop(styleIdx, styleLen);
                }

                this.context.memo('button.bold', function () {
                  return _this2.button({
                    className: 'note-btn-bold',
                    contents: _this2.ui.icon(_this2.options.icons.bold),
                    tooltip: _this2.lang.font.bold + _this2.representShortcut('bold'),
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.bold')
                  }).render();
                });
                this.context.memo('button.italic', function () {
                  return _this2.button({
                    className: 'note-btn-italic',
                    contents: _this2.ui.icon(_this2.options.icons.italic),
                    tooltip: _this2.lang.font.italic + _this2.representShortcut('italic'),
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.italic')
                  }).render();
                });
                this.context.memo('button.underline', function () {
                  return _this2.button({
                    className: 'note-btn-underline',
                    contents: _this2.ui.icon(_this2.options.icons.underline),
                    tooltip: _this2.lang.font.underline + _this2.representShortcut('underline'),
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.underline')
                  }).render();
                });
                this.context.memo('button.clear', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.eraser),
                    tooltip: _this2.lang.font.clear + _this2.representShortcut('removeFormat'),
                    click: _this2.context.createInvokeHandler('editor.removeFormat')
                  }).render();
                });
                this.context.memo('button.strikethrough', function () {
                  return _this2.button({
                    className: 'note-btn-strikethrough',
                    contents: _this2.ui.icon(_this2.options.icons.strikethrough),
                    tooltip: _this2.lang.font.strikethrough + _this2.representShortcut('strikethrough'),
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.strikethrough')
                  }).render();
                });
                this.context.memo('button.superscript', function () {
                  return _this2.button({
                    className: 'note-btn-superscript',
                    contents: _this2.ui.icon(_this2.options.icons.superscript),
                    tooltip: _this2.lang.font.superscript,
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.superscript')
                  }).render();
                });
                this.context.memo('button.subscript', function () {
                  return _this2.button({
                    className: 'note-btn-subscript',
                    contents: _this2.ui.icon(_this2.options.icons.subscript),
                    tooltip: _this2.lang.font.subscript,
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.subscript')
                  }).render();
                });
                this.context.memo('button.fontname', function () {
                  var styleInfo = _this2.context.invoke('editor.currentStyle');

                  if (_this2.options.addDefaultFonts) {
                    // Add 'default' fonts into the fontnames array if not exist
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(styleInfo['font-family'].split(','), function (idx, fontname) {
                      fontname = fontname.trim().replace(/['"]+/g, '');

                      if (_this2.isFontDeservedToAdd(fontname)) {
                        if (_this2.options.fontNames.indexOf(fontname) === -1) {
                          _this2.options.fontNames.push(fontname);
                        }
                      }
                    });
                  }

                  return _this2.ui.buttonGroup([_this2.button({
                    className: 'dropdown-toggle',
                    contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontname"/>', _this2.options),
                    tooltip: _this2.lang.font.name,
                    data: {
                      toggle: 'dropdown'
                    }
                  }), _this2.ui.dropdownCheck({
                    className: 'dropdown-fontname',
                    checkClassName: _this2.options.icons.menuCheck,
                    items: _this2.options.fontNames.filter(_this2.isFontInstalled.bind(_this2)),
                    title: _this2.lang.font.name,
                    template: function template(item) {
                      return '<span style="font-family: ' + env.validFontName(item) + '">' + item + '</span>';
                    },
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.fontName')
                  })]).render();
                });
                this.context.memo('button.fontsize', function () {
                  return _this2.ui.buttonGroup([_this2.button({
                    className: 'dropdown-toggle',
                    contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontsize"/>', _this2.options),
                    tooltip: _this2.lang.font.size,
                    data: {
                      toggle: 'dropdown'
                    }
                  }), _this2.ui.dropdownCheck({
                    className: 'dropdown-fontsize',
                    checkClassName: _this2.options.icons.menuCheck,
                    items: _this2.options.fontSizes,
                    title: _this2.lang.font.size,
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.fontSize')
                  })]).render();
                });
                this.context.memo('button.fontsizeunit', function () {
                  return _this2.ui.buttonGroup([_this2.button({
                    className: 'dropdown-toggle',
                    contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontsizeunit"/>', _this2.options),
                    tooltip: _this2.lang.font.sizeunit,
                    data: {
                      toggle: 'dropdown'
                    }
                  }), _this2.ui.dropdownCheck({
                    className: 'dropdown-fontsizeunit',
                    checkClassName: _this2.options.icons.menuCheck,
                    items: _this2.options.fontSizeUnits,
                    title: _this2.lang.font.sizeunit,
                    click: _this2.context.createInvokeHandlerAndUpdateState('editor.fontSizeUnit')
                  })]).render();
                });
                this.context.memo('button.color', function () {
                  return _this2.colorPalette('note-color-all', _this2.lang.color.recent, true, true);
                });
                this.context.memo('button.forecolor', function () {
                  return _this2.colorPalette('note-color-fore', _this2.lang.color.foreground, false, true);
                });
                this.context.memo('button.backcolor', function () {
                  return _this2.colorPalette('note-color-back', _this2.lang.color.background, true, false);
                });
                this.context.memo('button.ul', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.unorderedlist),
                    tooltip: _this2.lang.lists.unordered + _this2.representShortcut('insertUnorderedList'),
                    click: _this2.context.createInvokeHandler('editor.insertUnorderedList')
                  }).render();
                });
                this.context.memo('button.ol', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.orderedlist),
                    tooltip: _this2.lang.lists.ordered + _this2.representShortcut('insertOrderedList'),
                    click: _this2.context.createInvokeHandler('editor.insertOrderedList')
                  }).render();
                });
                var justifyLeft = this.button({
                  contents: this.ui.icon(this.options.icons.alignLeft),
                  tooltip: this.lang.paragraph.left + this.representShortcut('justifyLeft'),
                  click: this.context.createInvokeHandler('editor.justifyLeft')
                });
                var justifyCenter = this.button({
                  contents: this.ui.icon(this.options.icons.alignCenter),
                  tooltip: this.lang.paragraph.center + this.representShortcut('justifyCenter'),
                  click: this.context.createInvokeHandler('editor.justifyCenter')
                });
                var justifyRight = this.button({
                  contents: this.ui.icon(this.options.icons.alignRight),
                  tooltip: this.lang.paragraph.right + this.representShortcut('justifyRight'),
                  click: this.context.createInvokeHandler('editor.justifyRight')
                });
                var justifyFull = this.button({
                  contents: this.ui.icon(this.options.icons.alignJustify),
                  tooltip: this.lang.paragraph.justify + this.representShortcut('justifyFull'),
                  click: this.context.createInvokeHandler('editor.justifyFull')
                });
                var outdent = this.button({
                  contents: this.ui.icon(this.options.icons.outdent),
                  tooltip: this.lang.paragraph.outdent + this.representShortcut('outdent'),
                  click: this.context.createInvokeHandler('editor.outdent')
                });
                var indent = this.button({
                  contents: this.ui.icon(this.options.icons.indent),
                  tooltip: this.lang.paragraph.indent + this.representShortcut('indent'),
                  click: this.context.createInvokeHandler('editor.indent')
                });
                this.context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));
                this.context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));
                this.context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));
                this.context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));
                this.context.memo('button.outdent', func.invoke(outdent, 'render'));
                this.context.memo('button.indent', func.invoke(indent, 'render'));
                this.context.memo('button.paragraph', function () {
                  return _this2.ui.buttonGroup([_this2.button({
                    className: 'dropdown-toggle',
                    contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.alignLeft), _this2.options),
                    tooltip: _this2.lang.paragraph.paragraph,
                    data: {
                      toggle: 'dropdown'
                    }
                  }), _this2.ui.dropdown([_this2.ui.buttonGroup({
                    className: 'note-align',
                    children: [justifyLeft, justifyCenter, justifyRight, justifyFull]
                  }), _this2.ui.buttonGroup({
                    className: 'note-list',
                    children: [outdent, indent]
                  })])]).render();
                });
                this.context.memo('button.height', function () {
                  return _this2.ui.buttonGroup([_this2.button({
                    className: 'dropdown-toggle',
                    contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.textHeight), _this2.options),
                    tooltip: _this2.lang.font.height,
                    data: {
                      toggle: 'dropdown'
                    }
                  }), _this2.ui.dropdownCheck({
                    items: _this2.options.lineHeights,
                    checkClassName: _this2.options.icons.menuCheck,
                    className: 'dropdown-line-height',
                    title: _this2.lang.font.height,
                    click: _this2.context.createInvokeHandler('editor.lineHeight')
                  })]).render();
                });
                this.context.memo('button.table', function () {
                  return _this2.ui.buttonGroup([_this2.button({
                    className: 'dropdown-toggle',
                    contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.table), _this2.options),
                    tooltip: _this2.lang.table.table,
                    data: {
                      toggle: 'dropdown'
                    }
                  }), _this2.ui.dropdown({
                    title: _this2.lang.table.table,
                    className: 'note-table',
                    items: ['<div class="note-dimension-picker">', '<div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"/>', '<div class="note-dimension-picker-highlighted"/>', '<div class="note-dimension-picker-unhighlighted"/>', '</div>', '<div class="note-dimension-display">1 x 1</div>'].join('')
                  })], {
                    callback: function callback($node) {
                      var $catcher = $node.find('.note-dimension-picker-mousecatcher');
                      $catcher.css({
                        width: _this2.options.insertTableMaxSize.col + 'em',
                        height: _this2.options.insertTableMaxSize.row + 'em'
                      }).mousedown(_this2.context.createInvokeHandler('editor.insertTable')).on('mousemove', _this2.tableMoveHandler.bind(_this2));
                    }
                  }).render();
                });
                this.context.memo('button.link', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.link),
                    tooltip: _this2.lang.link.link + _this2.representShortcut('linkDialog.show'),
                    click: _this2.context.createInvokeHandler('linkDialog.show')
                  }).render();
                });
                this.context.memo('button.picture', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.picture),
                    tooltip: _this2.lang.image.image,
                    click: _this2.context.createInvokeHandler('imageDialog.show')
                  }).render();
                });
                this.context.memo('button.video', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.video),
                    tooltip: _this2.lang.video.video,
                    click: _this2.context.createInvokeHandler('videoDialog.show')
                  }).render();
                });
                this.context.memo('button.hr', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.minus),
                    tooltip: _this2.lang.hr.insert + _this2.representShortcut('insertHorizontalRule'),
                    click: _this2.context.createInvokeHandler('editor.insertHorizontalRule')
                  }).render();
                });
                this.context.memo('button.fullscreen', function () {
                  return _this2.button({
                    className: 'btn-fullscreen',
                    contents: _this2.ui.icon(_this2.options.icons.arrowsAlt),
                    tooltip: _this2.lang.options.fullscreen,
                    click: _this2.context.createInvokeHandler('fullscreen.toggle')
                  }).render();
                });
                this.context.memo('button.codeview', function () {
                  return _this2.button({
                    className: 'btn-codeview',
                    contents: _this2.ui.icon(_this2.options.icons.code),
                    tooltip: _this2.lang.options.codeview,
                    click: _this2.context.createInvokeHandler('codeview.toggle')
                  }).render();
                });
                this.context.memo('button.redo', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.redo),
                    tooltip: _this2.lang.history.redo + _this2.representShortcut('redo'),
                    click: _this2.context.createInvokeHandler('editor.redo')
                  }).render();
                });
                this.context.memo('button.undo', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.undo),
                    tooltip: _this2.lang.history.undo + _this2.representShortcut('undo'),
                    click: _this2.context.createInvokeHandler('editor.undo')
                  }).render();
                });
                this.context.memo('button.help', function () {
                  return _this2.button({
                    contents: _this2.ui.icon(_this2.options.icons.question),
                    tooltip: _this2.lang.options.help,
                    click: _this2.context.createInvokeHandler('helpDialog.show')
                  }).render();
                });
              }
              /**
               * image: [
               *   ['imageResize', ['resizeFull', 'resizeHalf', 'resizeQuarter', 'resizeNone']],
               *   ['float', ['floatLeft', 'floatRight', 'floatNone']],
               *   ['remove', ['removeMedia']],
               * ],
               */

            }, {
              key: "addImagePopoverButtons",
              value: function addImagePopoverButtons() {
                var _this3 = this;

                // Image Size Buttons
                this.context.memo('button.resizeFull', function () {
                  return _this3.button({
                    contents: '<span class="note-fontsize-10">100%</span>',
                    tooltip: _this3.lang.image.resizeFull,
                    click: _this3.context.createInvokeHandler('editor.resize', '1')
                  }).render();
                });
                this.context.memo('button.resizeHalf', function () {
                  return _this3.button({
                    contents: '<span class="note-fontsize-10">50%</span>',
                    tooltip: _this3.lang.image.resizeHalf,
                    click: _this3.context.createInvokeHandler('editor.resize', '0.5')
                  }).render();
                });
                this.context.memo('button.resizeQuarter', function () {
                  return _this3.button({
                    contents: '<span class="note-fontsize-10">25%</span>',
                    tooltip: _this3.lang.image.resizeQuarter,
                    click: _this3.context.createInvokeHandler('editor.resize', '0.25')
                  }).render();
                });
                this.context.memo('button.resizeNone', function () {
                  return _this3.button({
                    contents: _this3.ui.icon(_this3.options.icons.rollback),
                    tooltip: _this3.lang.image.resizeNone,
                    click: _this3.context.createInvokeHandler('editor.resize', '0')
                  }).render();
                }); // Float Buttons

                this.context.memo('button.floatLeft', function () {
                  return _this3.button({
                    contents: _this3.ui.icon(_this3.options.icons.floatLeft),
                    tooltip: _this3.lang.image.floatLeft,
                    click: _this3.context.createInvokeHandler('editor.floatMe', 'left')
                  }).render();
                });
                this.context.memo('button.floatRight', function () {
                  return _this3.button({
                    contents: _this3.ui.icon(_this3.options.icons.floatRight),
                    tooltip: _this3.lang.image.floatRight,
                    click: _this3.context.createInvokeHandler('editor.floatMe', 'right')
                  }).render();
                });
                this.context.memo('button.floatNone', function () {
                  return _this3.button({
                    contents: _this3.ui.icon(_this3.options.icons.rollback),
                    tooltip: _this3.lang.image.floatNone,
                    click: _this3.context.createInvokeHandler('editor.floatMe', 'none')
                  }).render();
                }); // Remove Buttons

                this.context.memo('button.removeMedia', function () {
                  return _this3.button({
                    contents: _this3.ui.icon(_this3.options.icons.trash),
                    tooltip: _this3.lang.image.remove,
                    click: _this3.context.createInvokeHandler('editor.removeMedia')
                  }).render();
                });
              }
            }, {
              key: "addLinkPopoverButtons",
              value: function addLinkPopoverButtons() {
                var _this4 = this;

                this.context.memo('button.linkDialogShow', function () {
                  return _this4.button({
                    contents: _this4.ui.icon(_this4.options.icons.link),
                    tooltip: _this4.lang.link.edit,
                    click: _this4.context.createInvokeHandler('linkDialog.show')
                  }).render();
                });
                this.context.memo('button.unlink', function () {
                  return _this4.button({
                    contents: _this4.ui.icon(_this4.options.icons.unlink),
                    tooltip: _this4.lang.link.unlink,
                    click: _this4.context.createInvokeHandler('editor.unlink')
                  }).render();
                });
              }
              /**
               * table : [
               *  ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
               *  ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
               * ],
               */

            }, {
              key: "addTablePopoverButtons",
              value: function addTablePopoverButtons() {
                var _this5 = this;

                this.context.memo('button.addRowUp', function () {
                  return _this5.button({
                    className: 'btn-md',
                    contents: _this5.ui.icon(_this5.options.icons.rowAbove),
                    tooltip: _this5.lang.table.addRowAbove,
                    click: _this5.context.createInvokeHandler('editor.addRow', 'top')
                  }).render();
                });
                this.context.memo('button.addRowDown', function () {
                  return _this5.button({
                    className: 'btn-md',
                    contents: _this5.ui.icon(_this5.options.icons.rowBelow),
                    tooltip: _this5.lang.table.addRowBelow,
                    click: _this5.context.createInvokeHandler('editor.addRow', 'bottom')
                  }).render();
                });
                this.context.memo('button.addColLeft', function () {
                  return _this5.button({
                    className: 'btn-md',
                    contents: _this5.ui.icon(_this5.options.icons.colBefore),
                    tooltip: _this5.lang.table.addColLeft,
                    click: _this5.context.createInvokeHandler('editor.addCol', 'left')
                  }).render();
                });
                this.context.memo('button.addColRight', function () {
                  return _this5.button({
                    className: 'btn-md',
                    contents: _this5.ui.icon(_this5.options.icons.colAfter),
                    tooltip: _this5.lang.table.addColRight,
                    click: _this5.context.createInvokeHandler('editor.addCol', 'right')
                  }).render();
                });
                this.context.memo('button.deleteRow', function () {
                  return _this5.button({
                    className: 'btn-md',
                    contents: _this5.ui.icon(_this5.options.icons.rowRemove),
                    tooltip: _this5.lang.table.delRow,
                    click: _this5.context.createInvokeHandler('editor.deleteRow')
                  }).render();
                });
                this.context.memo('button.deleteCol', function () {
                  return _this5.button({
                    className: 'btn-md',
                    contents: _this5.ui.icon(_this5.options.icons.colRemove),
                    tooltip: _this5.lang.table.delCol,
                    click: _this5.context.createInvokeHandler('editor.deleteCol')
                  }).render();
                });
                this.context.memo('button.deleteTable', function () {
                  return _this5.button({
                    className: 'btn-md',
                    contents: _this5.ui.icon(_this5.options.icons.trash),
                    tooltip: _this5.lang.table.delTable,
                    click: _this5.context.createInvokeHandler('editor.deleteTable')
                  }).render();
                });
              }
            }, {
              key: "build",
              value: function build($container, groups) {
                for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {
                  var group = groups[groupIdx];
                  var groupName = Array.isArray(group) ? group[0] : group;
                  var buttons = Array.isArray(group) ? group.length === 1 ? [group[0]] : group[1] : [group];
                  var $group = this.ui.buttonGroup({
                    className: 'note-' + groupName
                  }).render();

                  for (var idx = 0, len = buttons.length; idx < len; idx++) {
                    var btn = this.context.memo('button.' + buttons[idx]);

                    if (btn) {
                      $group.append(typeof btn === 'function' ? btn(this.context) : btn);
                    }
                  }

                  $group.appendTo($container);
                }
              }
              /**
               * @param {jQuery} [$container]
               */

            }, {
              key: "updateCurrentStyle",
              value: function updateCurrentStyle($container) {
                var _this6 = this;

                var $cont = $container || this.$toolbar;
                var styleInfo = this.context.invoke('editor.currentStyle');
                this.updateBtnStates($cont, {
                  '.note-btn-bold': function noteBtnBold() {
                    return styleInfo['font-bold'] === 'bold';
                  },
                  '.note-btn-italic': function noteBtnItalic() {
                    return styleInfo['font-italic'] === 'italic';
                  },
                  '.note-btn-underline': function noteBtnUnderline() {
                    return styleInfo['font-underline'] === 'underline';
                  },
                  '.note-btn-subscript': function noteBtnSubscript() {
                    return styleInfo['font-subscript'] === 'subscript';
                  },
                  '.note-btn-superscript': function noteBtnSuperscript() {
                    return styleInfo['font-superscript'] === 'superscript';
                  },
                  '.note-btn-strikethrough': function noteBtnStrikethrough() {
                    return styleInfo['font-strikethrough'] === 'strikethrough';
                  }
                });

                if (styleInfo['font-family']) {
                  var fontNames = styleInfo['font-family'].split(',').map(function (name) {
                    return name.replace(/[\'\"]/g, '').replace(/\s+$/, '').replace(/^\s+/, '');
                  });
                  var fontName = lists.find(fontNames, this.isFontInstalled.bind(this));
                  $cont.find('.dropdown-fontname a').each(function (idx, item) {
                    var $item = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item); // always compare string to avoid creating another func.

                    var isChecked = $item.data('value') + '' === fontName + '';
                    $item.toggleClass('checked', isChecked);
                  });
                  $cont.find('.note-current-fontname').text(fontName).css('font-family', fontName);
                }

                if (styleInfo['font-size']) {
                  var fontSize = styleInfo['font-size'];
                  $cont.find('.dropdown-fontsize a').each(function (idx, item) {
                    var $item = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item); // always compare with string to avoid creating another func.

                    var isChecked = $item.data('value') + '' === fontSize + '';
                    $item.toggleClass('checked', isChecked);
                  });
                  $cont.find('.note-current-fontsize').text(fontSize);
                  var fontSizeUnit = styleInfo['font-size-unit'];
                  $cont.find('.dropdown-fontsizeunit a').each(function (idx, item) {
                    var $item = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item);
                    var isChecked = $item.data('value') + '' === fontSizeUnit + '';
                    $item.toggleClass('checked', isChecked);
                  });
                  $cont.find('.note-current-fontsizeunit').text(fontSizeUnit);
                }

                if (styleInfo['line-height']) {
                  var lineHeight = styleInfo['line-height'];
                  $cont.find('.dropdown-line-height li a').each(function (idx, item) {
                    // always compare with string to avoid creating another func.
                    var isChecked = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item).data('value') + '' === lineHeight + '';
                    _this6.className = isChecked ? 'checked' : '';
                  });
                }
              }
            }, {
              key: "updateBtnStates",
              value: function updateBtnStates($container, infos) {
                var _this7 = this;

                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(infos, function (selector, pred) {
                  _this7.ui.toggleBtnActive($container.find(selector), pred());
                });
              }
            }, {
              key: "tableMoveHandler",
              value: function tableMoveHandler(event) {
                var PX_PER_EM = 18;
                var $picker = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(event.target.parentNode); // target is mousecatcher

                var $dimensionDisplay = $picker.next();
                var $catcher = $picker.find('.note-dimension-picker-mousecatcher');
                var $highlighted = $picker.find('.note-dimension-picker-highlighted');
                var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');
                var posOffset; // HTML5 with jQuery - e.offsetX is undefined in Firefox

                if (event.offsetX === undefined) {
                  var posCatcher = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(event.target).offset();
                  posOffset = {
                    x: event.pageX - posCatcher.left,
                    y: event.pageY - posCatcher.top
                  };
                } else {
                  posOffset = {
                    x: event.offsetX,
                    y: event.offsetY
                  };
                }

                var dim = {
                  c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
                  r: Math.ceil(posOffset.y / PX_PER_EM) || 1
                };
                $highlighted.css({
                  width: dim.c + 'em',
                  height: dim.r + 'em'
                });
                $catcher.data('value', dim.c + 'x' + dim.r);

                if (dim.c > 3 && dim.c < this.options.insertTableMaxSize.col) {
                  $unhighlighted.css({
                    width: dim.c + 1 + 'em'
                  });
                }

                if (dim.r > 3 && dim.r < this.options.insertTableMaxSize.row) {
                  $unhighlighted.css({
                    height: dim.r + 1 + 'em'
                  });
                }

                $dimensionDisplay.html(dim.c + ' x ' + dim.r);
              }
            }]);

            return Buttons;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/Toolbar.js
          function Toolbar_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function Toolbar_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function Toolbar_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) Toolbar_defineProperties(Constructor.prototype, protoProps);if (staticProps) Toolbar_defineProperties(Constructor, staticProps);return Constructor;
          }

          var Toolbar_Toolbar =
          /*#__PURE__*/
          function () {
            function Toolbar(context) {
              Toolbar_classCallCheck(this, Toolbar);

              this.context = context;
              this.$window = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(window);
              this.$document = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.$note = context.layoutInfo.note;
              this.$editor = context.layoutInfo.editor;
              this.$toolbar = context.layoutInfo.toolbar;
              this.$editable = context.layoutInfo.editable;
              this.$statusbar = context.layoutInfo.statusbar;
              this.options = context.options;
              this.isFollowing = false;
              this.followScroll = this.followScroll.bind(this);
            }

            Toolbar_createClass(Toolbar, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return !this.options.airMode;
              }
            }, {
              key: "initialize",
              value: function initialize() {
                var _this = this;

                this.options.toolbar = this.options.toolbar || [];

                if (!this.options.toolbar.length) {
                  this.$toolbar.hide();
                } else {
                  this.context.invoke('buttons.build', this.$toolbar, this.options.toolbar);
                }

                if (this.options.toolbarContainer) {
                  this.$toolbar.appendTo(this.options.toolbarContainer);
                }

                this.changeContainer(false);
                this.$note.on('summernote.keyup summernote.mouseup summernote.change', function () {
                  _this.context.invoke('buttons.updateCurrentStyle');
                });
                this.context.invoke('buttons.updateCurrentStyle');

                if (this.options.followingToolbar) {
                  this.$window.on('scroll resize', this.followScroll);
                }
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$toolbar.children().remove();

                if (this.options.followingToolbar) {
                  this.$window.off('scroll resize', this.followScroll);
                }
              }
            }, {
              key: "followScroll",
              value: function followScroll() {
                if (this.$editor.hasClass('fullscreen')) {
                  return false;
                }

                var editorHeight = this.$editor.outerHeight();
                var editorWidth = this.$editor.width();
                var toolbarHeight = this.$toolbar.height();
                var statusbarHeight = this.$statusbar.height(); // check if the web app is currently using another static bar

                var otherBarHeight = 0;

                if (this.options.otherStaticBar) {
                  otherBarHeight = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.otherStaticBar).outerHeight();
                }

                var currentOffset = this.$document.scrollTop();
                var editorOffsetTop = this.$editor.offset().top;
                var editorOffsetBottom = editorOffsetTop + editorHeight;
                var activateOffset = editorOffsetTop - otherBarHeight;
                var deactivateOffsetBottom = editorOffsetBottom - otherBarHeight - toolbarHeight - statusbarHeight;

                if (!this.isFollowing && currentOffset > activateOffset && currentOffset < deactivateOffsetBottom - toolbarHeight) {
                  this.isFollowing = true;
                  this.$editable.css({
                    marginTop: this.$toolbar.outerHeight()
                  });
                  this.$toolbar.css({
                    position: 'fixed',
                    top: otherBarHeight,
                    width: editorWidth,
                    zIndex: 1000
                  });
                } else if (this.isFollowing && (currentOffset < activateOffset || currentOffset > deactivateOffsetBottom)) {
                  this.isFollowing = false;
                  this.$toolbar.css({
                    position: 'relative',
                    top: 0,
                    width: '100%',
                    zIndex: 'auto'
                  });
                  this.$editable.css({
                    marginTop: ''
                  });
                }
              }
            }, {
              key: "changeContainer",
              value: function changeContainer(isFullscreen) {
                if (isFullscreen) {
                  this.$toolbar.prependTo(this.$editor);
                } else {
                  if (this.options.toolbarContainer) {
                    this.$toolbar.appendTo(this.options.toolbarContainer);
                  }
                }

                if (this.options.followingToolbar) {
                  this.followScroll();
                }
              }
            }, {
              key: "updateFullscreen",
              value: function updateFullscreen(isFullscreen) {
                this.ui.toggleBtnActive(this.$toolbar.find('.btn-fullscreen'), isFullscreen);
                this.changeContainer(isFullscreen);
              }
            }, {
              key: "updateCodeview",
              value: function updateCodeview(isCodeview) {
                this.ui.toggleBtnActive(this.$toolbar.find('.btn-codeview'), isCodeview);

                if (isCodeview) {
                  this.deactivate();
                } else {
                  this.activate();
                }
              }
            }, {
              key: "activate",
              value: function activate(isIncludeCodeview) {
                var $btn = this.$toolbar.find('button');

                if (!isIncludeCodeview) {
                  $btn = $btn.not('.btn-codeview').not('.btn-fullscreen');
                }

                this.ui.toggleBtn($btn, true);
              }
            }, {
              key: "deactivate",
              value: function deactivate(isIncludeCodeview) {
                var $btn = this.$toolbar.find('button');

                if (!isIncludeCodeview) {
                  $btn = $btn.not('.btn-codeview').not('.btn-fullscreen');
                }

                this.ui.toggleBtn($btn, false);
              }
            }]);

            return Toolbar;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/LinkDialog.js
          function LinkDialog_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function LinkDialog_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function LinkDialog_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) LinkDialog_defineProperties(Constructor.prototype, protoProps);if (staticProps) LinkDialog_defineProperties(Constructor, staticProps);return Constructor;
          }

          var LinkDialog_LinkDialog =
          /*#__PURE__*/
          function () {
            function LinkDialog(context) {
              LinkDialog_classCallCheck(this, LinkDialog);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.$body = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document.body);
              this.$editor = context.layoutInfo.editor;
              this.options = context.options;
              this.lang = this.options.langInfo;
              context.memo('help.linkDialog.show', this.options.langInfo.help['linkDialog.show']);
            }

            LinkDialog_createClass(LinkDialog, [{
              key: "initialize",
              value: function initialize() {
                var $container = this.options.dialogsInBody ? this.$body : this.options.container;
                var body = ['<div class="form-group note-form-group">', "<label for=\"note-dialog-link-txt-".concat(this.options.id, "\" class=\"note-form-label\">").concat(this.lang.link.textToDisplay, "</label>"), "<input id=\"note-dialog-link-txt-".concat(this.options.id, "\" class=\"note-link-text form-control note-form-control note-input\" type=\"text\"/>"), '</div>', '<div class="form-group note-form-group">', "<label for=\"note-dialog-link-url-".concat(this.options.id, "\" class=\"note-form-label\">").concat(this.lang.link.url, "</label>"), "<input id=\"note-dialog-link-url-".concat(this.options.id, "\" class=\"note-link-url form-control note-form-control note-input\" type=\"text\" value=\"http://\"/>"), '</div>', !this.options.disableLinkTarget ? external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div/>').append(this.ui.checkbox({
                  className: 'sn-checkbox-open-in-new-window',
                  text: this.lang.link.openInNewWindow,
                  checked: true
                }).render()).html() : '', external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div/>').append(this.ui.checkbox({
                  className: 'sn-checkbox-use-protocol',
                  text: this.lang.link.useProtocol,
                  checked: true
                }).render()).html()].join('');
                var buttonClass = 'btn btn-primary note-btn note-btn-primary note-link-btn';
                var footer = "<input type=\"button\" href=\"#\" class=\"".concat(buttonClass, "\" value=\"").concat(this.lang.link.insert, "\" disabled>");
                this.$dialog = this.ui.dialog({
                  className: 'link-dialog',
                  title: this.lang.link.insert,
                  fade: this.options.dialogsFade,
                  body: body,
                  footer: footer
                }).render().appendTo($container);
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.ui.hideDialog(this.$dialog);
                this.$dialog.remove();
              }
            }, {
              key: "bindEnterKey",
              value: function bindEnterKey($input, $btn) {
                $input.on('keypress', function (event) {
                  if (event.keyCode === core_key.code.ENTER) {
                    event.preventDefault();
                    $btn.trigger('click');
                  }
                });
              }
              /**
               * toggle update button
               */

            }, {
              key: "toggleLinkBtn",
              value: function toggleLinkBtn($linkBtn, $linkText, $linkUrl) {
                this.ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
              }
              /**
               * Show link dialog and set event handlers on dialog controls.
               *
               * @param {Object} linkInfo
               * @return {Promise}
               */

            }, {
              key: "showLinkDialog",
              value: function showLinkDialog(linkInfo) {
                var _this = this;

                return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
                  var $linkText = _this.$dialog.find('.note-link-text');

                  var $linkUrl = _this.$dialog.find('.note-link-url');

                  var $linkBtn = _this.$dialog.find('.note-link-btn');

                  var $openInNewWindow = _this.$dialog.find('.sn-checkbox-open-in-new-window input[type=checkbox]');

                  var $useProtocol = _this.$dialog.find('.sn-checkbox-use-protocol input[type=checkbox]');

                  _this.ui.onDialogShown(_this.$dialog, function () {
                    _this.context.triggerEvent('dialog.shown'); // If no url was given and given text is valid URL then copy that into URL Field


                    if (!linkInfo.url && func.isValidUrl(linkInfo.text)) {
                      linkInfo.url = linkInfo.text;
                    }

                    $linkText.on('input paste propertychange', function () {
                      // If linktext was modified by input events,
                      // cloning text from linkUrl will be stopped.
                      linkInfo.text = $linkText.val();

                      _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                    }).val(linkInfo.text);
                    $linkUrl.on('input paste propertychange', function () {
                      // Display same text on `Text to display` as default
                      // when linktext has no text
                      if (!linkInfo.text) {
                        $linkText.val($linkUrl.val());
                      }

                      _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                    }).val(linkInfo.url);

                    if (!env.isSupportTouch) {
                      $linkUrl.trigger('focus');
                    }

                    _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);

                    _this.bindEnterKey($linkUrl, $linkBtn);

                    _this.bindEnterKey($linkText, $linkBtn);

                    var isNewWindowChecked = linkInfo.isNewWindow !== undefined ? linkInfo.isNewWindow : _this.context.options.linkTargetBlank;
                    $openInNewWindow.prop('checked', isNewWindowChecked);
                    var useProtocolChecked = linkInfo.url ? false : _this.context.options.useProtocol;
                    $useProtocol.prop('checked', useProtocolChecked);
                    $linkBtn.one('click', function (event) {
                      event.preventDefault();
                      deferred.resolve({
                        range: linkInfo.range,
                        url: $linkUrl.val(),
                        text: $linkText.val(),
                        isNewWindow: $openInNewWindow.is(':checked'),
                        checkProtocol: $useProtocol.is(':checked')
                      });

                      _this.ui.hideDialog(_this.$dialog);
                    });
                  });

                  _this.ui.onDialogHidden(_this.$dialog, function () {
                    // detach events
                    $linkText.off();
                    $linkUrl.off();
                    $linkBtn.off();

                    if (deferred.state() === 'pending') {
                      deferred.reject();
                    }
                  });

                  _this.ui.showDialog(_this.$dialog);
                }).promise();
              }
              /**
               * @param {Object} layoutInfo
               */

            }, {
              key: "show",
              value: function show() {
                var _this2 = this;

                var linkInfo = this.context.invoke('editor.getLinkInfo');
                this.context.invoke('editor.saveRange');
                this.showLinkDialog(linkInfo).then(function (linkInfo) {
                  _this2.context.invoke('editor.restoreRange');

                  _this2.context.invoke('editor.createLink', linkInfo);
                }).fail(function () {
                  _this2.context.invoke('editor.restoreRange');
                });
              }
            }]);

            return LinkDialog;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/LinkPopover.js
          function LinkPopover_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function LinkPopover_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function LinkPopover_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) LinkPopover_defineProperties(Constructor.prototype, protoProps);if (staticProps) LinkPopover_defineProperties(Constructor, staticProps);return Constructor;
          }

          var LinkPopover_LinkPopover =
          /*#__PURE__*/
          function () {
            function LinkPopover(context) {
              var _this = this;

              LinkPopover_classCallCheck(this, LinkPopover);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.options = context.options;
              this.events = {
                'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function summernoteKeyupSummernoteMouseupSummernoteChangeSummernoteScroll() {
                  _this.update();
                },
                'summernote.disable summernote.dialog.shown summernote.blur': function summernoteDisableSummernoteDialogShownSummernoteBlur() {
                  _this.hide();
                }
              };
            }

            LinkPopover_createClass(LinkPopover, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return !lists.isEmpty(this.options.popover.link);
              }
            }, {
              key: "initialize",
              value: function initialize() {
                this.$popover = this.ui.popover({
                  className: 'note-link-popover',
                  callback: function callback($node) {
                    var $content = $node.find('.popover-content,.note-popover-content');
                    $content.prepend('<span><a target="_blank"></a>&nbsp;</span>');
                  }
                }).render().appendTo(this.options.container);
                var $content = this.$popover.find('.popover-content,.note-popover-content');
                this.context.invoke('buttons.build', $content, this.options.popover.link);
                this.$popover.on('mousedown', function (e) {
                  e.preventDefault();
                });
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$popover.remove();
              }
            }, {
              key: "update",
              value: function update() {
                // Prevent focusing on editable when invoke('code') is executed
                if (!this.context.invoke('editor.hasFocus')) {
                  this.hide();
                  return;
                }

                var rng = this.context.invoke('editor.getLastRange');

                if (rng.isCollapsed() && rng.isOnAnchor()) {
                  var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                  var href = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(anchor).attr('href');
                  this.$popover.find('a').attr('href', href).text(href);
                  var pos = dom.posFromPlaceholder(anchor);
                  var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();
                  pos.top -= containerOffset.top;
                  pos.left -= containerOffset.left;
                  this.$popover.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top
                  });
                } else {
                  this.hide();
                }
              }
            }, {
              key: "hide",
              value: function hide() {
                this.$popover.hide();
              }
            }]);

            return LinkPopover;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/ImageDialog.js
          function ImageDialog_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function ImageDialog_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function ImageDialog_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) ImageDialog_defineProperties(Constructor.prototype, protoProps);if (staticProps) ImageDialog_defineProperties(Constructor, staticProps);return Constructor;
          }

          var ImageDialog_ImageDialog =
          /*#__PURE__*/
          function () {
            function ImageDialog(context) {
              ImageDialog_classCallCheck(this, ImageDialog);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.$body = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document.body);
              this.$editor = context.layoutInfo.editor;
              this.options = context.options;
              this.lang = this.options.langInfo;
            }

            ImageDialog_createClass(ImageDialog, [{
              key: "initialize",
              value: function initialize() {
                var imageLimitation = '';

                if (this.options.maximumImageFileSize) {
                  var unit = Math.floor(Math.log(this.options.maximumImageFileSize) / Math.log(1024));
                  var readableSize = (this.options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 + ' ' + ' KMGTP'[unit] + 'B';
                  imageLimitation = "<small>".concat(this.lang.image.maximumFileSize + ' : ' + readableSize, "</small>");
                }

                var $container = this.options.dialogsInBody ? this.$body : this.options.container;
                var body = ['<div class="form-group note-form-group note-group-select-from-files">', '<label for="note-dialog-image-file-' + this.options.id + '" class="note-form-label">' + this.lang.image.selectFromFiles + '</label>', '<input id="note-dialog-image-file-' + this.options.id + '" class="note-image-input form-control-file note-form-control note-input" ', ' type="file" name="files" accept="image/*" multiple="multiple"/>', imageLimitation, '</div>', '<div class="form-group note-group-image-url">', '<label for="note-dialog-image-url-' + this.options.id + '" class="note-form-label">' + this.lang.image.url + '</label>', '<input id="note-dialog-image-url-' + this.options.id + '" class="note-image-url form-control note-form-control note-input" type="text"/>', '</div>'].join('');
                var buttonClass = 'btn btn-primary note-btn note-btn-primary note-image-btn';
                var footer = "<input type=\"button\" href=\"#\" class=\"".concat(buttonClass, "\" value=\"").concat(this.lang.image.insert, "\" disabled>");
                this.$dialog = this.ui.dialog({
                  title: this.lang.image.insert,
                  fade: this.options.dialogsFade,
                  body: body,
                  footer: footer
                }).render().appendTo($container);
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.ui.hideDialog(this.$dialog);
                this.$dialog.remove();
              }
            }, {
              key: "bindEnterKey",
              value: function bindEnterKey($input, $btn) {
                $input.on('keypress', function (event) {
                  if (event.keyCode === core_key.code.ENTER) {
                    event.preventDefault();
                    $btn.trigger('click');
                  }
                });
              }
            }, {
              key: "show",
              value: function show() {
                var _this = this;

                this.context.invoke('editor.saveRange');
                this.showImageDialog().then(function (data) {
                  // [workaround] hide dialog before restore range for IE range focus
                  _this.ui.hideDialog(_this.$dialog);

                  _this.context.invoke('editor.restoreRange');

                  if (typeof data === 'string') {
                    // image url
                    // If onImageLinkInsert set,
                    if (_this.options.callbacks.onImageLinkInsert) {
                      _this.context.triggerEvent('image.link.insert', data);
                    } else {
                      _this.context.invoke('editor.insertImage', data);
                    }
                  } else {
                    // array of files
                    _this.context.invoke('editor.insertImagesOrCallback', data);
                  }
                }).fail(function () {
                  _this.context.invoke('editor.restoreRange');
                });
              }
              /**
               * show image dialog
               *
               * @param {jQuery} $dialog
               * @return {Promise}
               */

            }, {
              key: "showImageDialog",
              value: function showImageDialog() {
                var _this2 = this;

                return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
                  var $imageInput = _this2.$dialog.find('.note-image-input');

                  var $imageUrl = _this2.$dialog.find('.note-image-url');

                  var $imageBtn = _this2.$dialog.find('.note-image-btn');

                  _this2.ui.onDialogShown(_this2.$dialog, function () {
                    _this2.context.triggerEvent('dialog.shown'); // Cloning imageInput to clear element.


                    $imageInput.replaceWith($imageInput.clone().on('change', function (event) {
                      deferred.resolve(event.target.files || event.target.value);
                    }).val(''));
                    $imageUrl.on('input paste propertychange', function () {
                      _this2.ui.toggleBtn($imageBtn, $imageUrl.val());
                    }).val('');

                    if (!env.isSupportTouch) {
                      $imageUrl.trigger('focus');
                    }

                    $imageBtn.click(function (event) {
                      event.preventDefault();
                      deferred.resolve($imageUrl.val());
                    });

                    _this2.bindEnterKey($imageUrl, $imageBtn);
                  });

                  _this2.ui.onDialogHidden(_this2.$dialog, function () {
                    $imageInput.off();
                    $imageUrl.off();
                    $imageBtn.off();

                    if (deferred.state() === 'pending') {
                      deferred.reject();
                    }
                  });

                  _this2.ui.showDialog(_this2.$dialog);
                });
              }
            }]);

            return ImageDialog;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/ImagePopover.js
          function ImagePopover_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function ImagePopover_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function ImagePopover_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) ImagePopover_defineProperties(Constructor.prototype, protoProps);if (staticProps) ImagePopover_defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * Image popover module
           *  mouse events that show/hide popover will be handled by Handle.js.
           *  Handle.js will receive the events and invoke 'imagePopover.update'.
           */

          var ImagePopover_ImagePopover =
          /*#__PURE__*/
          function () {
            function ImagePopover(context) {
              var _this = this;

              ImagePopover_classCallCheck(this, ImagePopover);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.editable = context.layoutInfo.editable[0];
              this.options = context.options;
              this.events = {
                'summernote.disable summernote.blur': function summernoteDisableSummernoteBlur() {
                  _this.hide();
                }
              };
            }

            ImagePopover_createClass(ImagePopover, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return !lists.isEmpty(this.options.popover.image);
              }
            }, {
              key: "initialize",
              value: function initialize() {
                this.$popover = this.ui.popover({
                  className: 'note-image-popover'
                }).render().appendTo(this.options.container);
                var $content = this.$popover.find('.popover-content,.note-popover-content');
                this.context.invoke('buttons.build', $content, this.options.popover.image);
                this.$popover.on('mousedown', function (e) {
                  e.preventDefault();
                });
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$popover.remove();
              }
            }, {
              key: "update",
              value: function update(target, event) {
                if (dom.isImg(target)) {
                  var position = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(target).offset();
                  var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();
                  var pos = {};

                  if (this.options.popatmouse) {
                    pos.left = event.pageX - 20;
                    pos.top = event.pageY;
                  } else {
                    pos = position;
                  }

                  pos.top -= containerOffset.top;
                  pos.left -= containerOffset.left;
                  this.$popover.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top
                  });
                } else {
                  this.hide();
                }
              }
            }, {
              key: "hide",
              value: function hide() {
                this.$popover.hide();
              }
            }]);

            return ImagePopover;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/TablePopover.js
          function TablePopover_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function TablePopover_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function TablePopover_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) TablePopover_defineProperties(Constructor.prototype, protoProps);if (staticProps) TablePopover_defineProperties(Constructor, staticProps);return Constructor;
          }

          var TablePopover_TablePopover =
          /*#__PURE__*/
          function () {
            function TablePopover(context) {
              var _this = this;

              TablePopover_classCallCheck(this, TablePopover);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.options = context.options;
              this.events = {
                'summernote.mousedown': function summernoteMousedown(we, e) {
                  _this.update(e.target);
                },
                'summernote.keyup summernote.scroll summernote.change': function summernoteKeyupSummernoteScrollSummernoteChange() {
                  _this.update();
                },
                'summernote.disable summernote.blur': function summernoteDisableSummernoteBlur() {
                  _this.hide();
                }
              };
            }

            TablePopover_createClass(TablePopover, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return !lists.isEmpty(this.options.popover.table);
              }
            }, {
              key: "initialize",
              value: function initialize() {
                this.$popover = this.ui.popover({
                  className: 'note-table-popover'
                }).render().appendTo(this.options.container);
                var $content = this.$popover.find('.popover-content,.note-popover-content');
                this.context.invoke('buttons.build', $content, this.options.popover.table); // [workaround] Disable Firefox's default table editor

                if (env.isFF) {
                  document.execCommand('enableInlineTableEditing', false, false);
                }

                this.$popover.on('mousedown', function (e) {
                  e.preventDefault();
                });
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$popover.remove();
              }
            }, {
              key: "update",
              value: function update(target) {
                if (this.context.isDisabled()) {
                  return false;
                }

                var isCell = dom.isCell(target);

                if (isCell) {
                  var pos = dom.posFromPlaceholder(target);
                  var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();
                  pos.top -= containerOffset.top;
                  pos.left -= containerOffset.left;
                  this.$popover.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top
                  });
                } else {
                  this.hide();
                }

                return isCell;
              }
            }, {
              key: "hide",
              value: function hide() {
                this.$popover.hide();
              }
            }]);

            return TablePopover;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/VideoDialog.js
          function VideoDialog_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function VideoDialog_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function VideoDialog_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) VideoDialog_defineProperties(Constructor.prototype, protoProps);if (staticProps) VideoDialog_defineProperties(Constructor, staticProps);return Constructor;
          }

          var VideoDialog_VideoDialog =
          /*#__PURE__*/
          function () {
            function VideoDialog(context) {
              VideoDialog_classCallCheck(this, VideoDialog);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.$body = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document.body);
              this.$editor = context.layoutInfo.editor;
              this.options = context.options;
              this.lang = this.options.langInfo;
            }

            VideoDialog_createClass(VideoDialog, [{
              key: "initialize",
              value: function initialize() {
                var $container = this.options.dialogsInBody ? this.$body : this.options.container;
                var body = ['<div class="form-group note-form-group row-fluid">', "<label for=\"note-dialog-video-url-".concat(this.options.id, "\" class=\"note-form-label\">").concat(this.lang.video.url, " <small class=\"text-muted\">").concat(this.lang.video.providers, "</small></label>"), "<input id=\"note-dialog-video-url-".concat(this.options.id, "\" class=\"note-video-url form-control note-form-control note-input\" type=\"text\"/>"), '</div>'].join('');
                var buttonClass = 'btn btn-primary note-btn note-btn-primary note-video-btn';
                var footer = "<input type=\"button\" href=\"#\" class=\"".concat(buttonClass, "\" value=\"").concat(this.lang.video.insert, "\" disabled>");
                this.$dialog = this.ui.dialog({
                  title: this.lang.video.insert,
                  fade: this.options.dialogsFade,
                  body: body,
                  footer: footer
                }).render().appendTo($container);
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.ui.hideDialog(this.$dialog);
                this.$dialog.remove();
              }
            }, {
              key: "bindEnterKey",
              value: function bindEnterKey($input, $btn) {
                $input.on('keypress', function (event) {
                  if (event.keyCode === core_key.code.ENTER) {
                    event.preventDefault();
                    $btn.trigger('click');
                  }
                });
              }
            }, {
              key: "createVideoNode",
              value: function createVideoNode(url) {
                // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)
                var ytRegExp = /\/\/(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))([\w|-]{11})(?:(?:[\?&]t=)(\S+))?$/;
                var ytRegExpForStart = /^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/;
                var ytMatch = url.match(ytRegExp);
                var igRegExp = /(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/;
                var igMatch = url.match(igRegExp);
                var vRegExp = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/;
                var vMatch = url.match(vRegExp);
                var vimRegExp = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/;
                var vimMatch = url.match(vimRegExp);
                var dmRegExp = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/;
                var dmMatch = url.match(dmRegExp);
                var youkuRegExp = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/;
                var youkuMatch = url.match(youkuRegExp);
                var qqRegExp = /\/\/v\.qq\.com.*?vid=(.+)/;
                var qqMatch = url.match(qqRegExp);
                var qqRegExp2 = /\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/;
                var qqMatch2 = url.match(qqRegExp2);
                var mp4RegExp = /^.+.(mp4|m4v)$/;
                var mp4Match = url.match(mp4RegExp);
                var oggRegExp = /^.+.(ogg|ogv)$/;
                var oggMatch = url.match(oggRegExp);
                var webmRegExp = /^.+.(webm)$/;
                var webmMatch = url.match(webmRegExp);
                var fbRegExp = /(?:www\.|\/\/)facebook\.com\/([^\/]+)\/videos\/([0-9]+)/;
                var fbMatch = url.match(fbRegExp);
                var $video;

                if (ytMatch && ytMatch[1].length === 11) {
                  var youtubeId = ytMatch[1];
                  var start = 0;

                  if (typeof ytMatch[2] !== 'undefined') {
                    var ytMatchForStart = ytMatch[2].match(ytRegExpForStart);

                    if (ytMatchForStart) {
                      for (var n = [3600, 60, 1], i = 0, r = n.length; i < r; i++) {
                        start += typeof ytMatchForStart[i + 1] !== 'undefined' ? n[i] * parseInt(ytMatchForStart[i + 1], 10) : 0;
                      }
                    }
                  }

                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', '//www.youtube.com/embed/' + youtubeId + (start > 0 ? '?start=' + start : '')).attr('width', '640').attr('height', '360');
                } else if (igMatch && igMatch[0].length) {
                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/').attr('width', '612').attr('height', '710').attr('scrolling', 'no').attr('allowtransparency', 'true');
                } else if (vMatch && vMatch[0].length) {
                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', vMatch[0] + '/embed/simple').attr('width', '600').attr('height', '600').attr('class', 'vine-embed');
                } else if (vimMatch && vimMatch[3].length) {
                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('src', '//player.vimeo.com/video/' + vimMatch[3]).attr('width', '640').attr('height', '360');
                } else if (dmMatch && dmMatch[2].length) {
                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2]).attr('width', '640').attr('height', '360');
                } else if (youkuMatch && youkuMatch[1].length) {
                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('height', '498').attr('width', '510').attr('src', '//player.youku.com/embed/' + youkuMatch[1]);
                } else if (qqMatch && qqMatch[1].length || qqMatch2 && qqMatch2[2].length) {
                  var vid = qqMatch && qqMatch[1].length ? qqMatch[1] : qqMatch2[2];
                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('height', '310').attr('width', '500').attr('src', 'https://v.qq.com/iframe/player.html?vid=' + vid + '&amp;auto=0');
                } else if (mp4Match || oggMatch || webmMatch) {
                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<video controls>').attr('src', url).attr('width', '640').attr('height', '360');
                } else if (fbMatch && fbMatch[0].length) {
                  $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', 'https://www.facebook.com/plugins/video.php?href=' + encodeURIComponent(fbMatch[0]) + '&show_text=0&width=560').attr('width', '560').attr('height', '301').attr('scrolling', 'no').attr('allowtransparency', 'true');
                } else {
                  // this is not a known video link. Now what, Cat? Now what?
                  return false;
                }

                $video.addClass('note-video-clip');
                return $video[0];
              }
            }, {
              key: "show",
              value: function show() {
                var _this = this;

                var text = this.context.invoke('editor.getSelectedText');
                this.context.invoke('editor.saveRange');
                this.showVideoDialog(text).then(function (url) {
                  // [workaround] hide dialog before restore range for IE range focus
                  _this.ui.hideDialog(_this.$dialog);

                  _this.context.invoke('editor.restoreRange'); // build node


                  var $node = _this.createVideoNode(url);

                  if ($node) {
                    // insert video node
                    _this.context.invoke('editor.insertNode', $node);
                  }
                }).fail(function () {
                  _this.context.invoke('editor.restoreRange');
                });
              }
              /**
               * show video dialog
               *
               * @param {jQuery} $dialog
               * @return {Promise}
               */

            }, {
              key: "showVideoDialog",
              value: function showVideoDialog()
              /* text */
              {
                var _this2 = this;

                return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
                  var $videoUrl = _this2.$dialog.find('.note-video-url');

                  var $videoBtn = _this2.$dialog.find('.note-video-btn');

                  _this2.ui.onDialogShown(_this2.$dialog, function () {
                    _this2.context.triggerEvent('dialog.shown');

                    $videoUrl.on('input paste propertychange', function () {
                      _this2.ui.toggleBtn($videoBtn, $videoUrl.val());
                    });

                    if (!env.isSupportTouch) {
                      $videoUrl.trigger('focus');
                    }

                    $videoBtn.click(function (event) {
                      event.preventDefault();
                      deferred.resolve($videoUrl.val());
                    });

                    _this2.bindEnterKey($videoUrl, $videoBtn);
                  });

                  _this2.ui.onDialogHidden(_this2.$dialog, function () {
                    $videoUrl.off();
                    $videoBtn.off();

                    if (deferred.state() === 'pending') {
                      deferred.reject();
                    }
                  });

                  _this2.ui.showDialog(_this2.$dialog);
                });
              }
            }]);

            return VideoDialog;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/HelpDialog.js
          function HelpDialog_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function HelpDialog_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function HelpDialog_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) HelpDialog_defineProperties(Constructor.prototype, protoProps);if (staticProps) HelpDialog_defineProperties(Constructor, staticProps);return Constructor;
          }

          var HelpDialog_HelpDialog =
          /*#__PURE__*/
          function () {
            function HelpDialog(context) {
              HelpDialog_classCallCheck(this, HelpDialog);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.$body = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document.body);
              this.$editor = context.layoutInfo.editor;
              this.options = context.options;
              this.lang = this.options.langInfo;
            }

            HelpDialog_createClass(HelpDialog, [{
              key: "initialize",
              value: function initialize() {
                var $container = this.options.dialogsInBody ? this.$body : this.options.container;
                var body = ['<p class="text-center">', '<a href="http://summernote.org/" target="_blank">Summernote 0.8.16</a>  ', '<a href="https://github.com/summernote/summernote" target="_blank">Project</a>  ', '<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>', '</p>'].join('');
                this.$dialog = this.ui.dialog({
                  title: this.lang.options.help,
                  fade: this.options.dialogsFade,
                  body: this.createShortcutList(),
                  footer: body,
                  callback: function callback($node) {
                    $node.find('.modal-body,.note-modal-body').css({
                      'max-height': 300,
                      'overflow': 'scroll'
                    });
                  }
                }).render().appendTo($container);
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.ui.hideDialog(this.$dialog);
                this.$dialog.remove();
              }
            }, {
              key: "createShortcutList",
              value: function createShortcutList() {
                var _this = this;

                var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
                return Object.keys(keyMap).map(function (key) {
                  var command = keyMap[key];
                  var $row = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div><div class="help-list-item"/></div>');
                  $row.append(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<label><kbd>' + key + '</kdb></label>').css({
                    'width': 180,
                    'margin-right': 10
                  })).append(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<span/>').html(_this.context.memo('help.' + command) || command));
                  return $row.html();
                }).join('');
              }
              /**
               * show help dialog
               *
               * @return {Promise}
               */

            }, {
              key: "showHelpDialog",
              value: function showHelpDialog() {
                var _this2 = this;

                return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
                  _this2.ui.onDialogShown(_this2.$dialog, function () {
                    _this2.context.triggerEvent('dialog.shown');

                    deferred.resolve();
                  });

                  _this2.ui.showDialog(_this2.$dialog);
                }).promise();
              }
            }, {
              key: "show",
              value: function show() {
                var _this3 = this;

                this.context.invoke('editor.saveRange');
                this.showHelpDialog().then(function () {
                  _this3.context.invoke('editor.restoreRange');
                });
              }
            }]);

            return HelpDialog;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/AirPopover.js
          function AirPopover_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function AirPopover_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function AirPopover_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) AirPopover_defineProperties(Constructor.prototype, protoProps);if (staticProps) AirPopover_defineProperties(Constructor, staticProps);return Constructor;
          }

          var AIRMODE_POPOVER_X_OFFSET = -5;
          var AIRMODE_POPOVER_Y_OFFSET = 5;

          var AirPopover_AirPopover =
          /*#__PURE__*/
          function () {
            function AirPopover(context) {
              var _this = this;

              AirPopover_classCallCheck(this, AirPopover);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.options = context.options;
              this.hidable = true;
              this.onContextmenu = false;
              this.pageX = null;
              this.pageY = null;
              this.events = {
                'summernote.contextmenu': function summernoteContextmenu(e) {
                  if (_this.options.editing) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.onContextmenu = true;

                    _this.update(true);
                  }
                },
                'summernote.mousedown': function summernoteMousedown(we, e) {
                  _this.pageX = e.pageX;
                  _this.pageY = e.pageY;
                },
                'summernote.keyup summernote.mouseup summernote.scroll': function summernoteKeyupSummernoteMouseupSummernoteScroll(we, e) {
                  if (_this.options.editing && !_this.onContextmenu) {
                    _this.pageX = e.pageX;
                    _this.pageY = e.pageY;

                    _this.update();
                  }

                  _this.onContextmenu = false;
                },
                'summernote.disable summernote.change summernote.dialog.shown summernote.blur': function summernoteDisableSummernoteChangeSummernoteDialogShownSummernoteBlur() {
                  _this.hide();
                },
                'summernote.focusout': function summernoteFocusout() {
                  if (!_this.$popover.is(':active,:focus')) {
                    _this.hide();
                  }
                }
              };
            }

            AirPopover_createClass(AirPopover, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return this.options.airMode && !lists.isEmpty(this.options.popover.air);
              }
            }, {
              key: "initialize",
              value: function initialize() {
                var _this2 = this;

                this.$popover = this.ui.popover({
                  className: 'note-air-popover'
                }).render().appendTo(this.options.container);
                var $content = this.$popover.find('.popover-content');
                this.context.invoke('buttons.build', $content, this.options.popover.air); // disable hiding this popover preemptively by 'summernote.blur' event.

                this.$popover.on('mousedown', function () {
                  _this2.hidable = false;
                }); // (re-)enable hiding after 'summernote.blur' has been handled (aka. ignored).

                this.$popover.on('mouseup', function () {
                  _this2.hidable = true;
                });
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$popover.remove();
              }
            }, {
              key: "update",
              value: function update(forcelyOpen) {
                var styleInfo = this.context.invoke('editor.currentStyle');

                if (styleInfo.range && (!styleInfo.range.isCollapsed() || forcelyOpen)) {
                  var rect = {
                    left: this.pageX,
                    top: this.pageY
                  };
                  var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();
                  rect.top -= containerOffset.top;
                  rect.left -= containerOffset.left;
                  this.$popover.css({
                    display: 'block',
                    left: Math.max(rect.left, 0) + AIRMODE_POPOVER_X_OFFSET,
                    top: rect.top + AIRMODE_POPOVER_Y_OFFSET
                  });
                  this.context.invoke('buttons.updateCurrentStyle', this.$popover);
                } else {
                  this.hide();
                }
              }
            }, {
              key: "hide",
              value: function hide() {
                if (this.hidable) {
                  this.$popover.hide();
                }
              }
            }]);

            return AirPopover;
          }();

          // CONCATENATED MODULE: ./src/js/base/module/HintPopover.js
          function HintPopover_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function HintPopover_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function HintPopover_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) HintPopover_defineProperties(Constructor.prototype, protoProps);if (staticProps) HintPopover_defineProperties(Constructor, staticProps);return Constructor;
          }

          var POPOVER_DIST = 5;

          var HintPopover_HintPopover =
          /*#__PURE__*/
          function () {
            function HintPopover(context) {
              var _this = this;

              HintPopover_classCallCheck(this, HintPopover);

              this.context = context;
              this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
              this.$editable = context.layoutInfo.editable;
              this.options = context.options;
              this.hint = this.options.hint || [];
              this.direction = this.options.hintDirection || 'bottom';
              this.hints = Array.isArray(this.hint) ? this.hint : [this.hint];
              this.events = {
                'summernote.keyup': function summernoteKeyup(we, e) {
                  if (!e.isDefaultPrevented()) {
                    _this.handleKeyup(e);
                  }
                },
                'summernote.keydown': function summernoteKeydown(we, e) {
                  _this.handleKeydown(e);
                },
                'summernote.disable summernote.dialog.shown summernote.blur': function summernoteDisableSummernoteDialogShownSummernoteBlur() {
                  _this.hide();
                }
              };
            }

            HintPopover_createClass(HintPopover, [{
              key: "shouldInitialize",
              value: function shouldInitialize() {
                return this.hints.length > 0;
              }
            }, {
              key: "initialize",
              value: function initialize() {
                var _this2 = this;

                this.lastWordRange = null;
                this.matchingWord = null;
                this.$popover = this.ui.popover({
                  className: 'note-hint-popover',
                  hideArrow: true,
                  direction: ''
                }).render().appendTo(this.options.container);
                this.$popover.hide();
                this.$content = this.$popover.find('.popover-content,.note-popover-content');
                this.$content.on('click', '.note-hint-item', function (e) {
                  _this2.$content.find('.active').removeClass('active');

                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(e.currentTarget).addClass('active');

                  _this2.replace();
                });
                this.$popover.on('mousedown', function (e) {
                  e.preventDefault();
                });
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.$popover.remove();
              }
            }, {
              key: "selectItem",
              value: function selectItem($item) {
                this.$content.find('.active').removeClass('active');
                $item.addClass('active');
                this.$content[0].scrollTop = $item[0].offsetTop - this.$content.innerHeight() / 2;
              }
            }, {
              key: "moveDown",
              value: function moveDown() {
                var $current = this.$content.find('.note-hint-item.active');
                var $next = $current.next();

                if ($next.length) {
                  this.selectItem($next);
                } else {
                  var $nextGroup = $current.parent().next();

                  if (!$nextGroup.length) {
                    $nextGroup = this.$content.find('.note-hint-group').first();
                  }

                  this.selectItem($nextGroup.find('.note-hint-item').first());
                }
              }
            }, {
              key: "moveUp",
              value: function moveUp() {
                var $current = this.$content.find('.note-hint-item.active');
                var $prev = $current.prev();

                if ($prev.length) {
                  this.selectItem($prev);
                } else {
                  var $prevGroup = $current.parent().prev();

                  if (!$prevGroup.length) {
                    $prevGroup = this.$content.find('.note-hint-group').last();
                  }

                  this.selectItem($prevGroup.find('.note-hint-item').last());
                }
              }
            }, {
              key: "replace",
              value: function replace() {
                var $item = this.$content.find('.note-hint-item.active');

                if ($item.length) {
                  var node = this.nodeFromItem($item); // If matchingWord length = 0 -> capture OK / open hint / but as mention capture "" (\w*)

                  if (this.matchingWord !== null && this.matchingWord.length === 0) {
                    this.lastWordRange.so = this.lastWordRange.eo; // Else si > 0 and normal case -> adjust range "before" for correct position of insertion
                  } else if (this.matchingWord !== null && this.matchingWord.length > 0 && !this.lastWordRange.isCollapsed()) {
                    var rangeCompute = this.lastWordRange.eo - this.lastWordRange.so - this.matchingWord.length;

                    if (rangeCompute > 0) {
                      this.lastWordRange.so += rangeCompute;
                    }
                  }

                  this.lastWordRange.insertNode(node);

                  if (this.options.hintSelect === 'next') {
                    var blank = document.createTextNode('');
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).after(blank);
                    range.createFromNodeBefore(blank).select();
                  } else {
                    range.createFromNodeAfter(node).select();
                  }

                  this.lastWordRange = null;
                  this.hide();
                  this.context.invoke('editor.focus');
                }
              }
            }, {
              key: "nodeFromItem",
              value: function nodeFromItem($item) {
                var hint = this.hints[$item.data('index')];
                var item = $item.data('item');
                var node = hint.content ? hint.content(item) : item;

                if (typeof node === 'string') {
                  node = dom.createText(node);
                }

                return node;
              }
            }, {
              key: "createItemTemplates",
              value: function createItemTemplates(hintIdx, items) {
                var hint = this.hints[hintIdx];
                return items.map(function (item
                /*, idx */
                ) {
                  var $item = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div class="note-hint-item"/>');
                  $item.append(hint.template ? hint.template(item) : item + '');
                  $item.data({
                    'index': hintIdx,
                    'item': item
                  });
                  return $item;
                });
              }
            }, {
              key: "handleKeydown",
              value: function handleKeydown(e) {
                if (!this.$popover.is(':visible')) {
                  return;
                }

                if (e.keyCode === core_key.code.ENTER) {
                  e.preventDefault();
                  this.replace();
                } else if (e.keyCode === core_key.code.UP) {
                  e.preventDefault();
                  this.moveUp();
                } else if (e.keyCode === core_key.code.DOWN) {
                  e.preventDefault();
                  this.moveDown();
                }
              }
            }, {
              key: "searchKeyword",
              value: function searchKeyword(index, keyword, callback) {
                var hint = this.hints[index];

                if (hint && hint.match.test(keyword) && hint.search) {
                  var matches = hint.match.exec(keyword);
                  this.matchingWord = matches[0];
                  hint.search(matches[1], callback);
                } else {
                  callback();
                }
              }
            }, {
              key: "createGroup",
              value: function createGroup(idx, keyword) {
                var _this3 = this;

                var $group = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div class="note-hint-group note-hint-group-' + idx + '"/>');
                this.searchKeyword(idx, keyword, function (items) {
                  items = items || [];

                  if (items.length) {
                    $group.html(_this3.createItemTemplates(idx, items));

                    _this3.show();
                  }
                });
                return $group;
              }
            }, {
              key: "handleKeyup",
              value: function handleKeyup(e) {
                var _this4 = this;

                if (!lists.contains([core_key.code.ENTER, core_key.code.UP, core_key.code.DOWN], e.keyCode)) {
                  var _range = this.context.invoke('editor.getLastRange');

                  var wordRange, keyword;

                  if (this.options.hintMode === 'words') {
                    wordRange = _range.getWordsRange(_range);
                    keyword = wordRange.toString();
                    this.hints.forEach(function (hint) {
                      if (hint.match.test(keyword)) {
                        wordRange = _range.getWordsMatchRange(hint.match);
                        return false;
                      }
                    });

                    if (!wordRange) {
                      this.hide();
                      return;
                    }

                    keyword = wordRange.toString();
                  } else {
                    wordRange = _range.getWordRange();
                    keyword = wordRange.toString();
                  }

                  if (this.hints.length && keyword) {
                    this.$content.empty();
                    var bnd = func.rect2bnd(lists.last(wordRange.getClientRects()));
                    var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();

                    if (bnd) {
                      bnd.top -= containerOffset.top;
                      bnd.left -= containerOffset.left;
                      this.$popover.hide();
                      this.lastWordRange = wordRange;
                      this.hints.forEach(function (hint, idx) {
                        if (hint.match.test(keyword)) {
                          _this4.createGroup(idx, keyword).appendTo(_this4.$content);
                        }
                      }); // select first .note-hint-item

                      this.$content.find('.note-hint-item:first').addClass('active'); // set position for popover after group is created

                      if (this.direction === 'top') {
                        this.$popover.css({
                          left: bnd.left,
                          top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST
                        });
                      } else {
                        this.$popover.css({
                          left: bnd.left,
                          top: bnd.top + bnd.height + POPOVER_DIST
                        });
                      }
                    }
                  } else {
                    this.hide();
                  }
                }
              }
            }, {
              key: "show",
              value: function show() {
                this.$popover.show();
              }
            }, {
              key: "hide",
              value: function hide() {
                this.$popover.hide();
              }
            }]);

            return HintPopover;
          }();

          // CONCATENATED MODULE: ./src/js/base/settings.js


          external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote, {
            version: '0.8.16',
            plugins: {},
            dom: dom,
            range: range,
            lists: lists,
            options: {
              langInfo: external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.lang['en-US'],
              editing: true,
              modules: {
                'editor': Editor_Editor,
                'clipboard': Clipboard_Clipboard,
                'dropzone': Dropzone_Dropzone,
                'codeview': Codeview_CodeView,
                'statusbar': Statusbar_Statusbar,
                'fullscreen': Fullscreen_Fullscreen,
                'handle': Handle_Handle,
                // FIXME: HintPopover must be front of autolink
                //  - Script error about range when Enter key is pressed on hint popover
                'hintPopover': HintPopover_HintPopover,
                'autoLink': AutoLink_AutoLink,
                'autoSync': AutoSync_AutoSync,
                'autoReplace': AutoReplace_AutoReplace,
                'placeholder': Placeholder_Placeholder,
                'buttons': Buttons_Buttons,
                'toolbar': Toolbar_Toolbar,
                'linkDialog': LinkDialog_LinkDialog,
                'linkPopover': LinkPopover_LinkPopover,
                'imageDialog': ImageDialog_ImageDialog,
                'imagePopover': ImagePopover_ImagePopover,
                'tablePopover': TablePopover_TablePopover,
                'videoDialog': VideoDialog_VideoDialog,
                'helpDialog': HelpDialog_HelpDialog,
                'airPopover': AirPopover_AirPopover
              },
              buttons: {},
              lang: 'en-US',
              followingToolbar: false,
              toolbarPosition: 'top',
              otherStaticBar: '',
              // toolbar
              toolbar: [['style', ['style']], ['font', ['bold', 'underline', 'clear']], ['fontname', ['fontname']], ['color', ['color']], ['para', ['ul', 'ol', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture', 'video']], ['view', ['fullscreen', 'codeview', 'help']]],
              // popover
              popatmouse: true,
              popover: {
                image: [['resize', ['resizeFull', 'resizeHalf', 'resizeQuarter', 'resizeNone']], ['float', ['floatLeft', 'floatRight', 'floatNone']], ['remove', ['removeMedia']]],
                link: [['link', ['linkDialogShow', 'unlink']]],
                table: [['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']], ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]],
                air: [['color', ['color']], ['font', ['bold', 'underline', 'clear']], ['para', ['ul', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture']], ['view', ['fullscreen', 'codeview']]]
              },
              // air mode: inline editor
              airMode: false,
              overrideContextMenu: false,
              // TBD
              width: null,
              height: null,
              linkTargetBlank: true,
              useProtocol: true,
              defaultProtocol: 'http://',
              focus: false,
              tabDisabled: false,
              tabSize: 4,
              styleWithCSS: false,
              shortcuts: true,
              textareaAutoSync: true,
              tooltip: 'auto',
              container: null,
              maxTextLength: 0,
              blockquoteBreakingLevel: 2,
              spellCheck: true,
              disableGrammar: false,
              placeholder: null,
              inheritPlaceholder: false,
              // TODO: need to be documented
              recordEveryKeystroke: false,
              historyLimit: 200,
              // TODO: need to be documented
              hintMode: 'word',
              hintSelect: 'after',
              hintDirection: 'bottom',
              styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
              fontNames: ['Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande', 'Tahoma', 'Times New Roman', 'Verdana'],
              fontNamesIgnoreCheck: [],
              addDefaultFonts: true,
              fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],
              fontSizeUnits: ['px', 'pt'],
              // pallete colors(n x n)
              colors: [['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'], ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'], ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'], ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'], ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'], ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'], ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'], ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']],
              // http://chir.ag/projects/name-that-color/
              colorsName: [['Black', 'Tundora', 'Dove Gray', 'Star Dust', 'Pale Slate', 'Gallery', 'Alabaster', 'White'], ['Red', 'Orange Peel', 'Yellow', 'Green', 'Cyan', 'Blue', 'Electric Violet', 'Magenta'], ['Azalea', 'Karry', 'Egg White', 'Zanah', 'Botticelli', 'Tropical Blue', 'Mischka', 'Twilight'], ['Tonys Pink', 'Peach Orange', 'Cream Brulee', 'Sprout', 'Casper', 'Perano', 'Cold Purple', 'Careys Pink'], ['Mandy', 'Rajah', 'Dandelion', 'Olivine', 'Gulf Stream', 'Viking', 'Blue Marguerite', 'Puce'], ['Guardsman Red', 'Fire Bush', 'Golden Dream', 'Chelsea Cucumber', 'Smalt Blue', 'Boston Blue', 'Butterfly Bush', 'Cadillac'], ['Sangria', 'Mai Tai', 'Buddha Gold', 'Forest Green', 'Eden', 'Venice Blue', 'Meteorite', 'Claret'], ['Rosewood', 'Cinnamon', 'Olive', 'Parsley', 'Tiber', 'Midnight Blue', 'Valentino', 'Loulou']],
              colorButton: {
                foreColor: '#000000',
                backColor: '#FFFF00'
              },
              lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],
              tableClassName: 'table table-bordered',
              insertTableMaxSize: {
                col: 10,
                row: 10
              },
              // By default, dialogs are attached in container.
              dialogsInBody: false,
              dialogsFade: false,
              maximumImageFileSize: null,
              callbacks: {
                onBeforeCommand: null,
                onBlur: null,
                onBlurCodeview: null,
                onChange: null,
                onChangeCodeview: null,
                onDialogShown: null,
                onEnter: null,
                onFocus: null,
                onImageLinkInsert: null,
                onImageUpload: null,
                onImageUploadError: null,
                onInit: null,
                onKeydown: null,
                onKeyup: null,
                onMousedown: null,
                onMouseup: null,
                onPaste: null,
                onScroll: null
              },
              codemirror: {
                mode: 'text/html',
                htmlMode: true,
                lineNumbers: true
              },
              codeviewFilter: false,
              codeviewFilterRegex: /<\/*(?:applet|b(?:ase|gsound|link)|embed|frame(?:set)?|ilayer|l(?:ayer|ink)|meta|object|s(?:cript|tyle)|t(?:itle|extarea)|xml)[^>]*?>/gi,
              codeviewIframeFilter: true,
              codeviewIframeWhitelistSrc: [],
              codeviewIframeWhitelistSrcBase: ['www.youtube.com', 'www.youtube-nocookie.com', 'www.facebook.com', 'vine.co', 'instagram.com', 'player.vimeo.com', 'www.dailymotion.com', 'player.youku.com', 'v.qq.com'],
              keyMap: {
                pc: {
                  'ENTER': 'insertParagraph',
                  'CTRL+Z': 'undo',
                  'CTRL+Y': 'redo',
                  'TAB': 'tab',
                  'SHIFT+TAB': 'untab',
                  'CTRL+B': 'bold',
                  'CTRL+I': 'italic',
                  'CTRL+U': 'underline',
                  'CTRL+SHIFT+S': 'strikethrough',
                  'CTRL+BACKSLASH': 'removeFormat',
                  'CTRL+SHIFT+L': 'justifyLeft',
                  'CTRL+SHIFT+E': 'justifyCenter',
                  'CTRL+SHIFT+R': 'justifyRight',
                  'CTRL+SHIFT+J': 'justifyFull',
                  'CTRL+SHIFT+NUM7': 'insertUnorderedList',
                  'CTRL+SHIFT+NUM8': 'insertOrderedList',
                  'CTRL+LEFTBRACKET': 'outdent',
                  'CTRL+RIGHTBRACKET': 'indent',
                  'CTRL+NUM0': 'formatPara',
                  'CTRL+NUM1': 'formatH1',
                  'CTRL+NUM2': 'formatH2',
                  'CTRL+NUM3': 'formatH3',
                  'CTRL+NUM4': 'formatH4',
                  'CTRL+NUM5': 'formatH5',
                  'CTRL+NUM6': 'formatH6',
                  'CTRL+ENTER': 'insertHorizontalRule',
                  'CTRL+K': 'linkDialog.show'
                },
                mac: {
                  'ENTER': 'insertParagraph',
                  'CMD+Z': 'undo',
                  'CMD+SHIFT+Z': 'redo',
                  'TAB': 'tab',
                  'SHIFT+TAB': 'untab',
                  'CMD+B': 'bold',
                  'CMD+I': 'italic',
                  'CMD+U': 'underline',
                  'CMD+SHIFT+S': 'strikethrough',
                  'CMD+BACKSLASH': 'removeFormat',
                  'CMD+SHIFT+L': 'justifyLeft',
                  'CMD+SHIFT+E': 'justifyCenter',
                  'CMD+SHIFT+R': 'justifyRight',
                  'CMD+SHIFT+J': 'justifyFull',
                  'CMD+SHIFT+NUM7': 'insertUnorderedList',
                  'CMD+SHIFT+NUM8': 'insertOrderedList',
                  'CMD+LEFTBRACKET': 'outdent',
                  'CMD+RIGHTBRACKET': 'indent',
                  'CMD+NUM0': 'formatPara',
                  'CMD+NUM1': 'formatH1',
                  'CMD+NUM2': 'formatH2',
                  'CMD+NUM3': 'formatH3',
                  'CMD+NUM4': 'formatH4',
                  'CMD+NUM5': 'formatH5',
                  'CMD+NUM6': 'formatH6',
                  'CMD+ENTER': 'insertHorizontalRule',
                  'CMD+K': 'linkDialog.show'
                }
              },
              icons: {
                'align': 'note-icon-align',
                'alignCenter': 'note-icon-align-center',
                'alignJustify': 'note-icon-align-justify',
                'alignLeft': 'note-icon-align-left',
                'alignRight': 'note-icon-align-right',
                'rowBelow': 'note-icon-row-below',
                'colBefore': 'note-icon-col-before',
                'colAfter': 'note-icon-col-after',
                'rowAbove': 'note-icon-row-above',
                'rowRemove': 'note-icon-row-remove',
                'colRemove': 'note-icon-col-remove',
                'indent': 'note-icon-align-indent',
                'outdent': 'note-icon-align-outdent',
                'arrowsAlt': 'note-icon-arrows-alt',
                'bold': 'note-icon-bold',
                'caret': 'note-icon-caret',
                'circle': 'note-icon-circle',
                'close': 'note-icon-close',
                'code': 'note-icon-code',
                'eraser': 'note-icon-eraser',
                'floatLeft': 'note-icon-float-left',
                'floatRight': 'note-icon-float-right',
                'font': 'note-icon-font',
                'frame': 'note-icon-frame',
                'italic': 'note-icon-italic',
                'link': 'note-icon-link',
                'unlink': 'note-icon-chain-broken',
                'magic': 'note-icon-magic',
                'menuCheck': 'note-icon-menu-check',
                'minus': 'note-icon-minus',
                'orderedlist': 'note-icon-orderedlist',
                'pencil': 'note-icon-pencil',
                'picture': 'note-icon-picture',
                'question': 'note-icon-question',
                'redo': 'note-icon-redo',
                'rollback': 'note-icon-rollback',
                'square': 'note-icon-square',
                'strikethrough': 'note-icon-strikethrough',
                'subscript': 'note-icon-subscript',
                'superscript': 'note-icon-superscript',
                'table': 'note-icon-table',
                'textHeight': 'note-icon-text-height',
                'trash': 'note-icon-trash',
                'underline': 'note-icon-underline',
                'undo': 'note-icon-undo',
                'unorderedlist': 'note-icon-unorderedlist',
                'video': 'note-icon-video'
              }
            }
          });

          /***/
        },

        /***/4:
        /***/function (module, exports, __webpack_require__) {

          // extracted by mini-css-extract-plugin

          /***/},

        /***/52:
        /***/function (module, __webpack_exports__, __webpack_require__) {

          "use strict";

          __webpack_require__.r(__webpack_exports__);

          // EXTERNAL MODULE: external {"root":"jQuery","commonjs2":"jquery","commonjs":"jquery","amd":"jquery"}
          var external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_ = __webpack_require__(0);
          var external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default = /*#__PURE__*/__webpack_require__.n(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_);

          // EXTERNAL MODULE: ./src/js/base/renderer.js
          var renderer = __webpack_require__(1);

          // CONCATENATED MODULE: ./src/js/bs3/ui.js
          function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
            }return _typeof(obj);
          }

          var editor = renderer["a" /* default */].create('<div class="note-editor note-frame panel panel-default"/>');
          var toolbar = renderer["a" /* default */].create('<div class="note-toolbar panel-heading" role="toolbar"></div></div>');
          var editingArea = renderer["a" /* default */].create('<div class="note-editing-area"/>');
          var codable = renderer["a" /* default */].create('<textarea class="note-codable" aria-multiline="true"/>');
          var editable = renderer["a" /* default */].create('<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"/>');
          var statusbar = renderer["a" /* default */].create(['<output class="note-status-output" role="status" aria-live="polite"/>', '<div class="note-statusbar" role="status">', '<div class="note-resizebar" aria-label="Resize">', '<div class="note-icon-bar"/>', '<div class="note-icon-bar"/>', '<div class="note-icon-bar"/>', '</div>', '</div>'].join(''));
          var airEditor = renderer["a" /* default */].create('<div class="note-editor note-airframe"/>');
          var airEditable = renderer["a" /* default */].create(['<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"/>', '<output class="note-status-output" role="status" aria-live="polite"/>'].join(''));
          var buttonGroup = renderer["a" /* default */].create('<div class="note-btn-group btn-group">');
          var dropdown = renderer["a" /* default */].create('<ul class="note-dropdown-menu dropdown-menu">', function ($node, options) {
            var markup = Array.isArray(options.items) ? options.items.map(function (item) {
              var value = typeof item === 'string' ? item : item.value || '';
              var content = options.template ? options.template(item) : item;
              var option = _typeof(item) === 'object' ? item.option : undefined;
              var dataValue = 'data-value="' + value + '"';
              var dataOption = option !== undefined ? ' data-option="' + option + '"' : '';
              return '<li aria-label="' + value + '"><a href="#" ' + (dataValue + dataOption) + '>' + content + '</a></li>';
            }).join('') : options.items;
            $node.html(markup).attr({
              'aria-label': options.title
            });
          });

          var dropdownButtonContents = function dropdownButtonContents(contents, options) {
            return contents + ' ' + icon(options.icons.caret, 'span');
          };

          var dropdownCheck = renderer["a" /* default */].create('<ul class="note-dropdown-menu dropdown-menu note-check">', function ($node, options) {
            var markup = Array.isArray(options.items) ? options.items.map(function (item) {
              var value = typeof item === 'string' ? item : item.value || '';
              var content = options.template ? options.template(item) : item;
              return '<li aria-label="' + item + '"><a href="#" data-value="' + value + '">' + icon(options.checkClassName) + ' ' + content + '</a></li>';
            }).join('') : options.items;
            $node.html(markup).attr({
              'aria-label': options.title
            });
          });
          var dialog = renderer["a" /* default */].create('<div class="modal note-modal" aria-hidden="false" tabindex="-1" role="dialog"/>', function ($node, options) {
            if (options.fade) {
              $node.addClass('fade');
            }

            $node.attr({
              'aria-label': options.title
            });
            $node.html(['<div class="modal-dialog">', '<div class="modal-content">', options.title ? '<div class="modal-header">' + '<button type="button" class="close" data-dismiss="modal" aria-label="Close" aria-hidden="true">&times;</button>' + '<h4 class="modal-title">' + options.title + '</h4>' + '</div>' : '', '<div class="modal-body">' + options.body + '</div>', options.footer ? '<div class="modal-footer">' + options.footer + '</div>' : '', '</div>', '</div>'].join(''));
          });
          var popover = renderer["a" /* default */].create(['<div class="note-popover popover in">', '<div class="arrow"/>', '<div class="popover-content note-children-container"/>', '</div>'].join(''), function ($node, options) {
            var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';
            $node.addClass(direction);

            if (options.hideArrow) {
              $node.find('.arrow').hide();
            }
          });
          var ui_checkbox = renderer["a" /* default */].create('<div class="checkbox"></div>', function ($node, options) {
            $node.html(['<label' + (options.id ? ' for="note-' + options.id + '"' : '') + '>', '<input type="checkbox"' + (options.id ? ' id="note-' + options.id + '"' : ''), options.checked ? ' checked' : '', ' aria-checked="' + (options.checked ? 'true' : 'false') + '"/>', options.text ? options.text : '', '</label>'].join(''));
          });

          var icon = function icon(iconClassName, tagName) {
            tagName = tagName || 'i';
            return '<' + tagName + ' class="' + iconClassName + '"/>';
          };

          var ui_ui = function ui(editorOptions) {
            return {
              editor: editor,
              toolbar: toolbar,
              editingArea: editingArea,
              codable: codable,
              editable: editable,
              statusbar: statusbar,
              airEditor: airEditor,
              airEditable: airEditable,
              buttonGroup: buttonGroup,
              dropdown: dropdown,
              dropdownButtonContents: dropdownButtonContents,
              dropdownCheck: dropdownCheck,
              dialog: dialog,
              popover: popover,
              checkbox: ui_checkbox,
              icon: icon,
              options: editorOptions,
              palette: function palette($node, options) {
                return renderer["a" /* default */].create('<div class="note-color-palette"/>', function ($node, options) {
                  var contents = [];

                  for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {
                    var eventName = options.eventName;
                    var colors = options.colors[row];
                    var colorsName = options.colorsName[row];
                    var buttons = [];

                    for (var col = 0, colSize = colors.length; col < colSize; col++) {
                      var color = colors[col];
                      var colorName = colorsName[col];
                      buttons.push(['<button type="button" class="note-color-btn"', 'style="background-color:', color, '" ', 'data-event="', eventName, '" ', 'data-value="', color, '" ', 'title="', colorName, '" ', 'aria-label="', colorName, '" ', 'data-toggle="button" tabindex="-1"></button>'].join(''));
                    }

                    contents.push('<div class="note-color-row">' + buttons.join('') + '</div>');
                  }

                  $node.html(contents.join(''));

                  if (options.tooltip) {
                    $node.find('.note-color-btn').tooltip({
                      container: options.container || editorOptions.container,
                      trigger: 'hover',
                      placement: 'bottom'
                    });
                  }
                })($node, options);
              },
              button: function button($node, options) {
                return renderer["a" /* default */].create('<button type="button" class="note-btn btn btn-default btn-sm" tabindex="-1">', function ($node, options) {
                  if (options && options.tooltip) {
                    $node.attr({
                      title: options.tooltip,
                      'aria-label': options.tooltip
                    }).tooltip({
                      container: options.container || editorOptions.container,
                      trigger: 'hover',
                      placement: 'bottom'
                    }).on('click', function (e) {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(e.currentTarget).tooltip('hide');
                    });
                  }
                })($node, options);
              },
              toggleBtn: function toggleBtn($btn, isEnable) {
                $btn.toggleClass('disabled', !isEnable);
                $btn.attr('disabled', !isEnable);
              },
              toggleBtnActive: function toggleBtnActive($btn, isActive) {
                $btn.toggleClass('active', isActive);
              },
              onDialogShown: function onDialogShown($dialog, handler) {
                $dialog.one('shown.bs.modal', handler);
              },
              onDialogHidden: function onDialogHidden($dialog, handler) {
                $dialog.one('hidden.bs.modal', handler);
              },
              showDialog: function showDialog($dialog) {
                $dialog.modal('show');
              },
              hideDialog: function hideDialog($dialog) {
                $dialog.modal('hide');
              },
              createLayout: function createLayout($note) {
                var $editor = (editorOptions.airMode ? airEditor([editingArea([codable(), airEditable()])]) : editorOptions.toolbarPosition === 'bottom' ? editor([editingArea([codable(), editable()]), toolbar(), statusbar()]) : editor([toolbar(), editingArea([codable(), editable()]), statusbar()])).render();
                $editor.insertAfter($note);
                return {
                  note: $note,
                  editor: $editor,
                  toolbar: $editor.find('.note-toolbar'),
                  editingArea: $editor.find('.note-editing-area'),
                  editable: $editor.find('.note-editable'),
                  codable: $editor.find('.note-codable'),
                  statusbar: $editor.find('.note-statusbar')
                };
              },
              removeLayout: function removeLayout($note, layoutInfo) {
                $note.html(layoutInfo.editable.html());
                layoutInfo.editor.remove();
                $note.show();
              }
            };
          };

          /* harmony default export */var bs3_ui = ui_ui;
          // EXTERNAL MODULE: ./src/js/base/settings.js + 37 modules
          var settings = __webpack_require__(3);

          // EXTERNAL MODULE: ./src/styles/summernote-bs3.scss
          var summernote_bs3 = __webpack_require__(4);

          // CONCATENATED MODULE: ./src/js/bs3/settings.js


          external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote, {
            ui_template: bs3_ui,
            "interface": 'bs3'
          });

          /***/
        }

        /******/ })
    );
  });
  
});
(function() {
var define = $__System.amdDefine;
define("86", ["85"], function(main) {
  return main;
});

})();
(function() {
var define = $__System.amdDefine;
(function(factory) {
  if (typeof define === 'function' && define.amd) {
    define("87", ["28"], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(require('jquery'));
  } else {
    factory(window.jQuery);
  }
}(function($) {
  var FileDialog = function(context) {
    var self = this;
    var ui = $.summernote.ui;
    var $editor = context.layoutInfo.editor;
    var options = context.options;
    var lang = options.langInfo;
    var callbacks = options.callbacks;
    context.memo('button.file', function() {
      return ui.button({
        contents: '<i class="fa fa-paperclip" />',
        tooltip: lang.file.insert,
        click: context.createInvokeHandler('fileDialog.show')
      }).render();
    });
    this.initialize = function() {
      var $container = options.dialogsInBody ? $(document.body) : $editor;
      var fileType = localStorage.getItem('fileType');
      var footer = '<button href="#" class="btn btn-primary note-file-btn">' + lang.file.insert + '</button>';
      var body = '<div class="form-group note-group-select-from-files">' + '<label>' + lang.file.selectFromFiles + '</label>' + '<input class="note-file-input form-control" type="file" name="files" multiple="multiple" />' + '</div>' + '<div class="form-group" style="overflow:auto;">' + '<label>' + lang.file.text + '</label>' + '<input class="note-file-text form-control col-md-12" type="text" />' + '</div>' + `<div class="form-check">
                                <input class="form-check-input" type="radio" name="fileType" id="fileType1" value="webrtc" ${fileType === 'webrtc' ? 'checked' : ''}>
                                <label class="form-check-label" for="fileType1">
                                Base64 embedded (durability depends on hosting method) NOTE: Use only for small files! Can be encrypted.
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="fileType" id="fileType2" value="ipfs" ${fileType === 'ipfs' || !fileType ? 'checked' : ''}>
                                <label class="form-check-label" for="fileType2">
                                IPFS: Distributed file system (rather permanent) NOTE: Can not be encrypted.
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="fileType" id="fileType3" value="webtorrent" ${fileType === 'webtorrent' ? 'checked' : ''}>
                                <label class="form-check-label" for="fileType3">
                                WebTorrent: Peer to peer file sharing (transitory) NOTE: Can not be encrypted.
                            </label>
                            </div>`;
      this.$dialog = ui.dialog({
        title: lang.file.insert,
        fade: options.dialogsFade,
        body: body,
        footer: footer
      }).render().appendTo($container);
    };
    this.show = function() {
      context.invoke('editor.saveRange');
      this.showFileDialog().then(function(files, text) {
        ui.hideDialog(self.$dialog);
        context.invoke('editor.restoreRange');
        if (callbacks.onFileUpload) {
          context.triggerEvent('file.upload', files, text);
        } else {
          console.log('onFileUpload not defined');
        }
      }).fail(function() {
        context.invoke('editor.restoreRange');
      });
    };
    this.showFileDialog = function() {
      return $.Deferred(function(deferred) {
        var $fileInput = self.$dialog.find('.note-file-input'),
            $fileText = self.$dialog.find('.note-file-text'),
            $fileBtn = self.$dialog.find('.note-file-btn');
        ui.onDialogShown(self.$dialog, function() {
          self.$dialog.find('input[name="fileType"]').click(function(event) {
            localStorage.setItem('fileType', self.$dialog.find('input[name="fileType"]:checked').val());
          });
          $fileBtn.click(function(event) {
            event.preventDefault();
            localStorage.setItem('fileType', self.$dialog.find('input[name="fileType"]:checked').val());
            deferred.resolve($fileInput.prop('files') || $fileInput.prop('value'), $fileText.val());
          });
        });
        ui.onDialogHidden(self.$dialog, function() {
          $fileBtn.off('click');
          $fileInput.replaceWith($fileInput.clone().val(''));
          $fileText.replaceWith($fileText.clone().val(''));
          if (deferred.state() === 'pending') {
            deferred.reject();
          }
        });
        ui.showDialog(self.$dialog);
      });
    };
    this.destroy = function() {
      this.$dialog.remove();
      this.$dialog = null;
    };
  };
  $.extend(true, $.summernote, {
    plugins: {fileDialog: FileDialog},
    lang: {'en-US': {file: {
          file: 'File',
          text: 'Link Text',
          insert: 'Insert File',
          selectFromFiles: 'Select from files'
        }}},
    options: {callbacks: {onFileUpload: null}}
  });
}));

})();
(function() {
var define = $__System.amdDefine;
(function(global, factory) {
  "use strict";
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  "use strict";
  var arr = [];
  var document = window.document;
  var getProto = Object.getPrototypeOf;
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};
  var isFunction = function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  };
  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };
  var preservedScriptAttributes = {
    type: true,
    src: true,
    noModule: true
  };
  function DOMEval(code, doc, node) {
    doc = doc || document;
    var i,
        script = doc.createElement("script");
    script.text = code;
    if (node) {
      for (i in preservedScriptAttributes) {
        if (node[i]) {
          script[i] = node[i];
        }
      }
    }
    doc.head.appendChild(script).parentNode.removeChild(script);
  }
  function toType(obj) {
    if (obj == null) {
      return obj + "";
    }
    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
  }
  var version = "3.3.1",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      if (num == null) {
        return slice.call(this);
      }
      return num < 0 ? this[num + this.length] : this[num];
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      return ret;
    },
    each: function(callback) {
      return jQuery.each(this, callback);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isPlainObject: function(obj) {
      var proto,
          Ctor;
      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }
      proto = getProto(obj);
      if (!proto) {
        return true;
      }
      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    globalEval: function(code) {
      DOMEval(code);
    },
    each: function(obj, callback) {
      var length,
          i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);
    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        },
        unloadHandler = function() {
          setDocument();
        },
        disabledAncestor = addCombinator(function(elem) {
          return elem.disabled === true && ("form" in elem || "label" in elem);
        }, {
          dir: "parentNode",
          next: "legend"
        });
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", (nid = expando));
              }
              groups = tokenize(selector);
              i = groups.length;
              while (i--) {
                groups[i] = "#" + nid + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var el = document.createElement("fieldset");
      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        el = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createDisabledPseudo(disabled) {
      return function(elem) {
        if ("form" in elem) {
          if (elem.parentNode && elem.disabled === false) {
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
          }
          return elem.disabled === disabled;
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        }
        return false;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false);
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function(el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function(el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);
            if (elem) {
              node = elem.getAttributeNode("id");
              if (node && node.value === id) {
                return [elem];
              }
              elems = context.getElementsByName(id);
              i = 0;
              while ((elem = elems[i++])) {
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [elem];
                }
              }
            }
            return [];
          }
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        assert(function(el) {
          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");
          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(el) {
          support.disconnectedMatch = matches.call(el, "*");
          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.escape = function(sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      } : function(elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                uniqueCache[key] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context === document || context || outermost;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(el) {
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    });
    if (!assert(function(el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;
  var dir = function(elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var siblings = function(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = jQuery.expr.match.needsContext;
  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }
  ;
  var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);
  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function(elem) {
        return (indexOf.call(qualifier, elem) > -1) !== not;
      });
    }
    return jQuery.filter(qualifier, elements, not);
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }
    return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          ret,
          len = this.length,
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      ret = this.pushStack([]);
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function(selector, context, root) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors);
      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return siblings(elem.firstChild);
    },
    contents: function(elem) {
      if (nodeName(elem, "iframe")) {
        return elem.contentDocument;
      }
      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }
      return jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var firing,
        memory,
        fired,
        locked,
        list = [],
        queue = [],
        firingIndex = -1,
        fire = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  function Identity(v) {
    return v;
  }
  function Thrower(ex) {
    throw ex;
  }
  function adoptValue(value, resolve, reject, noValue) {
    var method;
    try {
      if (value && isFunction((method = value.promise))) {
        method.call(value).done(resolve).fail(reject);
      } else if (value && isFunction((method = value.then))) {
        method.call(value, resolve, reject);
      } else {
        resolve.apply(undefined, [value].slice(noValue));
      }
    } catch (value) {
      reject.apply(undefined, [value]);
    }
  }
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred, handler, special) {
                return function() {
                  var that = this,
                      args = arguments,
                      mightThrow = function() {
                        var returned,
                            then;
                        if (depth < maxDepth) {
                          return;
                        }
                        returned = handler.apply(that, args);
                        if (returned === deferred.promise()) {
                          throw new TypeError("Thenable self-resolution");
                        }
                        then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                        if (isFunction(then)) {
                          if (special) {
                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                          } else {
                            maxDepth++;
                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                          }
                        } else {
                          if (handler !== Identity) {
                            that = undefined;
                            args = [returned];
                          }
                          (special || deferred.resolveWith)(that, args);
                        }
                      },
                      process = special ? mightThrow : function() {
                        try {
                          mightThrow();
                        } catch (e) {
                          if (jQuery.Deferred.exceptionHook) {
                            jQuery.Deferred.exceptionHook(e, process.stackTrace);
                          }
                          if (depth + 1 >= maxDepth) {
                            if (handler !== Thrower) {
                              that = undefined;
                              args = [e];
                            }
                            deferred.rejectWith(that, args);
                          }
                        }
                      };
                  if (depth) {
                    process();
                  } else {
                    if (jQuery.Deferred.getStackHook) {
                      process.stackTrace = jQuery.Deferred.getStackHook();
                    }
                    window.setTimeout(process);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[5];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
        }
        list.add(tuple[3].fire);
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(singleValue) {
      var remaining = arguments.length,
          i = remaining,
          resolveContexts = Array(i),
          resolveValues = slice.call(arguments),
          master = jQuery.Deferred(),
          updateFunc = function(i) {
            return function(value) {
              resolveContexts[i] = this;
              resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!(--remaining)) {
                master.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
      if (remaining <= 1) {
        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
        if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return master.then();
        }
      }
      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }
      return master.promise();
    }
  });
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  jQuery.Deferred.exceptionHook = function(error, stack) {
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };
  jQuery.readyException = function(error) {
    window.setTimeout(function() {
      throw error;
    });
  };
  var readyList = jQuery.Deferred();
  jQuery.fn.ready = function(fn) {
    readyList.then(fn).catch(function(error) {
      jQuery.readyException(error);
    });
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then;
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }
  if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
    window.setTimeout(jQuery.ready);
  } else {
    document.addEventListener("DOMContentLoaded", completed);
    window.addEventListener("load", completed);
  }
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (toType(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    if (chainable) {
      return elems;
    }
    if (bulk) {
      return fn.call(elems);
    }
    return len ? fn(elems[0], key) : emptyGet;
  };
  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g;
  function fcamelCase(all, letter) {
    return letter.toUpperCase();
  }
  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }
  var acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    cache: function(owner) {
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      var prop,
          cache = this.cache(owner);
      if (typeof data === "string") {
        cache[camelCase(data)] = value;
      } else {
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function(owner, key, value) {
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        return this.get(owner, key);
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key !== undefined) {
        if (Array.isArray(key)) {
          key = key.map(camelCase);
        } else {
          key = camelCase(key);
          key = key in cache ? [key] : (key.match(rnothtmlwhite) || []);
        }
        i = key.length;
        while (i--) {
          delete cache[key[i]];
        }
      }
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;
  function getData(data) {
    if (data === "true") {
      return true;
    }
    if (data === "false") {
      return false;
    }
    if (data === "null") {
      return null;
    }
    if (data === +data + "") {
      return +data;
    }
    if (rbrace.test(data)) {
      return JSON.parse(data);
    }
    return data;
  }
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }
      return access(this, function(value) {
        var data;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, key);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function() {
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          dataPriv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHiddenWithinTree = function(elem, el) {
    elem = el || elem;
    return elem.style.display === "none" || elem.style.display === "" && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
  };
  var swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      initial = initial / 2;
      unit = unit || initialInUnit[3];
      initialInUnit = +initial || 1;
      while (maxIterations--) {
        jQuery.style(elem, prop, initialInUnit + unit);
        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }
        initialInUnit = initialInUnit / scale;
      }
      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit);
      valueParts = valueParts || [];
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var defaultDisplayMap = {};
  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];
    if (display) {
      return display;
    }
    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);
    if (display === "none") {
      display = "block";
    }
    defaultDisplayMap[nodeName] = display;
    return display;
  }
  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      display = elem.style.display;
      if (show) {
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;
          if (!values[index]) {
            elem.style.display = "";
          }
        }
        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none";
          dataPriv.set(elem, "display", display);
        }
      }
    }
    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);
  var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret;
    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }
    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }
    return ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (toType(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          jQuery.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while ((elem = nodes[i++])) {
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var documentElement = document.documentElement;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function on(elem, types, selector, data, fn, one) {
    var origFn,
        type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function(nativeEvent) {
      var event = jQuery.event.fix(nativeEvent);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }
            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      }
      cur = this;
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    addProp: function(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function() {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function() {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
      this.target = (src.target && src.target.nodeType === 3) ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || Date.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: function(event) {
      var button = event.button;
      if (event.which == null && rkeyEvent.test(event.type)) {
        return event.charCode != null ? event.charCode : event.keyCode;
      }
      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
        if (button & 1) {
          return 1;
        }
        if (button & 2) {
          return 3;
        }
        if (button & 4) {
          return 2;
        }
        return 0;
      }
      return event.which;
    }
  }, jQuery.event.addProp);
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
      rnoInnerhtml = /<script|<style|<link/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }
    return elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value);
    if (valueIsFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function(selector) {
      return remove(this, selector, true);
    },
    remove: function(selector) {
      return remove(this, selector);
    },
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var ignored = [];
      return domManip(this, arguments, function(elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  var rboxStyle = new RegExp(cssExpand.join("|"), "i");
  (function() {
    function computeStyleTests() {
      if (!div) {
        return;
      }
      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
      div.style.position = "absolute";
      scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
      documentElement.removeChild(container);
      div = null;
    }
    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }
    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function() {
        computeStyleTests();
        return scrollboxSizeVal;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function finalPropName(name) {
    var ret = jQuery.cssProps[name];
    if (!ret) {
      ret = jQuery.cssProps[name] = vendorPropName(name) || name;
    }
    return ret;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0;
    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }
    for (; i < 4; i += 2) {
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      }
      if (!isBorderBox) {
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    if (!isBorderBox && computedVal >= 0) {
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
    }
    return delta;
  }
  function getWidthOrHeight(elem, dimension, extra) {
    var styles = getStyles(elem),
        val = curCSS(elem, dimension, styles),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox;
    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }
      val = "auto";
    }
    valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);
    if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
      val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];
      valueIsBorderBox = true;
    }
    val = parseFloat(val) || 0;
    return (val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val)) + "px";
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style;
      if (!isCustomProp) {
        name = finalPropName(origName);
      }
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name);
      if (!isCustomProp) {
        name = finalPropName(origName);
      }
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function(elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);
        if (isBorderBox && support.scrollboxSize() === styles.position) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        }
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }});
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }
      jQuery.fx.tick();
    }
  }
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = Date.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    propTween = !jQuery.isEmptyObject(props);
    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    }
    if (isBox && elem.nodeType === 1) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      restoreDisplay = dataShow && dataShow.display;
      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }
      display = jQuery.css(elem, "display");
      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      }
      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          if (!propTween) {
            anim.done(function() {
              style.display = restoreDisplay;
            });
            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }
          style.display = "inline-block";
        }
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    propTween = false;
    for (prop in orig) {
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {display: restoreDisplay});
        }
        if (toggle) {
          dataShow.hidden = !hidden;
        }
        if (hidden) {
          showHide([elem], true);
        }
        anim.done(function() {
          if (!hidden) {
            showHide([elem]);
          }
          dataPriv.remove(elem, "fxshow");
          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      }
      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;
        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          }
          if (!length) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {"*": [function(prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]},
    tweener: function(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    };
    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    }
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (inProgress) {
      return;
    }
    inProgress = true;
    schedule();
  };
  jQuery.fx.stop = function() {
    inProgress = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}},
    removeAttr: function(elem, value) {
      var name,
          i = 0,
          attrNames = value && value.match(rnothtmlwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();
      if (!isXML) {
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return (elem[name] = value);
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {tabIndex: {get: function(elem) {
          var tabindex = jQuery.find.attr(elem, "tabindex");
          if (tabindex) {
            return parseInt(tabindex, 10);
          }
          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }
          return -1;
        }}},
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function(elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }
    return [];
  }
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      classes = classesToArray(value);
      if (classes.length) {
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      classes = classesToArray(value);
      if (classes.length) {
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value,
          isValidValue = type === "string" || Array.isArray(value);
      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function() {
        var className,
            i,
            self,
            classNames;
        if (isValidValue) {
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          }
          return ret == null ? "" : ret;
        }
        return;
      }
      valueIsFunction = isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : stripAndCollapse(jQuery.text(elem));
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;
          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          }
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (Array.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  support.focusin = "onfocusin" in window;
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function(e) {
        e.stopPropagation();
      };
  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }
            elem[type]();
            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = Date.now();
  var rquery = (/\?/);
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = (new window.DOMParser()).parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (Array.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, valueOrFunction) {
          var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
    if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        if (val == null) {
          return null;
        }
        if (Array.isArray(val)) {
          return jQuery.map(val, function(val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }
        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
      if (isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": JSON.parse,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          urlAnchor,
          completed,
          fireGlobals,
          i,
          uncached,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (completed) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return completed ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              if (completed == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (completed == null) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (completed) {
                  jqXHR.always(map[jqXHR.status]);
                } else {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR);
      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (completed) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url.replace(rhash, "");
      if (!s.hasContent) {
        uncached = s.url.slice(cacheURL.length);
        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
        }
        s.url = cacheURL + uncached;
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error);
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (completed) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (completed) {
            throw e;
          }
          done(-1, e);
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (completed) {
          return;
        }
        completed = true;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        }
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function(selector) {
      this.parent(selector).not("body").each(function() {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });
  jQuery.expr.pseudos.hidden = function(elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };
  jQuery.expr.pseudos.visible = function(elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
    0: 200,
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback,
        errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          callback = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxPrefilter(function(s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
    contents: {script: /\b(?:java|ecma)script\b/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  support.createHTMLDocument = (function() {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  })();
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    var base,
        parsed,
        scripts;
    if (!context) {
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument("");
        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }
    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  jQuery.fn.load = function(url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    }
    if (isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function(jqXHR, status) {
        self.each(function() {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.pseudos.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (isFunction(options)) {
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var rect,
          win,
          elem = this[0];
      if (!elem) {
        return;
      }
      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      }
      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset();
        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;
        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }
        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win;
        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (isWindow(elem)) {
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }});
  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  jQuery.proxy = function(fn, context) {
    var tmp,
        args,
        proxy;
    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    }
    if (!isFunction(fn)) {
      return undefined;
    }
    args = slice.call(arguments, 2);
    proxy = function() {
      return fn.apply(context || this, args.concat(slice.call(arguments)));
    };
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };
  jQuery.holdReady = function(hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;
  jQuery.isNumeric = function(obj) {
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
  };
  if (typeof define === "function" && define.amd) {
    define("88", [], function() {
      return jQuery;
    }) && define("jquery", ["88"], function(m) {
      return m;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
});

})();
(function() {
var define = $__System.amdDefine;
define("28", ["88"], function(main) {
  return main;
});

})();
(function() {
var define = $__System.amdDefine;
(function(factory) {
  if (typeof define === 'function' && define.amd) {
    define("89", ["28"], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(require('jquery'));
  } else {
    factory(window.jQuery);
  }
}(function($) {
  $.extend(true, $.summernote.lang, {'en-US': {imageShapes: {
        tooltip: 'Image Shapes',
        tooltipShapeOptions: ['Responsive', 'Rounded', 'Circle', 'Thumbnail', 'None']
      }}});
  $.extend($.summernote.options, {imageShapes: {
      icon: '<i class="note-icon-picture"/>',
      shapes: ['img-responsive', 'img-rounded', 'img-circle', 'img-thumbnail', '']
    }});
  $.extend($.summernote.plugins, {'imageShapes': function(context) {
      var ui = $.summernote.ui,
          $editable = context.layoutInfo.editable,
          options = context.options,
          lang = options.langInfo;
      context.memo('button.imageShapes', function() {
        var button = ui.buttonGroup([ui.button({
          className: 'dropdown-toggle',
          contents: options.imageShapes.icon + '&nbsp;&nbsp;<span class="caret"></span>',
          tooltip: lang.imageShapes.tooltip,
          data: {toggle: 'dropdown'}
        }), ui.dropdown({
          className: 'dropdown-shape',
          items: lang.imageShapes.tooltipShapeOptions,
          click: function(e) {
            e.preventDefault();
            var $button = $(e.target);
            var $img = $($editable.data('target'));
            var index = $.inArray($button.data('value'), lang.imageShapes.tooltipShapeOptions);
            $.each(options.imageShapes.shapes, function(index, value) {
              $img.removeClass(value);
            });
            $img.addClass(options.imageShapes.shapes[index]);
            context.invoke('editor.afterCommand');
          }
        })]);
        return button.render();
      });
    }});
}));

})();
$__System.register('8a', ['5', '6', '7', '28', '33', '80', '81', '82', '83', '84', '86', '87', '89', 'a', '2a', '7b', '7c', '7e', '7f'], function (_export) {
	var _get, _inherits, _classCallCheck, $, _Promise, _createClass, _Array$from, MasterEditor, Helper, EditorSummernote;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_5) {
			$ = _5['default'];
		}, function (_4) {
			_Promise = _4['default'];
		}, function (_6) {}, function (_7) {}, function (_8) {}, function (_9) {}, function (_10) {}, function (_11) {}, function (_12) {}, function (_13) {}, function (_a) {
			_createClass = _a['default'];
		}, function (_a2) {
			_Array$from = _a2['default'];
		}, function (_b) {
			MasterEditor = _b.MasterEditor;
		}, function (_c) {
			Helper = _c.Helper;
		}, function (_e) {}, function (_f) {}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			//import 'Editor/Classes/Helper/summernote-insert-paragraph-bug-fix.js'; // would fix it but triggers summernote error, time to find a new wysiwyg or write our own
			//import 'Editor/Classes/Helper/summernote-plugin-image-download.js';

			// summernote uses this icons: https://fontawesome.com/icons [jspm_packages/github/summernote/summernote@0.8.16/summernote-bs4.css]

			EditorSummernote = (function (_MasterEditor) {
				_inherits(EditorSummernote, _MasterEditor);

				function EditorSummernote(WebTorrent, IPFS) {
					var _this = this;

					_classCallCheck(this, EditorSummernote);

					_get(Object.getPrototypeOf(EditorSummernote.prototype), 'constructor', this).call(this);
					this.WebTorrent = WebTorrent;
					this.IPFS = IPFS;
					this.torrentNodeName = 'span';
					this.torrentNodeNameAudioVideo = 'figure';

					this.container = null;
					this.summernote = $.summernote;
					this.Helper = new Helper();
					this.changeEvent = function () {
						console.warn('No ChangeEvent defined!!!');
					};
					this.changeDelay = 1000;
					this.timeout = true;
					this.timeoutCont = null; // used internal when timeout true
					// add css
					this.css = this.Helper.addBaseURL(['jspm_packages/' + System.map['bootstrap'] + '/css/bootstrap.min.css', 'JavaScript/js/Editor/lib/codemirror/codemirror.css', 'JavaScript/js/Editor/lib/codemirror/monokai.css', 'jspm_packages/' + System.map['summernote/summernote'] + '/summernote.css']);
					//`` // ide has some issues here to highlight properly without this line
					this.css.forEach(function (e) {
						$('<link/>', {
							rel: 'stylesheet',
							type: 'text/css',
							href: e
						}).appendTo('head');
					});
					// options
					this.addEmojis();
					this.opts = {
						toolbar: [['insert', ['link', 'codeview' /*, 'picture', 'video'*/]], ['font', ['style', 'fontsize', 'fontname']], ['weight', ['color', 'bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'clear']], ['para', ['height', 'ul', 'ol', 'paragraph', 'table']], ['view', ['undo', 'redo', 'fullscreen', 'help']]],
						// catch drag and drop file
						callbacks: {
							// If no WebTorrent remove the onImageUpload callback and let default handle it
							onImageUpload: function onImageUpload(files, text) {
								if (files.length > 0) _this.loadFileInit(files, text);
							},
							onFileUpload: function onFileUpload(files, text) {
								if (files.length > 0) _this.loadFileInit(files, text, undefined, false);
							},
							onPaste: function onPaste($event) {
								if (localStorage.getItem('fileType') === 'webrtc') return true;
								var clipboardData = ($event.originalEvent || $event).clipboardData;
								var files = []; // files can be received sync and for that straight stored as file obj
								var promises = []; // strings con not be received sync but by callback, for that stored in promises resolving to string
								_Array$from(clipboardData.items).forEach(function (item) {
									if (item.kind === 'file') {
										files.push(item.getAsFile());
									} else if (item.kind === 'string') {
										promises.push(new _Promise(function (resolve) {
											return item.getAsString(function (string) {
												return resolve(string);
											});
										}));
									}
								});
								if (!!files.length) {
									var _ret = (function () {
										var text = files[0].name;
										if (!!promises.length) {
											_Promise.all(promises).then(function (strings) {
												var string = strings.reduce(function (prev, curr) {
													var match = curr.match(/alt="(.*?)"/);
													if (match && match[1]) return prev ? prev += '_' + match[1] : match[1];
													return prev;
												}, '').split('/').splice(-1)[0];
												var mime = _this.Helper.mime.getType(string, null);
												text = mime ? string : string + '_' + text;
												_this.loadFileInit(files, text);
											});
										} else {
											_this.loadFileInit(files, text);
										}
										// remove the default added base64 string
										$event.preventDefault();
										$event.isDefaultPrevented();
										$event.stopPropagation();
										$event.isPropagationStopped();
										$event.stopImmediatePropagation();
										$event.isImmediatePropagationStopped();
										return {
											v: false
										};
									})();

									if (typeof _ret === 'object') return _ret.v;
								}
								return true;
							},
							// trash icon
							onMediaDelete: function onMediaDelete($target, container) {
								// remove element in container
								$target.remove();
								var removeByEvaluate = function removeByEvaluate(nodeName) {
									var nodeList = document.evaluate('//' + nodeName + '[@data-blobs[contains(., \'' + $target[0].src + '\')]]', document, null, XPathResult.ANY_TYPE, null);
									var node = nodeList.iterateNext(); // it is supposed to be empty before deleting
									while (node && node.childNodes.length !== 0) {
										node = nodeList.iterateNext();
										if (node) {
											if (node.nextSibling && node.nextSibling.innerHTML === '') node.nextSibling.remove(); // remove buffer element added at line 176, this is used for setting focus after torrentNode
											node.remove();
										}
									}
								};
								removeByEvaluate(_this.torrentNodeName);
								removeByEvaluate(_this.torrentNodeNameAudioVideo);
							}
						},
						hint: {
							match: /:([\-+\w]+)$/,
							search: function search(keyword, callback) {
								callback($.grep(emojis, function (item) {
									return item.indexOf(keyword) === 0;
								}));
							},
							template: function template(item) {
								var content = emojiUrls[item];
								return '<img src="' + content + '" width="20" /> :' + item + ':';
							},
							content: function content(item) {
								var url = emojiUrls[item];
								if (url) {
									return $('<img />').attr('src', url).css('width', 20)[0];
								}
								return '';
							}
						},
						codemirror: {
							mode: 'htmlmixed',
							htmlMode: true,
							lineNumbers: true,
							theme: 'monokai'
						},
						height: '65vh', /* when adjusting search: height in-code search. to change both values. */
						minHeight: null,
						maxHeight: null,
						focus: false,
						fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36', '48', '64', '82', '150'],
						popover: {
							image: [['image', ['resizeFull', 'resizeHalf', 'resizeQuarter', 'resizeNone']], ['float', ['floatLeft', 'floatRight', 'floatNone']], ['custom', ['imageShapes']], ['remove', ['imageDownload', 'removeMedia']]]
						}
					};
				}

				_createClass(EditorSummernote, [{
					key: 'add',
					value: function add() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						this.container = container;
						container.summernote(this.opts);
						this.addFileDialog(container);
					}
				}, {
					key: 'remove',
					value: function remove() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						container.summernote('destroy');
					}
				}, {
					key: 'getData',
					value: function getData() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];
						var repairHTML = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

						// fix possible html errors before getting the data
						if (repairHTML) this.setData(undefined, container.summernote('code'), 'code');
						return container.summernote('code');
					}
				}, {
					key: 'setData',
					value: function setData() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];
						var data = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
						var type = arguments.length <= 2 || arguments[2] === undefined ? 'insertText' : arguments[2];

						return container.summernote(type, data, type);
					}
				}, {
					key: 'attachChangeEvent',
					value: function attachChangeEvent(container, event) {
						var _this2 = this;

						if (container === undefined) container = this.container;

						this.changeEvent = event;
						container.on('summernote.change', function (we, contents, $editable) {
							if (contents && contents.length > 0) {
								clearTimeout(_this2.timeoutCont);
								_this2.timeoutCont = setTimeout(function () {
									// unseed webTorrents when node.webTorrent deleted
									if (_this2.WebTorrent) {
										if (_this2.WebTorrent.api.removeDeletedNodes().length > 0 && !_this2.WebTorrent.api.areTorrentsLoading()) {
											// enable codeview
											$('.btn-codeview').first().removeClass('disabled').removeAttr('disabled', true);
										}
									}
								}, _this2.changeDelay);
								// !!!Send here the whole content #sender div instead of only the one element!!!
								_this2.changeEvent(contents, container[0].id);
							}
						});
					}
				}, {
					key: 'addFileDialog',
					value: function addFileDialog() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						// add button
						var ui = this.summernote.ui;
						var button = ui.button({
							contents: '<i class="glyphicon glyphicon-open-file"/>',
							tooltip: 'File',
							click: function click() {
								container.summernote('fileDialog.show');
							}
						});
						$('.note-btn-group.btn-group.note-insert').prepend(button.render());
					}
				}, {
					key: 'loadFileInit',
					value: function loadFileInit(files, text) {
						var _this3 = this;

						var container = arguments.length <= 2 || arguments[2] === undefined ? this.container : arguments[2];
						var image = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

						var type = localStorage.getItem('fileType') || 'ipfs';
						if (type === 'webtorrent') {
							// check for doublicated video, this has a browser bug, which eventuelly looses the blob
							var torrent = undefined;
							// TODO: adding videos twice breaks the blob link, this is most likely a bug in browsers
							if (!image && (torrent = this.WebTorrent.api.torrents.get(this.WebTorrent.api.createFilesId(files))) && torrent.sst_containsVideo && !confirm('Adding a video more than once is going to reset the videos of Sender and Receiver. Do you want to continue?')) {
								return;
							}
							this.loadFile(files, text, container);
						} else if (type === 'ipfs') {
							_get(Object.getPrototypeOf(EditorSummernote.prototype), 'loadFile', this).call(this, files, text, container, false).then(function (results) {
								var addSpacerAfter = results && results[0] && results[0].type && results[0].type[0] !== 'a';
								results.forEach(function (result) {
									var outerNode = result.audioVideo || result.source;
									outerNode.classList.add('ipfsLoading');
									// https://github.com/ipfs/js-ipfs/blob/master/docs/core-api/FILES.md#returns
									_this3.IPFS.add(result.name, result.content).then(function (file) {
										// sw do not intercept videos for streaming but give mimetype down
										file.link += '?filename=' + _this3.sanitizForInlineError(result.name) + (result.audioVideo ? '&audioVideo=true' : '');
										outerNode.classList.remove('ipfsLoading');
										// workaround for not showing any indication on loading the image when png (jpg's are covered with style.css background)
										if (result.type[0] === 'img') {
											outerNode.classList.add('img-bg');
											outerNode.addEventListener('load', function (event) {
												return outerNode.classList.remove('img-bg');
											});
										}
										// static error handling which also works at receiver
										if (result.type[0] === 'a') {
											outerNode.setAttribute('download', result.name);
											outerNode.setAttribute('onclick', _this3.IPFS.ipfs_onerror + '(event, \'' + file.link + '\', \'' + _this3.sanitizForInlineError(result.name) + '\', \'' + result.type + '\', ' + !!result.audioVideo + ', this);');
										} else {
											result.source.setAttribute('onerror', _this3.IPFS.ipfs_onerror + '(null, \'' + file.link + '\', \'' + _this3.sanitizForInlineError(result.name) + '\', \'' + result.type + '\', ' + !!result.audioVideo + ', this);');
										}
										result.source[result.type[1]] = file.link;
										// video wouldn't play on seeder if not newly set
										if (result.audioVideo) {
											result.audioVideo.innerHTML = result.audioVideo.innerHTML;
											result.audioVideo.classList.remove('ipfsLoading');
											// add a description
											if (result.name && outerNode.parentNode) {
												var figure = document.createElement('figure');
												var placeholder = document.createElement('span');
												figure.appendChild(placeholder);
												var figcaption = document.createElement('figcaption');
												figcaption.textContent = result.name;
												figure.appendChild(figcaption);
												outerNode.replaceWith(figure);
												placeholder.replaceWith(outerNode);
											}
										}
										_this3.changeEvent(_this3.getData(), container[0].id);
									})['catch'](function (error) {
										var errorMessageEl = document.createElement('span');
										errorMessageEl.textContent = 'IPFS failed: ' + error;
										outerNode.replaceWith(errorMessageEl);
										_this3.changeEvent(_this3.getData(), container[0].id);
									});
								});
								if (addSpacerAfter) _this3.setData(container, document.createElement('p'), 'insertNode'); // trying to get cursor focus after node
							});
						} else {
								_get(Object.getPrototypeOf(EditorSummernote.prototype), 'loadFile', this).call(this, files, text, container);
							}
					}
				}, {
					key: 'loadFile',
					value: function loadFile(files, text) {
						var _this4 = this;

						var container = arguments.length <= 2 || arguments[2] === undefined ? this.container : arguments[2];

						// append file
						var elementType = this.torrentNodeName;
						$.each(files, function (i, file) {
							if (file && (file.type.includes('video') || file.type.includes('audio'))) elementType = _this4.torrentNodeNameAudioVideo;
						});
						var node = document.createElement(elementType);
						node.id = this.Helper.createFilesId(files); // give each node an id, so that virtual-dom doesn't mix up things
						// disable codeview until file is loaded, otherwise it doesn't get added when in codeview
						$('.btn-codeview').first().addClass('disabled').attr('disabled', true);
						// console.log(App.Editor.areTorrentsLoading()); console.log(App.Editor.WebTorrent.torrents);  console.log(App.Editor.WebTorrent.client.torrents); console.log(App.Editor.WebTorrent.nodes);
						this.WebTorrent.api.seed(files, text, node, undefined, undefined, undefined, function (torrent) {
							// enable codeview
							if (!_this4.WebTorrent.api.areTorrentsLoading()) {
								$('.btn-codeview').first().removeClass('disabled').removeAttr('disabled', true);
							}
							_this4.changeEvent(_this4.getData(), container[0].id);
							torrent.on('error', function (error) {
								node.textContent = 'WebTorrent failed: ' + error;
								_this4.changeEvent(_this4.getData(), container[0].id);
							});
						});
						var p = document.createElement('p');
						this.setData(container, p, 'insertNode'); // trying to get cursor focus after node
						p.replaceWith(node);
					}
				}, {
					key: 'sanitizForInlineError',
					value: function sanitizForInlineError(str) {
						return encodeURIComponent(str.replace(/[\'\"\&\?\!\@\#\$\%\^\*\(\)\+\/\\]/g, ''));
					}
				}]);

				return EditorSummernote;
			})(MasterEditor);

			_export('EditorSummernote', EditorSummernote);
		}
	};
});
// Summernote supported codemirror version not available on github anymore

// plugins
$__System.registerDynamic('62', ['45', '50', '46'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('45'),
        core = $__require('50'),
        fails = $__require('46');
    module.exports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY],
            exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function () {
            fn(1);
        }), 'Object', exp);
    };
});
$__System.registerDynamic('8b', ['8c', '62'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toIObject = $__require('8c');
  $__require('62')('getOwnPropertyDescriptor', function ($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
});
$__System.registerDynamic('8d', ['35', '8b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('35');
  $__require('8b');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
});
$__System.registerDynamic("8e", ["8d"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("8d"), __esModule: true };
});
$__System.registerDynamic("5", ["8e"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$getOwnPropertyDescriptor = $__require("8e")["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null) object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
});
$__System.registerDynamic('8f', ['35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('35');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
});
$__System.registerDynamic("90", ["8f"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("8f"), __esModule: true };
});
$__System.registerDynamic('79', ['35', '40', '65', '38'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var getDesc = $__require('35').getDesc,
      isObject = $__require('40'),
      anObject = $__require('65');
  var check = function (O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {
      try {
        set = $__require('38')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
});
$__System.registerDynamic('91', ['45', '79'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('45');
  $export($export.S, 'Object', { setPrototypeOf: $__require('79').set });
});
$__System.registerDynamic('92', ['91', '50'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('91');
  module.exports = $__require('50').Object.setPrototypeOf;
});
$__System.registerDynamic("93", ["92"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("92"), __esModule: true };
});
$__System.registerDynamic("6", ["90", "93"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$create = $__require("90")["default"];
  var _Object$setPrototypeOf = $__require("93")["default"];
  exports["default"] = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, { constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      } });
    if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
});
$__System.registerDynamic('94', ['35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('35');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
});
$__System.registerDynamic("9", ["94"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("94"), __esModule: true };
});
$__System.registerDynamic("a", ["9"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$defineProperty = $__require("9")["default"];
  exports["default"] = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  exports.__esModule = true;
});
$__System.registerDynamic("7", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  exports["default"] = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  exports.__esModule = true;
});
$__System.registerDynamic("95", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function () {/* empty */};
});
$__System.registerDynamic("3d", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (done, value) {
    return { value: value, done: !!done };
  };
});
$__System.registerDynamic('55', ['70'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var cof = $__require('70');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
});
$__System.registerDynamic('8c', ['55', '3a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var IObject = $__require('55'),
      defined = $__require('3a');
  module.exports = function (it) {
    return IObject(defined(it));
  };
});
$__System.registerDynamic('96', ['95', '3d', '66', '8c', '3c'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var addToUnscopables = $__require('95'),
      step = $__require('3d'),
      Iterators = $__require('66'),
      toIObject = $__require('8c');
  module.exports = $__require('3c')(Array, 'Array', function (iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function () {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys') return step(0, index);
    if (kind == 'values') return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
});
$__System.registerDynamic('4f', ['96', '66'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('96');
  var Iterators = $__require('66');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
});
$__System.registerDynamic("68", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.1.4 ToInteger
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
});
$__System.registerDynamic("3a", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
});
$__System.registerDynamic('97', ['68', '3a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('68'),
      defined = $__require('3a');
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
});
$__System.registerDynamic("78", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = true;
});
$__System.registerDynamic('6b', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
});
$__System.registerDynamic('38', ['6b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var aFunction = $__require('6b');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };
});
$__System.registerDynamic('45', ['44', '50', '38'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('44'),
      core = $__require('50'),
      ctx = $__require('38'),
      PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {
        var F = function (param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
});
$__System.registerDynamic('73', ['36'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('36');
});
$__System.registerDynamic("98", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
});
$__System.registerDynamic("46", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
});
$__System.registerDynamic('42', ['46'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = !$__require('46')(function () {
    return Object.defineProperty({}, 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
});
$__System.registerDynamic('36', ['35', '98', '42'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('35'),
      createDesc = $__require('98');
  module.exports = $__require('42') ? function (object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
});
$__System.registerDynamic('99', ['35', '98', '47', '36', '67'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('35'),
      descriptor = $__require('98'),
      setToStringTag = $__require('47'),
      IteratorPrototype = {};
  $__require('36')(IteratorPrototype, $__require('67')('iterator'), function () {
    return this;
  });
  module.exports = function (Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + ' Iterator');
  };
});
$__System.registerDynamic("3f", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };
});
$__System.registerDynamic('47', ['35', '3f', '67'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var def = $__require('35').setDesc,
      has = $__require('3f'),
      TAG = $__require('67')('toStringTag');
  module.exports = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
      configurable: true,
      value: tag
    });
  };
});
$__System.registerDynamic("35", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
});
$__System.registerDynamic('3c', ['78', '45', '73', '36', '3f', '66', '99', '47', '35', '67'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var LIBRARY = $__require('78'),
      $export = $__require('45'),
      redefine = $__require('73'),
      hide = $__require('36'),
      has = $__require('3f'),
      Iterators = $__require('66'),
      $iterCreate = $__require('99'),
      setToStringTag = $__require('47'),
      getProto = $__require('35').getProto,
      ITERATOR = $__require('67')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function () {
    return this;
  };
  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base()));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
});
$__System.registerDynamic('4e', ['97', '3c'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $at = $__require('97')(true);
  $__require('3c')(String, 'String', function (iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function () {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length) return {
      value: undefined,
      done: true
    };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
});
$__System.registerDynamic('40', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
});
$__System.registerDynamic('65', ['40'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('40');
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
});
$__System.registerDynamic("70", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
});
$__System.registerDynamic('4a', ['70', '67'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var cof = $__require('70'),
        TAG = $__require('67')('toStringTag'),
        ARG = cof(function () {
        return arguments;
    }()) == 'Arguments';
    module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
    };
});
$__System.registerDynamic('9a', ['44'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var global = $__require('44'),
        SHARED = '__core-js_shared__',
        store = global[SHARED] || (global[SHARED] = {});
    module.exports = function (key) {
        return store[key] || (store[key] = {});
    };
});
$__System.registerDynamic('3e', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var id = 0,
      px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
});
$__System.registerDynamic('44', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});
$__System.registerDynamic('67', ['9a', '3e', '44'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var store = $__require('9a')('wks'),
        uid = $__require('3e'),
        Symbol = $__require('44').Symbol;
    module.exports = function (name) {
        return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
    };
});
$__System.registerDynamic("66", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = {};
});
$__System.registerDynamic('5e', ['4a', '67', '66', '50'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var classof = $__require('4a'),
        ITERATOR = $__require('67')('iterator'),
        Iterators = $__require('66');
    module.exports = $__require('50').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
    };
});
$__System.registerDynamic('50', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var core = module.exports = { version: '1.2.6' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
$__System.registerDynamic('9b', ['65', '5e', '50'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('65'),
      get = $__require('5e');
  module.exports = $__require('50').getIterator = function (it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
});
$__System.registerDynamic('9c', ['4f', '4e', '9b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('4f');
  $__require('4e');
  module.exports = $__require('9b');
});
$__System.registerDynamic("32", ["9c"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("9c"), __esModule: true };
});
$__System.register('19', ['7', '32', 'a'], function (_export) {
	var _classCallCheck, _getIterator, _createClass, MasterHelper;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_getIterator = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterHelper = (function () {
				function MasterHelper() {
					_classCallCheck(this, MasterHelper);

					this.baseURL = window.sst && window.sst.karma ? window.sst.karma : location.host.includes('github') ? 'PeerWebSite/' : '';

					// helper node for saveData / saveUrl / saveBlobUrl
					if (!(this.a = document.querySelector('#downloadHelperLink'))) {
						this.a = document.createElement('a');
						this.a.setAttribute('id', 'downloadHelperLink');
						document.body.appendChild(this.a);
						this.a.style = 'display: none';
					}

					var mimes = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma", "es"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/mrb-consumer+xml": ["*xdf"], "application/mrb-publish+xml": ["*xdf"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["*xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/ttml+xml": ["ttml"], "application/urc-ressheet+xml": ["rsheet"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-error+xml": ["xer"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
					this.mime = {
						getType: function getType(type) {
							var notFound = arguments.length <= 1 || arguments[1] === undefined ? 'text/plain' : arguments[1];

							type = type.split('.').splice(-1)[0];
							for (var key in mimes) {
								if (mimes[key].includes(type)) return key;
							}
							return notFound;
						},
						mimes: mimes
					};
				}

				_createClass(MasterHelper, [{
					key: 'addBaseURL',
					value: function addBaseURL() {
						var _this = this;

						var url = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
						var relative = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

						var locOrigin = relative ? '.' : location.href.match('.*\/') && location.href.match('.*\/')[0] || location.origin;
						return url.map(function (e) {
							if (!_this.baseURL && relative && e.includes('./')) return e;
							return locOrigin + '/' + (location.host.includes('github') && relative ? '' : _this.baseURL) + e.replace(':', '/');
						});
					}
				}, {
					key: 'getRandomString',
					value: function getRandomString() {
						if (window.crypto && window.crypto.getRandomValues && navigator.userAgent.indexOf('Safari') === -1) {
							var a = window.crypto.getRandomValues(new Uint32Array(3)),
							    token = '';
							for (var i = 0, l = a.length; i < l; i++) {
								token += a[i].toString(36);
							}
							return token;
						} else {
							return (Math.random() * new Date().getTime()).toString(36).replace(/\./g, '');
						}
					}

					/**
      * creates id's from files (api Hook)
      * 
      * @param {FileList} files 
      * @returns {number}
      * @memberof Helper
      */
				}, {
					key: 'createFilesId',
					value: function createFilesId(files) {
						if (!files.length) return this.createFileId(files[0] || files);
						var str = 0;
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
							for (var _iterator = _getIterator(files), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var file = _step.value;

								str += this.createFileId(file);
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}

						return str;
					}

					/**
      * creates id's from files (api Hook)
      * 
      * @param {File | FileList} file 
      * @returns {number}
      * @memberof Helper
      */
				}, {
					key: 'createFileId',
					value: function createFileId(file) {
						return this.getHash('' + file.lastModified + file.name + file.size);
					}
				}, {
					key: 'getHash',
					value: function getHash(str) {
						var hash = 0,
						    i = undefined,
						    chr = undefined;
						for (i = 0; i < str.length; i++) {
							chr = str.charCodeAt(i);
							hash = (hash << 5) - hash + chr;
							hash |= 0; // Convert to 32bit integer
						}
						return Math.abs(hash);
					}

					// save text
				}, {
					key: 'saveText',
					value: function saveText(text, fileName) {
						this.saveBlob(new Blob([text || 'empty'], { type: 'plain/text' }), fileName);
					}
				}, {
					key: 'saveBlob',
					value: function saveBlob(blob, fileName) {
						var url = window.URL.createObjectURL(blob);
						this.saveBlobUrl(url, fileName);
					}
				}, {
					key: 'saveBlobUrl',
					value: function saveBlobUrl(blobUrl, fileName) {
						var revoke = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

						this.saveUrl(blobUrl, fileName);
						if (revoke) window.URL.revokeObjectURL(blobUrl);
					}
				}, {
					key: 'saveUrl',
					value: function saveUrl(url) {
						var fileName = arguments.length <= 1 || arguments[1] === undefined ? 'untitled' : arguments[1];

						this.a.href = url;
						this.a.download = fileName;
						this.a.click();
					}
				}]);

				return MasterHelper;
			})();

			_export('MasterHelper', MasterHelper);
		}
	};
});
$__System.register('31', ['5', '6', '7', '19'], function (_export) {
  var _get, _inherits, _classCallCheck, MasterHelper, Helper;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      MasterHelper = _4.MasterHelper;
    }],
    execute: function () {
      /*jshint esnext: true */

      'use strict';

      Helper = (function (_MasterHelper) {
        _inherits(Helper, _MasterHelper);

        function Helper() {
          _classCallCheck(this, Helper);

          _get(Object.getPrototypeOf(Helper.prototype), 'constructor', this).apply(this, arguments);
        }

        return Helper;
      })(MasterHelper);

      _export('Helper', Helper);
    }
  };
});
$__System.register('9d', ['7', '31', 'a'], function (_export) {
	var _classCallCheck, Helper, _createClass, ServiceWorker;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			Helper = _2.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			ServiceWorker = (function () {
				function ServiceWorker(serviceWorkerPath, serviceWorkerScope, webTorrentGetBlobByFileNameArray, ipfsGetBlobByCidArray) {
					if (serviceWorkerPath === undefined) serviceWorkerPath = 'MasterServiceWorker.js';
					if (serviceWorkerScope === undefined) serviceWorkerScope = './';
					var infoFuncs = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];

					_classCallCheck(this, ServiceWorker);

					this.serviceWorkerPath = serviceWorkerPath;
					this.serviceWorkerScope = serviceWorkerScope;
					// array of getBlobByFileName of webtorrent receiver [0] and seeder [1]
					this.webTorrentGetBlobByFileNameArray = webTorrentGetBlobByFileNameArray;
					this.ipfsGetBlobByCidArray = ipfsGetBlobByCidArray;
					this.infoFuncs = infoFuncs;

					this.name = 'ServiceWorker';
					this.Worker = null;
					this.messageChannel = new MessageChannel();
					this.Helper = new Helper();
					// NOTE: Karma Tests don't work, more information at ./JavaScript/tests/ServiceWorker/ServiceWorker.js
					this.serviceWorkerPath = this.Helper.addBaseURL([this.serviceWorkerPath])[0];
					this.serviceWorkerScope = this.Helper.addBaseURL([this.serviceWorkerScope])[0];
				}

				_createClass(ServiceWorker, [{
					key: 'run',
					value: function run() {
						if (navigator.serviceWorker) {
							this.addReadyEventListener();
							this.register();
						} else {
							console.warn('SST:Service Worker is not supported in this browser.');
						}
					}

					// wait until the ServiceWorker is ready and then addMessageChannelEventListener
				}, {
					key: 'addReadyEventListener',
					value: function addReadyEventListener() {
						var _this = this;

						//console.log('@sw_helper listening to ready event');
						navigator.serviceWorker.ready.then(function (registration) {
							_this.Worker = registration.active;
							_this.addMessageChannelEventListener();
							// send port to service worker
							//console.log('@sw_helper sending port to ServiceWorker');
							_this.Worker.postMessage(location.origin, [_this.messageChannel.port2]);
							_this.version = _this.version;
						})['catch'](function (e) {
							console.error(e);
							_this.version = 'n/a';
						});
					}

					// gets executed on every message received from ServiceWorker
				}, {
					key: 'addMessageChannelEventListener',
					value: function addMessageChannelEventListener() {
						var _this2 = this;

						this.messageChannel.port1.onmessage = function (event) {
							if (event.data === '!!!ready') {
								//console.log('@sw_helper Intercept is ready!');
							} else if (Array.isArray(event.data) && event.data[0].includes('/')) {
									(function () {
										var name = event.data[0].split('/').slice(-1)[0];
										// Promise.all is not supported by jspm "buildConfig": { "transpileES6": true
										var blobs = [];
										var resolve = function resolve(newBlob) {
											var needsTwo = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

											blobs.push(newBlob);
											if (needsTwo && (blobs[0] === undefined || blobs[1] === undefined)) return false;
											var blob = blobs[0] || blobs[1];
											if (!blob) {
												_this2.Worker.postMessage([event.data, false]);
												return null;
											}
											var init = { status: 200, statusText: name, headers: [['content-type', blob.type || null]] };
											init.headers.push(['accept-ranges', 'bytes']);
											blob.arrayBuffer().then(function (arrayBuffer) {
												init.headers.push(['content-length', arrayBuffer.byteLength]);
												init.headers.push(['content-range', 'bytes 0-' + (arrayBuffer.byteLength - 1) + '/' + arrayBuffer.byteLength]);
											})['finally'](function () {
												return _this2.Worker.postMessage([event.data, [blob, init]]);
											});
											return !!blob;
										};
										// only ask one instance of webtorrent when there is a magnetURI to resolve !!!if you change this, change equal at JavaScript/js/WebTorrent/Prototype/Domain/MasterWebTorrent.js.getBlobByFileName!!!
										if (name.includes('magnet:') || event.data[0].includes('magnet/') || name.includes('?xt=urn:')) {
											// promise returns null or blob
											_this2.webTorrentGetBlobByFileNameArray[0](name).then(function (blob) {
												return resolve(blob);
											});
										} else if (event.data[0].includes('ipfs/')) {
											_this2.ipfsGetBlobByCidArray[0](event.data[0]).then(function (blob) {
												return resolve(blob);
											});
										} else {
											// promise returns null or blob
											_this2.webTorrentGetBlobByFileNameArray[0](name).then(function (blob) {
												return resolve(blob, true);
											});
											_this2.webTorrentGetBlobByFileNameArray[1](name).then(function (blob) {
												return resolve(blob, true);
											});
										}
									})();
								} else if (Array.isArray(event.data) && event.data[0] === 'info') {
									_this2.infoFuncs.forEach(function (func) {
										return func(event.data[1]);
									});
								} else if (Array.isArray(event.data) && event.data[0] === 'version') {
									_this2.version = event.data[1];
								} else {
									_this2.Worker.postMessage([event.data, false]);
								}
						};
					}

					// register the service worker
				}, {
					key: 'register',
					value: function register() {
						//console.log(`@sw_helper register: ${this.serviceWorkerPath}; with scope: ${this.serviceWorkerScope}`);
						navigator.serviceWorker.register(this.serviceWorkerPath, { scope: this.serviceWorkerScope }).then(function (registration) {
							registration.update();
							//console.log('@sw_helper registered', registration);
						})['catch'](function (e) {
							console.error(e);
						});
					}
				}, {
					key: 'version',
					set: function set(version) {
						$('#sw-version').text('; sw-v. ' + version);
						localStorage.setItem('sw-version', version);
					},
					get: function get() {
						return localStorage.getItem('sw-version');
					}
				}]);

				return ServiceWorker;
			})();

			_export('ServiceWorker', ServiceWorker);
		}
	};
});
$__System.register('9e', ['7', '22', '52', '58', '59', 'a', '2b', '2c', '8a', '9d'], function (_export) {
	var _classCallCheck, WebRTC, WebTorrentReceiver, IPFS, EncryptDecrypt, _createClass, HTML, WebTorrentSeeder, EditorSummernote, ServiceWorker, MasterApp;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			WebRTC = _2.WebRTC;
		}, function (_3) {
			WebTorrentReceiver = _3.WebTorrentReceiver;
		}, function (_4) {
			IPFS = _4.IPFS;
		}, function (_5) {
			EncryptDecrypt = _5.EncryptDecrypt;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_b) {
			HTML = _b.HTML;
		}, function (_c) {
			WebTorrentSeeder = _c.WebTorrentSeeder;
		}, function (_a2) {
			EditorSummernote = _a2.EditorSummernote;
		}, function (_d) {
			ServiceWorker = _d.ServiceWorker;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterApp = (function () {
				function MasterApp() {
					_classCallCheck(this, MasterApp);

					this.isSender = !location.hash || (localStorage.getItem('channels') || '').includes('[' + location.hash + ']');
					this.WebRTC = new WebRTC();
					this.WebTorrentReceiver = new WebTorrentReceiver();
					this.WebTorrentSeeder = new WebTorrentSeeder();
					this.IPFS = new IPFS(this.isSender);
					this.EncryptDecrypt = new EncryptDecrypt();
					this.Editor = new EditorSummernote(this.WebTorrentSeeder, this.IPFS);
					this.HTML = new HTML(this.WebTorrentReceiver, this.WebTorrentSeeder, this.Editor, this.WebRTC, this.IPFS, this.EncryptDecrypt, this);
					this.ServiceWorker = new ServiceWorker(undefined, undefined, [this.WebTorrentReceiver.getBlobByFileName.bind(this.WebTorrentReceiver), this.WebTorrentSeeder.getBlobByFileName.bind(this.WebTorrentSeeder)], [this.IPFS.getBlobByFileCID.bind(this.IPFS)], [this.IPFS.pinIfSender.bind(this.IPFS)]);
					this.ServiceWorker.run();

					// hot-reloader clear all
					//if(window.sst && window.sst.isDebug){
					window.App = this;
					//}
				}

				_createClass(MasterApp, [{
					key: 'createElements',
					value: function createElements(name, isSender) {
						return this.HTML.createElements(name, undefined, this.WebRTC.connection, isSender);
					}
				}]);

				return MasterApp;
			})();

			_export('MasterApp', MasterApp);
		}
	};
});
$__System.register('9f', ['5', '6', '7', 'a', '9e'], function (_export) {
	var _get, _inherits, _classCallCheck, _createClass, MasterApp, App;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_e) {
			MasterApp = _e.MasterApp;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			App = (function (_MasterApp) {
				_inherits(App, _MasterApp);

				function App() {
					_classCallCheck(this, App);

					_get(Object.getPrototypeOf(App.prototype), 'constructor', this).call(this);

					this.receiverWaitMs = 60000; // 1min
				}

				_createClass(App, [{
					key: 'createElements',
					value: function createElements() {
						var _this = this;

						var name = arguments.length <= 0 || arguments[0] === undefined ? 'open-or-join-room' : arguments[0];

						document.body.setAttribute('isSender', this.isSender);
						this.checkHashType(location.hash); // sets attribute for hash type magnet, ipfs, webrtc
						this.originalHash = location.hash;
						var htmlElements = _get(Object.getPrototypeOf(App.prototype), 'createElements', this).call(this, name, this.isSender);
						var sendCont = htmlElements[0];
						this.receiveCont = htmlElements[1];
						var button = htmlElements[2]; // WebRTC Button
						this.counterWebTorrent = htmlElements[3];

						this.Editor.add(sendCont); // initiate before .WebTorrentSeeder.container
						this.WebTorrentReceiver.container = this.receiveCont[0]; // set the dom scope for the WebTorrent clients
						// reactivating torrents from save has strange sideeffects
						/*this.WebTorrentReceiver.addByText(this.WebTorrentReceiver.container.innerHTML, [
      	// trigger the following, when the worker returns with dataPack.message -> this.Dom.setData(container, oldMessage, dataPack.message);
      	new Map([
      		['function', ()=>{}],
      		['scope', this],
      		['attributes', ['none']],
      	])
      ]);*/
						this.WebTorrentSeeder.container = sendCont[0].nextSibling.getElementsByClassName('note-editable')[0]; // dom scope not set for Seeder. 1: SummerNote changes the active container, 2: its only used at removeDeletedNodes
						// reactivating torrents from save has strange sideeffects
						/*this.WebTorrentSeeder.addByText(this.WebTorrentSeeder.container.innerHTML, [
      	// trigger the following, when the worker returns with dataPack.message -> this.Dom.setData(container, oldMessage, dataPack.message);
      	new Map([
      		['function', ()=>{}],
      		['scope', this],
      		['attributes', ['none']],
      	])
      ]);*/
						this.setReceiverOrSender(this.isSender);

						this.WebRTC.api.isSender[0] = this.isSender;
						// *** Events Triggert by DOM ***
						// openOrJoinEvent(roomid, message = '', elID = '')
						this.HTML.attachButtonEvent(button, sendCont, this.Editor.getData, this.WebRTC.api.openOrJoinEvent, this.isSender);
						if (this.isSender) {
							// Seeder/Sender
							// sendEvent(message, elID = 'sst_all', remoteUserId = 'sst_toAll', requestID = '', options = new Map([['diffed', true], ['compressed', 'auto']])
							this.Editor.attachChangeEvent(sendCont, this.WebRTC.api.sendEvent);
							// *** Events Triggert by Connection ***
							// onNewParticipant.add(newMessageFunc, scope = this, args = []) ==> has to return [message = '', elID = '']
							this.WebRTC.api.onNewParticipant.add(function (remoteUserId) {
								return [this.Editor.getData(), this.Editor.container[0].id];
							}, this);
							// expose download all torrents to global scope
							window.getAllTorrents = this.WebTorrentSeeder.api.getAllTorrents;
							window.getAllTorrentFiles = this.WebTorrentSeeder.api.getAllTorrentFiles;
						} else {
							// Receiver
							// expose download all torrents to global scope
							window.getAllTorrents = this.WebTorrentReceiver.api.getAllTorrents;
							window.getAllTorrentFiles = this.WebTorrentReceiver.api.getAllTorrentFiles;
						}
						// onReceive.add(newMessageFunc, scope = this, args = [])
						this.WebRTC.api.onReceive.add(function (dataPack) {
							this.HTML.setData(this.receiveCont, dataPack);
						}, this);
						// reconnect on tab focus
						var visibilityTimeOutID = null;
						document.addEventListener('visibilitychange', function () {
							clearTimeout(visibilityTimeOutID);
							visibilityTimeOutID = setTimeout(function () {
								// check if active webrtc session
								if (document.visibilityState === 'visible' && _this.checkHashType(location.hash) === 'webrtc') {
									$('#open-or-join-room').click();
								}
							}, 200);
						});
						// save
						window.addEventListener('beforeunload', function (e) {
							/*
       // Cancel the event
       e.preventDefault(); // If you prevent default behavior in Mozilla Firefox prompt will always be shown
       // Chrome requires returnValue to be set
       e.returnValue = '';
       */
							// persist site
							var hash = _this.originalHash || location.hash;
							var data = _this.isSender ? _this.Editor.getData() : _this.receiveCont[0].innerHTML;
							_this.HTML.saveData(hash, data);
						});
						// online / offline
						var onlineOffline = function onlineOffline(event) {
							if (navigator.onLine) {
								$('.offline').hide();
							} else {
								$('.offline').show();
							}
						};
						onlineOffline();
						window.addEventListener('online', onlineOffline);
						window.addEventListener('offline', onlineOffline);
						// connect by hash
						this.connectHash(false);
						window.addEventListener('hashchange', function () {
							return _this.connectHash();
						});
					}
				}, {
					key: 'connectHash',
					value: function connectHash() {
						var _this2 = this;

						var reload = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

						// logic for receiver
						if (!this.isSender) {
							// triggered by hashchange
							if (reload) {
								location.reload();
								// manually triggered
							} else if (this.checkHashType(location.hash) === 'magnet') {
									(function () {
										var timeout = setTimeout(function () {
											return location.reload();
										}, _this2.receiverWaitMs);
										var torrent = _this2.WebTorrentReceiver.add(location.hash.substr(1), undefined, undefined, undefined, undefined, function (torrent) {
											if (torrent.files && torrent.files[0] && torrent.files[0].name.includes('peerWebSite')) {
												clearTimeout(timeout);
												torrent.files[0].getBlob(function (err, blob) {
													var reader = new FileReader();
													reader.onload = (function (reader) {
														return function () {
															var contents = reader.result;
															var setData = function setData(text) {
																return _this2.HTML.setData(_this2.receiveCont, { message: text }, false);
															};
															_this2.EncryptDecrypt.decrypt(contents, undefined, setData).then(function (result) {
																var text = result.text;
																var decrypted = result.decrypted;

																// if decryption failed by not entering a password but there is already a localStorage with the content, then don't set the data
																if (decrypted !== 'failed' || !localStorage.getItem(location.hash)) setData(text);
																_this2.HTML.setTitle(_this2.HTML.getFirstText(_this2.HTML.getData(_this2.receiveCont)));
															})['catch'](function (error) {
																return $('#receiver').text('Decrypt; an Error occured! ' + error);
															});
														};
													})(reader);
													reader.readAsText(blob);
												});
											} else {
												$('#receiver').text('An Error occured!');
											}
											_this2.WebTorrentReceiver.findAllNodes(torrent);
											if (!_this2.WebTorrentReceiver.areTorrentsLoading()) _this2.WebTorrentReceiver.ProgressBar.end();
										});
										var webTorrentCounterID = setInterval(function () {
											_this2.counterWebTorrent[0].textContent = '[' + torrent.numPeers + ' peer' + (torrent.numPeers === 1 ? '' : 's') + ']';
										}, 1000);
										_this2.WebTorrentReceiver.client.on('error', function () {
											clearInterval(webTorrentCounterID);
											_this2.counterWebTorrent[0].textContent = '[ERROR! Please, reload.]';
										});
										torrent.sst_id = 'peerWebSite';
										if (!localStorage.getItem(location.hash)) {
											var progressBarNode = document.createElement('span');
											$('#receiver').html(progressBarNode);
											torrent.sst_nodes = [progressBarNode];
											_this2.WebTorrentReceiver.findAllNodes(torrent); // to have nodes where the progressbar can attach to
											_this2.WebTorrentReceiver.ProgressBar.start();
										}
										$('.headerReceiver > .counterWebRTC').hide();
									})();
								} else if (this.checkHashType(location.hash) === 'ipfs') {
									(function () {
										var timeout = setTimeout(function () {
											return location.reload();
										}, _this2.receiverWaitMs);
										var cid = location.hash.substr(6);
										_this2.IPFS.raceFetchVsCat(cid, 'text', '?filename=peerWebSite.txt').then(function (text) {
											clearTimeout(timeout);
											_this2.IPFS.pinCid(cid);
											var setData = function setData(text) {
												return _this2.HTML.setData(_this2.receiveCont, { message: text });
											};
											_this2.EncryptDecrypt.decrypt(text, undefined, setData).then(function (result) {
												var text = result.text;
												var decrypted = result.decrypted;

												// if decryption failed by not entering a password but there is already a localStorage with the content, then don't set the data
												if (decrypted !== 'failed' || !localStorage.getItem(location.hash)) setData(text);
												_this2.HTML.setTitle(_this2.HTML.getFirstText(_this2.HTML.getData(_this2.receiveCont)));
											})['catch'](function (error) {
												return $('#receiver').text('Decrypt; an Error occured! ' + error);
											});
										})['catch'](function (error) {
											return $('#receiver').text('IPFS; an Error occured! ' + error);
										});
										$('.headerReceiver > .counterWebRTC').hide();
										$('.headerReceiver > .counterWebTorrent').hide();
									})();
								} else {
									$('#txt-roomid').val(location.hash.substr(1));
									// don't change on button click change hash, since this double triggers
									if (this.originalHash === location.hash) $('#open-or-join-room').click();
									this.originalHash = location.hash;
									$('.headerReceiver > .counterWebTorrent').hide();
								}
							// logic for sender
						} else if (reload && location.hash && !(localStorage.getItem('channels') || '').includes('[' + location.hash + ']')) {
								location.reload();
							} else if (!reload && this.checkHashType(location.hash) === 'ipfs') {
								(function () {
									// on intial load not on hash change, fetch IPFS data
									if (_this2.Editor.getData().length < 12) _this2.Editor.setData(undefined, _this2.HTML.loadingAnimation, 'code');
									var cid = location.hash.substr(6);
									_this2.IPFS.raceFetchVsCat(cid, 'text', '?filename=peerWebSite.txt').then(function (text) {
										_this2.IPFS.pinCid(cid);
										var setData = function setData(text) {
											return _this2.Editor.setData(undefined, text, 'code');
										};
										_this2.EncryptDecrypt.decrypt(text, undefined, setData).then(function (result) {
											var text = result.text;
											var decrypted = result.decrypted;

											// if decryption failed by not entering a password but there is already a localStorage with the content, then don't set the data
											if (decrypted !== 'failed' || !localStorage.getItem(location.hash)) setData(text);
											_this2.HTML.setTitle();
										})['catch'](function (error) {
											return $('#sender').text('Decrypt; an Error occured! ' + error);
										});
									})['catch'](function (error) {
										return $('#sender').text('IPFS; an Error occured! ' + error);
									});
								})();
							}
					}
				}, {
					key: 'setReceiverOrSender',
					value: function setReceiverOrSender(isSender) {
						if (!isSender) {
							// it is assumed that this is a viewer only
							$('#controls, #sender, .note-editor, .mui-btn').hide();
							$('body').addClass('viewer');
							return true;
						} else {
							$('.headerReceiver').hide();
						}
					}
				}, {
					key: 'checkHashType',
					value: function checkHashType() {
						var hash = arguments.length <= 0 || arguments[0] === undefined ? location.hash : arguments[0];

						if (!hash) {
							document.body.removeAttribute('type');
							return false;
						}
						if (hash.includes('magnet:')) {
							document.body.setAttribute('type', 'magnet');
							return 'magnet'; // WebTorrent
						}
						if (hash.includes('ipfs:')) {
							document.body.setAttribute('type', 'ipfs');
							return 'ipfs'; // IPFS
						}
						document.body.setAttribute('type', 'webrtc');
						return 'webrtc';
					}
				}]);

				return App;
			})(MasterApp);

			_export('App', App);
		}
	};
});
$__System.register('a0', ['9f'], function (_export) {
  /*jshint esnext: true */

  'use strict';

  var App, App1;
  return {
    setters: [function (_f) {
      App = _f.App;
    }],
    execute: function () {
      App1 = new App();

      App1.createElements();
    }
  };
});
$__System.register('2', ['a0'], function (_export) {
  /*jshint esnext: true */

  'use strict';

  return {
    setters: [function (_a0) {}],
    execute: function () {}
  };
});
})
(function(factory) {
  factory();
});
//# sourceMappingURL=webRTC.js.map